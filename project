#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"App/Project.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PROJECT';
  package App::Project;
  use 5.008001;
  use strict;
  use warnings;
  use version; our $VERSION = version->declare("v0.0.0");
  
  use Time::Piece qw(gmtime);
  
  our $DEBUG;
  
  sub debug { $DEBUG }
  
  sub new {
      my ($class, @args) = @_;
      my $self = bless {@args}, $class;
      $self->{version} // die 'Must specifies version!';
      $self->{changes_time} = scalar(gmtime());
      return $self;
  }
  
  sub version { return shift->{version}; }
  
  sub changes_time { return shift->{changes_time}; }
  
  1;
  __END__
  
  =encoding utf-8
  
  =head1 NAME
  
  App::Project - [DRAFT] Generic authoring tool(not only for perl project).
  
  =head1 SYNOPSIS
  
      project changes      - Ready to change log for release
      project untracks     - Show untracked files
      project dist         - (not yet) Make your dist tarball
      project migrate      - (not yet) Set up your project ready for this tool
      project release      - Make release tag and push
      project bump_version - Bump version for next release
      project wrapper      - (not yet) Output raw script source to stdout
  
  =head1 THIS IS DRAFT
  
  I'm going to implements this modules.
  
  And thinking about this name because L<App::Project> naming is uncool name :(
  
  =head1 DESCRIPTION
  
  App::Project is a application authoring tool. App::Project provides I<project> command as authoring tool for application project.
  
  App::Project is not only for Perl project.
  
  App::Project inspire of Minilla(as CPAN module auhtoring tool).
  
  B<THIS IS A DEVELOPMENT RELEASE. API MAY CHANGE WITHOUT NOTICE>.
  
  =head1 GETTING STARTED
  
      # First time only
      # TODO: Provide fat pack tool
      % cpanm App::Project
      # App::Project has only a few deps. It should be very quick
      # Make a new distribution
      % cd /path/to/App/
      % project migrate
      # Git commit
      % git commit -m "initial commit"
      # Hack your code!
      % $EDITOR lib/YourCode
      # Done? Test and release it!
      # Make L<git tag> and update change log for release
      % project release
      # Need more portability tool? We provide to generate L<>
      % project wrapper > bin/project
  
  
  It's that easy.
  
  =head1 NOTE
  
  =head2 Why made?
  
  I need generic authoring tool. (e.g. Android application, HTML5 application, and other)
  
  I was impressed L<Minilla>. And I decide make this project.
  
  =head2 Why Perl?
  
  Perl script is high portability, A lot of operation system is installed Perl. 
  
  Make simple script with comparative ease. I don't have plan to be complex interfaces ;)
  
  =head2 App::Project is built on small libraries.
  
  App::Project is built on only few small libraries. You can install App::Project without a huge list of dependencies to heavy modules.
  
  And dependencies are pure perl or perl core(5.12.0+) only, because to higher portability for I<wrapper> script.
  
  =head1 LICENSE
  
  Copyright (C) ichigotake.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 AUTHOR
  
  ichigotake E<lt>ichigotake.san@gmail.comE<gt>
  
  =head1 SEE ALSO
  
  =item1 L<Minilla>
  
  =cut
  
APP_PROJECT

$fatpacked{"App/Project/BumpVersion.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PROJECT_BUMPVERSION';
  package App::Project::BumpVersion;
  use 5.008001;
  use strict;
  use warnings;
  use ExtUtils::MakeMaker qw(prompt);
  use Getopt::Long;
  use version;
  use Version::Next;
  use App::Project::Logger;
  
  sub new {
      my $class = shift;
      return bless {@_}, $class;
  }
  
  sub run {
      my ($self, @args) = @_;
      local @ARGV = @args;
      my $validate = 0;
      my $res = GetOptions (
          'validate!' => \$validate,
      );
      my $current_version = shift(@ARGV) // '0.1';
  
      my $is_valid = version::is_lax($current_version);
      if ($validate) {
          if (!$is_valid) {
              errorf("Sorry, version '%s' is invalid.  Stopping.\n", $current_version);
              return "";
          }
          return $current_version;
      }
      return $self->default_new_version($current_version);
  }
  
  sub default_new_version {
      my ($self, $version) = @_;
      @_ == 2 or die;
  
      if (not exists_tag($version)) {
          $version;
      } else {
          return Version::Next::next_version("$version");
      }
  }
  
  sub exists_tag {
      my ( $tag ) = @_;
  
      my $x = `git tag -l $tag`;
      chomp $x;
      return !!$x;
  }
  
  
  1;
  
APP_PROJECT_BUMPVERSION

$fatpacked{"App/Project/CLI.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PROJECT_CLI';
  package App::Project::CLI;
  use strict;
  use warnings;
  use utf8;
  use Getopt::Long;
  use Module::Load;
  use App::Project::Errors;
  use App::Project::Logger;
  use App::Project::Util;
  
  sub new {
      my $class = shift;
      return bless {@_}, $class;
  }
  
  sub run {
      my ($self, @args) = @_;
      my $cmd_name = shift @args;
      if (!$cmd_name) {
          $self->show_usage();
          return;
      }
      
      local @ARGV = @args;
      my $cmd = $self->load_sub_cmd($cmd_name);
      if (!$cmd) {
          $self->show_usage();
          return;
      }
      $cmd->run(@args);
  }
  
  sub show_usage {
      print "TBD: show usage\n";
  }
  
  1;
  
APP_PROJECT_CLI

$fatpacked{"App/Project/CLI/BumpVersion.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PROJECT_CLI_BUMPVERSION';
  package App::Project::CLI::BumpVersion;
  use strict;
  use warnings;
  use utf8;
  use App::Project::BumpVersion;
  
  sub run {
      my ($self, @args) = @_;
      my $res = App::Project::BumpVersion->new()->run(@args);
      exit 1 unless $res;
      print $res;
  }
  
  1;
  
APP_PROJECT_CLI_BUMPVERSION

$fatpacked{"App/Project/CLI/Changes.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PROJECT_CLI_CHANGES';
  package App::Project::CLI::Changes;
  use strict;
  use warnings;
  use utf8;
  
  use Getopt::Long;
  use App::Project;
  use App::Project::Flow::CheckChanges;
  use App::Project::Flow::RewriteChanges;
  use App::Project::Logger;
  
  sub run {
      my ($self, @args) = @_;
      local @ARGV = @args;
      my $dry_run;
      GetOptions("--dry-run!" => $dry_run);
      my $version = shift(@args) or die 'Must specifies version name!';
      my $project = App::Project->new(version => $version);
      App::Project::Flow::CheckChanges->new()->run($project, \@args);
  
      if ($dry_run) {
          return;
      }
      App::Project::Flow::RewriteChanges->new()->run($project, \@args);
  
  }
  
  1;
  
APP_PROJECT_CLI_CHANGES

$fatpacked{"App/Project/CLI/Release.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PROJECT_CLI_RELEASE';
  package App::Project::CLI::Release;
  use strict;
  use warnings;
  use utf8;
  
  use Getopt::Long;
  use App::Project;
  use App::Project::Flow::Commit;
  use App::Project::Flow::Tag;
  use App::Project::Logger;
  
  sub run {
      my ($self, @args) = @_;
      my $version = shift(@args) or die 'Must specifies version name!';
      my $dry_run;
      my $res = GetOptions("dry-run!" => \$dry_run);
      if ($dru_run) {
          infof("DRY-RUN.  Would have tagged version $ver.\n");
          return;
      }
      my $project = App::Project->new(version => $version);
      App::Project::Flow::Commit->new()->run($project, {@args});
      App::Project::Flow::Tag->new()->run($project, {@args});
  }
  
  1;
  
APP_PROJECT_CLI_RELEASE

$fatpacked{"App/Project/CLI/Untracks.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PROJECT_CLI_UNTRACKS';
  package App::Project::CLI::Untracks;
  use strict;
  use warnings;
  use utf8;
  use App::Project::Logger;
  use App::Project::CheckUntrackedFiles;
  
  sub run {
      my ($self, $command, $args, $options) = @_;
      my @untracks = App::Project::CheckUntrackedFiles->new()->run();
      if (!@untracks) {
          my $unk = join("\n", @untracks);
          errorf("Unknown local files:\n$unk\n\nUpdate .gitignore, or git add them\n");
      }
      print join("\n", @untracks);
  }
  
  1;
  
APP_PROJECT_CLI_UNTRACKS

$fatpacked{"App/Project/CheckUntrackedFiles.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PROJECT_CHECKUNTRACKEDFILES';
  package App::Project::CheckUntrackedFiles;
  use strict;
  use warnings;
  use utf8;
  
  use App::Project::Logger;
  
  sub new {
      my $class = shift;
      return bless {@_}, $class;
  }
  
  sub run {
      my ($self) = @_;
      my $unk = `git ls-files -z --others --exclude-standard`;
      return split("\0", $unk);
  }
  
  1;
  
  __END__
  
  =encoding utf-8
  
  =head1 NAME
  
  App::Project::CheckUntrackedFiles
  
  =head1 DESCRIPTION
  
  Copy from L<Minilla::Release::CheckUntrackedFiles>.
  
APP_PROJECT_CHECKUNTRACKEDFILES

$fatpacked{"App/Project/Errors.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PROJECT_ERRORS';
  package App::Project::Errors;
  use strict;
  use warnings;
  use utf8;
  
  use Carp ();
  
  package App::Project::Error::CommandExit;
  
  use overload '""' => 'message', fallback => 1;
  
  sub throw {
      my ($class, $body) = @_;
      my $self = bless { body => $body, message => Carp::longmess($class) }, $class;
      die $self;
  }
  
  sub body { shift->{body} }
  
  sub message {
      my($self) = @_;
      return $self->{message};
  }
  
  1;
  
APP_PROJECT_ERRORS

$fatpacked{"App/Project/Flow/CheckChanges.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PROJECT_FLOW_CHECKCHANGES';
  package App::Project::Flow::CheckChanges;
  use strict;
  use warnings;
  use utf8;
  use ExtUtils::MakeMaker qw(prompt);
  
  use App::Project::Util qw(edit_file slurp);
  use App::Project::Logger;
  
  sub new {
      my $class = shift;
      return bless {@_}, $class;
  }
  
  sub run {
      my ($self, $project, $opts) = @_;
      $project->version or die 'Must specifies version name!';
  
      if ($ENV{PERL_APP_PROJECT_CHECK_CHANGE_LOG}) {
          infof("Okay, you are debugging now.\n");
          return;
      }
  
      until (slurp('Changes') =~ /^\{\{\$NEXT\}\}\n+[ \t]+\S/m) {
          infof("No mention of version '%s' in changelog file 'Changes'\n", $project->version);
          if (prompt("Edit file?", 'y') =~ /y/i) {
              edit_file('Changes');
          } else {
              errorf("Giving up!\n");
          }
      }
  }
  
  1;
  
APP_PROJECT_FLOW_CHECKCHANGES

$fatpacked{"App/Project/Flow/Commit.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PROJECT_FLOW_COMMIT';
  package App::Project::Flow::Commit;
  use strict;
  use warnings;
  use utf8;
  
  use App::Project::Util qw(cmd);
  use App::Project::Logger;
  
  sub new {
      my $class = shift;
      return bless {@_}, $class;
  }
  
  sub run {
      my ($self, $project, $opts) = @_;
  
      my @modified_files = split /\0/, `git ls-files --deleted --modified -z`;
      return if @modified_files == 0;
  
      my $ver = $project->version;
  
      my $msg = "Checking in changes prior to tagging of version $ver.\n\nChangelog diff is:\n\n";
      $msg .= `git diff Changes`;
  
      if ($opts->{dry_run} // undef) {
          infof("DRY-RUN.  Would have committed message of:\n----------------\n$msg\n-----------\n");
          return;
      }
  
      cmd('git', 'commit', '-a', '-m', $msg);
  
      $self->_push_to_origin();
  }
  
  sub _push_to_origin {
      my ($self) = @_;
  
      # git v1.7.10 is required?
      my $branch = _get_branch()
          or return;
      $branch =~ s/\n//g;
      infof("Pushing to origin\n");
      cmd('git', 'push', 'origin', $branch);
  }
  
  sub _get_branch {
      open my $fh, '<', '.git/HEAD';
      chomp( my $head = do { local $/; <$fh> });
      close $fh;
  
      my ($branch) = $head =~ m!ref: refs/heads/(\S+)!;
      return $branch;
  }
  
  1;
  
APP_PROJECT_FLOW_COMMIT

$fatpacked{"App/Project/Flow/RewriteChanges.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PROJECT_FLOW_REWRITECHANGES';
  package App::Project::Flow::RewriteChanges;
  use strict;
  use warnings;
  use utf8;
  use App::Project::Util qw(slurp_raw spew_raw);
  
  sub new {
      my $class = shift;
      return bless {@_}, $class;
  }
  
  sub run {
      my ($self, $project, $opts) = @_;
      return if $opts->{dry_run};
  
      my $content = slurp_raw('Changes');
      $content =~ s!\{\{\$NEXT\}\}!
          "{{\$NEXT}}\n\n" . $project->version. " " . $project->changes_time->strftime('%Y-%m-%dT%H:%M:%SZ')
          !e;
      spew_raw('Changes' => $content);
  }
  
  
  1;
  
APP_PROJECT_FLOW_REWRITECHANGES

$fatpacked{"App/Project/Flow/Tag.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PROJECT_FLOW_TAG';
  package App::Project::Flow::Tag;
  use strict;
  use warnings;
  use utf8;
  
  use App::Project::Util qw(cmd);
  use App::Project::Logger;
  
  sub run {
      my ($self, $project, $opts) = @_;
      my $version = $project->version;
  
      if ( $opts->{dry_run} ) {
          infof("DRY-RUN.  Would have tagged version $version.\n");
          return;
      }
  
      my $tag = $project->format_tag($version);
      cmd('git', 'tag', $tag);
      cmd('git', "push", 'origin', tag => $tag);
  }
  
  1;
  
APP_PROJECT_FLOW_TAG

$fatpacked{"App/Project/Git.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PROJECT_GIT';
  package App::Project::Git;
  use strict;
  use warnings;
  use utf8;
  
  use parent qw(Exporter);
  use App::Project::Util;
  
  our @EXPORT = qw(git_init git_add git_commit);
  
  sub git_init {
      cmd('git', 'init');
  }
  
  sub git_add {
      cmd('git', 'add', @_ ? @_ : '.');
  }
  
  sub git_commit {
      cmd('git', 'commit', @_);
  }
  
  1;
  
APP_PROJECT_GIT

$fatpacked{"App/Project/Logger.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PROJECT_LOGGER';
  package App::Project::Logger;
  use 5.008001;
  use strict;
  use warnings;
  use utf8;
  use parent qw(Exporter);
  
  use Term::ANSIColor qw(colored);
  require Win32::Console::ANSI if $^O eq 'MSWin32';
  
  use App::Project::Errors;
  
  our @EXPORT = qw(debugf infof warnf errorf);
  
  our $COLOR;
  
  use constant { DEBUG => 1, INFO => 2, WARN => 3, ERROR => 4 };
  
  our $Colors = {
      DEBUG,   => 'green',
      WARN,    => 'yellow',
      INFO,    => 'cyan',
      ERROR,   => 'red',
  };
  
  sub _printf {
      my $type = pop;
      my($temp, @args) = @_;
      _print(sprintf($temp, map { defined($_) ? $_ : '-' } @args), $type);
  }
  
  sub _print {
      my($msg, $type) = @_;
      return if $type == DEBUG && !App::Project->debug;
      $msg = colored $msg, $Colors->{$type} if defined $type && $COLOR;
      my $fh = $type && $type >= WARN ? *STDERR : *STDOUT;
      print {$fh} $msg;
  }
  
  sub infof {
      _printf(@_, INFO);
  }
  
  sub warnf {
      _printf(@_, WARN);
  }
  
  sub debugf {
      _printf(@_, DEBUG);
  }
  
  sub errorf {
      my(@msg) = @_;
      _printf(@msg, ERROR);
  
      my $fmt = shift @msg;
      App::Project::Error::CommandExit->throw(sprintf($fmt, @msg));
  }
  
  1;
  
APP_PROJECT_LOGGER

$fatpacked{"App/Project/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PROJECT_UTIL';
  package App::Project::Util;
  use strict;
  use warnings;
  use utf8;
  use parent qw(Exporter);
  
  use App::Project::Logger;
  use Cwd();
  use File::Basename qw(basename);
  use Module::Load;
  
  our @EXPORT = qw(camelize cmd edit_file load_sub_cmd slurp slurp_raw spew_raw);
  
  sub camelize {
      my ($target) = @_;
      $target =~ s/(_|^)(.)/\u$2/g;
      return $target;
  }
  
  sub cmd {
      App::Project::Logger::infof("[%s] \$ %s\n", basename(Cwd::getcwd()), "@_");
      system(@_) == 0
          or App::Project::Logger::errorf("Giving up.\n");
  }
  
  sub edit_file {
      my ($file) = @_;
      my $editor = $ENV{"EDITOR"} || "vi";
      system( $editor, $file );
  }
  
  sub load_sub_cmd {
      my ($self, $name) = @_;
      my $klass = sprintf("App::Project::CLI::%s", camelize($name));
      load $klass;
      return $klass;
  }
  
  sub slurp {
      my $fname = shift;
      open my $fh, '<', $fname
          or Carp::croak("Can't open '$fname' for reading: '$!'");
      scalar do { local $/; <$fh> }
  }
  
  sub slurp_raw {
      my $fname = shift;
      open my $fh, '<:raw', $fname
          or Carp::croak("Can't open '$fname' for reading: '$!'");
      scalar do { local $/; <$fh> }
  }
  
  sub spew_raw {
      my $fname = shift;
      open my $fh, '>:raw', $fname
          or Carp::croak("Can't open '$fname' for writing: '$!'");
      print {$fh} $_[0];
  }
  
  1;
  
APP_PROJECT_UTIL

$fatpacked{"Data/OptList.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DATA_OPTLIST';
  use strict;use warnings;package Data::OptList;{$Data::OptList::VERSION='0.109'}use List::Util ();use Params::Util ();use Sub::Install 0.921 ();my%test_for;BEGIN {%test_for=(CODE=>\&Params::Util::_CODELIKE,HASH=>\&Params::Util::_HASHLIKE,ARRAY=>\&Params::Util::_ARRAYLIKE,SCALAR=>\&Params::Util::_SCALAR0,)}sub __is_a {my ($got,$expected)=@_;return List::Util::first {__is_a($got,$_)}@$expected if ref$expected;return defined (exists($test_for{$expected})? $test_for{$expected}->($got): Params::Util::_INSTANCE($got,$expected))}sub mkopt {my ($opt_list)=shift;my ($moniker,$require_unique,$must_be);my$name_test;if (@_==1 and Params::Util::_HASHLIKE($_[0])){my$arg=$_[0];($moniker,$require_unique,$must_be,$name_test)=@$arg{qw(moniker require_unique must_be name_test) }}else {($moniker,$require_unique,$must_be)=@_}$moniker='unnamed' unless defined$moniker;return []unless$opt_list;$name_test ||= sub {!ref $_[0]};$opt_list=[map {$_=>(ref$opt_list->{$_}? $opt_list->{$_}: ())}keys %$opt_list ]if ref$opt_list eq 'HASH';my@return;my%seen;for (my$i=0;$i < @$opt_list;$i++){my$name=$opt_list->[$i];my$value;if ($require_unique){Carp::croak "multiple definitions provided for $name" if$seen{$name}++}if ($i==$#$opt_list){$value=undef}elsif (not defined$opt_list->[$i+1]){$value=undef;$i++}elsif ($name_test->($opt_list->[$i+1])){$value=undef}else {$value=$opt_list->[++$i]}if ($must_be and defined$value){unless (__is_a($value,$must_be)){my$ref=ref$value;Carp::croak "$ref-ref values are not valid in $moniker opt list"}}push@return,[$name=>$value ]}return \@return}sub mkopt_hash {my ($opt_list,$moniker,$must_be)=@_;return {}unless$opt_list;$opt_list=mkopt($opt_list,$moniker,1,$must_be);my%hash=map {$_->[0]=>$_->[1]}@$opt_list;return \%hash}BEGIN {*import=Sub::Install::exporter {exports=>[qw(mkopt mkopt_hash)],}}1;
DATA_OPTLIST

$fatpacked{"Getopt/Compact/WithCmd.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GETOPT_COMPACT_WITHCMD';
  package Getopt::Compact::WithCmd;use strict;use warnings;use 5.008_001;use Data::Dumper ();use List::Util qw(max);use Getopt::Long qw(GetOptionsFromArray);use Carp ();use constant DEFAULT_CONFIG=>(no_auto_abbrev=>1,no_ignore_case=>1,bundling=>1,);our$VERSION='0.22';my$TYPE_MAP={'Bool'=>'!','Incr'=>'+','Str'=>'=s','Int'=>'=i','Num'=>'=f','ExNum'=>'=o',};my$TYPE_GEN={};sub new {my ($class,%args)=@_;my$self=bless {cmd=>$args{cmd}|| do {require File::Basename;File::Basename::basename($0)},name=>$args{name},version=>$args{version}|| $::VERSION,modes=>$args{modes},opt=>{},usage=>exists$args{usage}&&!$args{usage}? 0 : 1,args=>$args{args}|| '',_argv=>\@ARGV,struct=>[],summary=>{},requires=>{},ret=>0,error=>undef,other_usage=>undef,commands=>[],_struct=>$args{command_struct}|| {},},$class;my%config=(DEFAULT_CONFIG,%{$args{configure}|| {}});my@gconf=grep$config{$_},keys%config;Getopt::Long::Configure(@gconf)if@gconf;$self->_init_summary($args{command_struct});$self->_init_struct($args{global_struct}|| []);my$opthash=$self->_parse_struct || return$self;if ($args{command_struct}){if (my@gopts=$self->_parse_argv){$self->{ret}=$self->_parse_option(\@gopts,$opthash);unshift@ARGV,@gopts;return$self unless$self->{ret};return$self if$self->_want_help}$self->_check_requires}else {$self->{ret}=$self->_parse_option(\@ARGV,$opthash);return$self unless$self->{ret};return$self if$self->_want_help;$self->_check_requires;return$self}$self->_parse_command_struct($args{command_struct});return$self}sub new_from_array {my ($class,$args,%options)=@_;unless (ref$args eq 'ARRAY'){Carp::croak("Usage: $class->new_from_array(\\\@args, %options)")}local*ARGV=$args;return$class->new(%options)}sub new_from_string {my ($class,$str,%options)=@_;unless (defined$str){Carp::croak("Usage: $class->new_from_string(\$str, %options)")}require Text::ParseWords;my$args=[Text::ParseWords::shellwords($str)];local*ARGV=$args;return$class->new(%options)}sub args {$_[0]->{_argv}}sub error {$_[0]->{error}||''}sub command {$_[0]->{command}}sub commands {$_[0]->{commands}}sub status {$_[0]->{ret}}sub is_success {$_[0]->{ret}}sub pod2usage {Carp::carp('Not implemented')}sub opts {my($self)=@_;my$opt=$self->{opt};if ($self->{usage}&& ($opt->{help}|| $self->status==0)){print$self->usage;exit!$self->status}return$opt}sub usage {my($self,@targets)=@_;my$usage='';my(@help,@commands);if ((defined$self->command && $self->command eq 'help')|| @targets){delete$self->{command};@targets=@{$self->{_argv}}unless@targets;for (my$i=0;$i < @targets;$i++){my$target=$targets[$i];last unless defined$target;unless (ref$self->{_struct}{$target}eq 'HASH'){$self->{error}="Unknown command: $target";last}else {$self->{command}=$target;push @{$self->{commands}},$target;$self->_init_struct($self->{_struct}{$target}{options});$self->_extends_usage($self->{_struct}{$target});if (ref$self->{_struct}{$target}{command_struct}eq 'HASH'){$self->{_struct}=$self->{_struct}{$target}{command_struct}}else {$self->{summary}={}}}}}my($name,$version,$cmd,$struct,$args,$summary,$error,$other_usage)=map $self->{$_}|| '',qw/name version cmd struct args summary error other_usage/;$usage .= "$error\n" if$error;if ($name){$usage .= $name;$usage .= " v$version" if$version;$usage .= "\n"}if ($self->command && $self->command ne 'help'){my$sub_command=join q{ },@{$self->commands}? @{$self->commands}: $self->command;$usage .= "usage: $cmd $sub_command [options]"}else {$usage .= "usage: $cmd [options]";$usage .= ' COMMAND' if keys %$summary}$usage .= ($args ? " $args" : '')."\n\n";for my$o (@$struct){my ($name_spec,$desc,$arg_spec,$dist,$opts)=@$o;$desc='' unless defined$desc;my@onames=$self->_option_names($name_spec);my$optname=join (', ',map {(length($_)> 1 ? '--' : '-').$_}@onames);$optname='    '.$optname unless length($onames[0])==1;my$info=do {local$Data::Dumper::Indent=0;local$Data::Dumper::Terse=1;my$info=[];push @$info,$self->_opt_spec2name($arg_spec)|| $arg_spec || '';push @$info,$opts->{required}? "(required)" : '';push @$info,defined$opts->{default}? "(default: ".Data::Dumper::Dumper($opts->{default}).")" : '';$info};push@help,[$optname,$info,ucfirst($desc)]}if (@help){require Text::Table;my$sep=\'   ';$usage .= "options:\n";$usage .= Text::Table->new($sep,'',$sep,'',$sep,'')->load($self->_format_info(@help))->stringify."\n"}if (defined$other_usage && length$other_usage > 0){$other_usage =~ s/\n$//ms;$usage .= "$other_usage\n\n"}if (!$self->command || $self->{has_sub_command}){for my$command (sort keys %$summary){push@commands,[$command,ucfirst$summary->{$command}]}if (@commands){require Text::Table;my$sep=\'   ';$usage .= "Implemented commands are:\n";$usage .= Text::Table->new($sep,'',$sep,'')->load(@commands)->stringify."\n";my$help_command="$cmd help COMMAND";if (@{$self->commands}){my$sub_commands=join q{ },@{$self->commands};$help_command="$cmd $sub_commands COMMAND --help"}$usage .= "See '$help_command' for more information on a specific command.\n\n"}}return$usage}sub show_usage {my$self=shift;print$self->usage(@_);exit!$self->status}sub completion {my($self,$shell)=@_;$shell ||= 'bash';if ($shell eq 'bash'){return$self->_completion_bash}else {Carp::carp("Not implemented: completion for $shell");return ""}}sub show_completion {my$self=shift;print$self->completion(@_);exit!$self->status}sub _completion_bash {my$self=shift;my$comp='';my$prog=$self->{name}|| substr($0,rindex($0,'/')+1);my$fname=$prog;$fname =~ s/[.-]/_/g;my@global_opts;my@commands;my$case={word=>'"$cmd"',cases=>[],};@global_opts=$self->_options2optarg($self->{struct});for my$cmd (sort keys %{$self->{_struct}}){my$s=$self->{_struct}{$cmd};my@opts=$self->_options2optarg($s->{options});my@commands2;if (ref$s->{command_struct}eq 'HASH'){for my$cmd (sort keys %{$s->{command_struct}}){my$s=$s->{command_struct}{$cmd};my@opts=$self->_options2optarg($s->{options});push@commands2,{cmd=>$cmd,opts=>\@opts,}}}push@commands,{cmd=>$cmd,opts=>\@opts,subcmd=>\@commands2,args=>($s->{args}|| ''),}}$comp .= "_$fname() {\n";$comp .= <<'EOC';$comp .= sprintf qq{  local global_opts="%s"\n},join(" ",map {@{$_->{opt}}}@global_opts);$comp .= sprintf qq{  local cmds="%s"\n},join(" ",map {$_->{cmd}}@commands);$comp .= "\n";for my$command (@commands){my$case_prev={word=>'"$prev"',cases=>[_opts2casecmd(@{$command->{opts}}),{pat=>'*',cmd=>['COMPREPLY=($(compgen -W "'._gen_wordlist($command).'" -- "$cur"))'],},],};if (scalar(@{$command->{subcmd}})> 0){my@cases;for my$subcommand (@{$command->{subcmd}}){next if (scalar(@{$subcommand->{opts}})<= 0);push@cases,{pat=>$subcommand->{cmd},cmd=>[{word=>'"$prev"',cases=>[_opts2casecmd(@{$subcommand->{opts}}),{pat=>'*',cmd=>['COMPREPLY=($(compgen -W "'._gen_wordlist($subcommand).'" -- "$cur"))'],},],}],}}push@cases,{pat=>'*',cmd=>[$case_prev ],};push @{$case->{cases}},{pat=>$command->{cmd},cmd=>[{word=>'"${cmd[1]}"',cases=>[@cases],}],}}else {push @{$case->{cases}},{pat=>$command->{cmd},cmd=>[$case_prev ],}}}push @{$case->{cases}},{pat=>'*',cmd=>[{word=>'"$prev"',cases=>[_opts2casecmd(@global_opts),{pat=>'*',cmd=>['COMPREPLY=($(compgen -W "$global_opts $cmds" -- "$cur"))'],},],}],};my@c=_generate_case_command($case);$comp .= join("\n",map {"  ".$_}@c)."\n";$comp .= <<"EOC";return$comp}sub _generate_case_command {my$case=shift;my@line;push@line,"case $case->{word} in";for my$c (@{$case->{cases}}){push@line,"  $c->{pat})";for my$cmd (@{$c->{cmd}},';;'){if (ref$cmd eq 'HASH'){push@line,map {"    ".$_}_generate_case_command->($cmd)}else {push@line,"    ".$cmd}}}push@line,"esac";return@line}sub _options2optarg {my($self,$opts)=@_;my@optarg;for my$o (@{$opts}){my ($name_spec,$desc,$arg_spec,$dist,$opts)=@$o;my@onames=map {(length($_)> 1 ? '--' : '-').$_}$self->_option_names($name_spec);my$arg=$self->_opt_spec2name($arg_spec)|| $arg_spec || '';$arg='' if$arg eq 'Incr';push@optarg,{opt=>\@onames,arg=>$arg,}}return@optarg}sub _opts2casecmd {my@cases;for my$o (grep {$_->{arg}}@_){push@cases,{pat=>join("|",@{$o->{opt}}),cmd=>['COMPREPLY=($(compgen -W "'.$o->{arg}.'" -- "$cur"))'],}}return@cases}sub _gen_wordlist {my$command=shift;return join(" ",'-h','--help',(map {@{$_->{opt}}}@{$command->{opts}}),($command->{args}||''),(map {$_->{cmd}}@{$command->{subcmd}}),)}sub _opt_spec2name {my ($self,$spec)=@_;my$name='';return$name unless defined$spec;my ($type,$dest)=$spec =~ /^[=:]?([!+isof])([@%])?/;if ($type){$name=$type eq '!' ? 'Bool' : $type eq '+' ? 'Incr' : $type eq 's' ? 'Str' : $type eq 'i' ? 'Int' : $type eq 'f' ? 'Num' : $type eq 'o' ? 'ExNum' : ''}if ($dest){$name=$dest eq '@' ? "Array[$name]" : $dest eq '%' ? "Hash[$name]" : $name}return$name}sub _format_info {my ($self,@help)=@_;my$type_max=0;my$required_max=0;my$default_max=0;for my$row (@help){my ($type,$required,$default)=@{$row->[1]};$type_max=max$type_max,length($type);$required_max=max$required_max,length($required);$default_max=max$default_max,length($default)}for my$row (@help){my ($type,$required,$default)=@{$row->[1]};my$parts=[];for my$stuff ([$type_max,$type],[$required_max,$required],[$default_max,$default]){push @$parts,sprintf '%-*s',@$stuff if$stuff->[0]> 0}$row->[1]=join ' ',@$parts}return@help}sub _parse_command_struct {my ($self,$command_struct)=@_;$command_struct ||= {};my$command_map={map {$_=>1}keys %$command_struct };my$command=shift@ARGV;unless (defined$command){$self->{ret}=$self->_check_requires;return$self}unless ($command_map->{help}){$command_map->{help}=1;$command_struct->{help}={args=>'[COMMAND]',desc=>'show help message',}}unless (exists$command_map->{$command}){$self->{error}="Unknown command: $command";$self->{ret}=0;return$self}$self->{command}||= $command;if ($command eq 'help'){$self->{ret}=0;delete$self->{error};if (defined$ARGV[0]&& exists$command_struct->{$ARGV[0]}){my$nested_struct=$command_struct->{$ARGV[0]}{command_struct};$self->_init_nested_struct($nested_struct)if$nested_struct}return$self}push @{$self->{commands}||= []},$command;$self->_init_struct($command_struct->{$command}{options});$self->_extends_usage($command_struct->{$command});my$opthash=$self->_parse_struct || return$self;if (my$nested_struct=$command_struct->{$command}{command_struct}){$self->_init_nested_struct($nested_struct);my@opts=$self->_parse_argv($nested_struct);$self->{ret}=$self->_parse_option(\@opts,$opthash);unshift@ARGV,@opts;$self->_check_requires;if ($self->_want_help){delete$self->{error};$self->{ret}=0}return$self unless$self->{ret};$self->_parse_command_struct($nested_struct)}else {$self->{ret}=$self->_parse_option(\@ARGV,$opthash);$self->_check_requires;$self->{has_sub_command}=0;if ($self->_want_help){delete$self->{error};$self->{ret}=0}}return$self}sub _want_help {exists $_[0]->{opt}{help}&& $_[0]->{opt}{help}? 1 : 0}sub _init_nested_struct {my ($self,$nested_struct)=@_;$self->{summary}={};$self->_init_summary($nested_struct);$self->{has_sub_command}=1}sub _parse_option {my ($self,$argv,$opthash)=@_;local$SIG{__WARN__}=sub {$self->{error}=join '',@_;chomp$self->{error}};my$ret=GetOptionsFromArray($argv,%$opthash)? 1 : 0;$self->{parsed_opthash}=$opthash;return$ret}sub _parse_argv {my ($self,$struct)=@_;$struct ||= $self->{_struct};my@opts;while (@ARGV){my$argv=shift@ARGV;push@opts,$argv;last if exists$struct->{$argv}}return@opts}sub _parse_struct {my ($self)=@_;my$struct=$self->{struct};my$opthash={};my$default_opthash={};my$default_args=[];for my$s (@$struct){my($m,$descr,$spec,$ref,$opts)=@$s;my@onames=$self->_option_names($m);my($longname)=grep length($_)> 1,@onames;my ($type,$cb)=$self->_compile_spec($spec);my$o=join('|',@onames).($type||'');my$dest=$longname ? $longname : $onames[0];$opts ||= {};my$destination;if (ref$cb eq 'CODE'){my$t=substr($type,-1,1)eq '@' ? 'Array' : substr($type,-1,1)eq '%' ? 'Hash' : '';if (ref$ref eq 'CODE'){$destination=sub {$ref->($_[0],$cb->($_[1]))}}elsif (ref$ref){if (ref$ref eq 'SCALAR' || ref$ref eq 'REF'){$$ref=$t eq 'Array' ? []: $t eq 'Hash' ? {}: undef}elsif (ref$ref eq 'ARRAY'){@$ref=()}elsif (ref$ref eq 'HASH'){%$ref=()}$destination=sub {if ($t eq 'Array'){if (ref$ref eq 'SCALAR' || ref$ref eq 'REF'){push @{$$ref},scalar$cb->($_[1])}elsif (ref$ref eq 'ARRAY'){push @$ref,scalar$cb->($_[1])}elsif (ref$ref eq 'HASH'){my@kv=split '=',$_[1],2;die qq(Option $_[0], key "$_[1]", requires a value\n) unless@kv==2;$ref->{$kv[0]}=scalar$cb->($kv[1])}}elsif ($t eq 'Hash'){if (ref$ref eq 'SCALAR' || ref$ref eq 'REF'){$$ref->{$_[1]}=scalar$cb->($_[2])}elsif (ref$ref eq 'ARRAY'){push @$ref,$_[1],scalar$cb->($_[2])}elsif (ref$ref eq 'HASH'){$ref->{$_[1]}=scalar$cb->($_[2])}}else {if (ref$ref eq 'SCALAR' || ref$ref eq 'REF'){$$ref=$cb->($_[1])}elsif (ref$ref eq 'ARRAY'){@$ref=(scalar$cb->($_[1]))}elsif (ref$ref eq 'HASH'){my@kv=split '=',$_[1],2;die qq(Option $_[0], key "$_[1]", requires a value\n) unless@kv==2;%$ref=($kv[0]=>scalar$cb->($kv[1]))}}}}else {$destination=sub {if ($t eq 'Array'){$self->{opt}{$dest}||= [];push @{$self->{opt}{$dest}},scalar$cb->($_[1])}elsif ($t eq 'Hash'){$self->{opt}{$dest}||= {};$self->{opt}{$dest}{$_[1]}=$cb->($_[2])}else {$self->{opt}{$dest}=$cb->($_[1])}}}}else {$destination=ref$ref ? $ref : \$self->{opt}{$dest}}if (exists$opts->{default}){my$value=$opts->{default};if (ref$value eq 'ARRAY'){push @$default_args,map {("--$dest",$_)}grep {defined $_}@$value}elsif (ref$value eq 'HASH'){push @$default_args,map {(my$key=$_)=~ s/=/\\=/g;("--$dest"=>"$key=$value->{$_}")}grep {defined$value->{$_}}keys %$value}elsif (not ref$value){if (!$spec || ($TYPE_MAP->{$spec}|| $spec)eq '!'){push @$default_args,"--$dest" if$value}else {push @$default_args,"--$dest",$value if defined$value}}else {$self->{error}="Invalid default option for $dest";$self->{ret}=0}$default_opthash->{$o}=$destination}$opthash->{$o}=$destination;$self->{requires}{$dest}=$o if$opts->{required}}return if$self->{error};if (@$default_args){$self->{ret}=$self->_parse_option($default_args,$default_opthash);unshift@ARGV,@$default_args;return unless$self->{ret}}return$opthash}sub _init_struct {my ($self,$struct)=@_;$self->{struct}=ref$struct eq 'ARRAY' ? $struct : ref$struct eq 'HASH' ? $self->_normalize_struct($struct): [];if (ref$self->{modes}eq 'ARRAY'){my@modeopt;for my$m (@{$self->{modes}}){my($mc)=$m =~ /^(\w)/;push@modeopt,[[$mc,$m],qq($m mode)]}unshift @$struct,@modeopt}unshift @{$self->{struct}},[[qw(h help)],qq(this help message)]if$self->{usage}&&!$self->_has_option('help')}sub _normalize_struct {my ($self,$struct)=@_;my$result=[];for my$option (keys %$struct){my$data=$struct->{$option}|| {};$data=ref$data eq 'HASH' ? $data : {};my$row=[];push @$row,[$option,ref$data->{alias}eq 'ARRAY' ? @{$data->{alias}}: defined$data->{alias}? $data->{alias}: (),];push @$row,$data->{desc};push @$row,$data->{type};push @$row,$data->{dest};push @$row,$data->{opts};push @$result,$row}return$result}sub _compile_spec {my ($self,$spec)=@_;return if!defined$spec or $spec eq '';return$spec if$self->_opt_spec2name($spec);my ($type,$cb);if ($spec =~ /^(Array|Hash)\[(\w+)\]$/){$type=$TYPE_MAP->{$2}|| Carp::croak("Can't find type constraint '$2'");$type .= $1 eq 'Array' ? '@' : '%';$cb=$TYPE_GEN->{$2}}elsif ($type=$TYPE_MAP->{$spec}){$cb=$TYPE_GEN->{$spec}}else {Carp::croak("Can't find type constraint '$spec'")}return$type,$cb}sub add_type {my ($class,$name,$src_type,$cb)=@_;unless (defined$name && $src_type && ref$cb eq 'CODE'){Carp::croak("Usage: $class->add_type(\$name, \$src_type, \$cb)")}unless ($TYPE_MAP->{$src_type}){Carp::croak("$src_type is not defined src type")}$TYPE_MAP->{$name}=$TYPE_MAP->{$src_type};$TYPE_GEN->{$name}=$cb}sub _init_summary {my ($self,$command_struct)=@_;if ($command_struct){for my$key (keys %$command_struct){$self->{summary}{$key}=$command_struct->{$key}->{desc}|| ''}}else {$self->{summary}={}}}sub _extends_usage {my ($self,$command_option)=@_;for my$key (qw/args other_usage/){$self->{$key}=$command_option->{$key}if exists$command_option->{$key}}}sub _check_requires {my ($self)=@_;for my$dest (sort keys %{$self->{requires}}){unless (defined$self->{opt}{$dest}){unless (defined ${$self->{parsed_opthash}{$self->{requires}{$dest}}}){$self->{ret}=0;$self->{error}="`--$dest` option must be specified";return 0}}}return 1}sub _option_names {my($self,$m)=@_;my@sorted=sort {my ($la,$lb)=(length($a),length($b));return$la <=> $lb if$la < 2 or $lb < 2;return 0}ref$m eq 'ARRAY' ? @$m : $m;return@sorted}sub _has_option {my($self,$option)=@_;return 1 if grep {$_ eq $option}map {$self->_option_names($_->[0])}@{$self->{struct}};return 0}1;
    COMPREPLY=()
    local cur=${COMP_WORDS[COMP_CWORD]}
    local prev=${COMP_WORDS[COMP_CWORD-1]}
    local cmd=()
    for ((i=1; i<COMP_CWORD; i++)); do
      # skip global opts and type to find cmd
      if [[ "${COMP_WORDS[$i]}" != -* && "${COMP_WORDS[$i]}" != [A-Z]* ]]; then
        cmd[${#cmd[@]}]=${COMP_WORDS[$i]}
      fi
    done
  
  EOC
  }
  
  complete -F _$fname $prog
  EOC
GETOPT_COMPACT_WITHCMD

$fatpacked{"Sub/Exporter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SUB_EXPORTER';
  use 5.006;use strict;use warnings;package Sub::Exporter;{$Sub::Exporter::VERSION='0.987'}use Carp ();use Data::OptList 0.100 ();use Params::Util 0.14 ();use Sub::Install 0.92 ();sub _group_name {my ($name)=@_;return if (index q{-:},(substr$name,0,1))==-1;return substr$name,1}sub _expand_groups {my ($class,$config,$groups,$collection,$seen,$merge)=@_;$seen ||= {};$merge ||= {};my@groups=@$groups;for my$i (reverse 0 .. $#groups){if (my$group_name=_group_name($groups[$i][0])){my$seen={%$seen };splice@groups,$i,1,_expand_group($class,$config,$groups[$i],$collection,$seen,$merge)}else {next unless my%merge=%$merge;my$prefix=(delete$merge{-prefix})|| '';my$suffix=(delete$merge{-suffix})|| '';if (Params::Util::_CODELIKE($groups[$i][1])or Params::Util::_SCALAR0($groups[$i][1])){$groups[$i][0]=$prefix .$groups[$i][0].$suffix}else {my$as =ref$groups[$i][1]{-as}? $groups[$i][1]{-as}: $groups[$i][1]{-as}? $prefix .$groups[$i][1]{-as}.$suffix : $prefix .$groups[$i][0].$suffix;$groups[$i][1]={%{$groups[$i][1]},%merge,-as=>$as }}}}return \@groups}sub _expand_group {my ($class,$config,$group,$collection,$seen,$merge)=@_;$merge ||= {};my ($group_name,$group_arg)=@$group;$group_name=_group_name($group_name);Carp::croak qq(group "$group_name" is not exported by the $class module) unless exists$config->{groups}{$group_name};return if$seen->{$group_name}++;if (ref$group_arg){my$prefix=(delete$merge->{-prefix}||'').($group_arg->{-prefix}||'');my$suffix=($group_arg->{-suffix}||'').(delete$merge->{-suffix}||'');$merge={%$merge,%$group_arg,($prefix ? (-prefix=>$prefix): ()),($suffix ? (-suffix=>$suffix): ()),}}my$exports=$config->{groups}{$group_name};if (Params::Util::_CODELIKE($exports)or Params::Util::_SCALAR0($exports)){my$group_arg=$merge ? {%$merge }: {};delete$group_arg->{-prefix};delete$group_arg->{-suffix};my$group=Params::Util::_CODELIKE($exports)? $exports->($class,$group_name,$group_arg,$collection): $class->$$exports($group_name,$group_arg,$collection);Carp::croak qq(group generator "$group_name" did not return a hashref) if ref$group ne 'HASH';my$stuff=[map {[$_=>$group->{$_}]}keys %$group ];return @{_expand_groups($class,$config,$stuff,$collection,$seen,$merge)}}else {$exports =Data::OptList::mkopt($exports,"$group_name exports");return @{_expand_groups($class,$config,$exports,$collection,$seen,$merge)}}}sub _mk_collection_builder {my ($col,$etc)=@_;my ($config,$import_args,$class,$into)=@$etc;my%seen;sub {my ($collection)=@_;my ($name,$value)=@$collection;Carp::croak "collection $name provided multiple times in import" if$seen{$name }++;if (ref(my$hook=$config->{collectors}{$name})){my$arg={name=>$name,config=>$config,import_args=>$import_args,class=>$class,into=>$into,};my$error_msg="collection $name failed validation";if (Params::Util::_SCALAR0($hook)){Carp::croak$error_msg unless$class->$$hook($value,$arg)}else {Carp::croak$error_msg unless$hook->($value,$arg)}}$col->{$name }=$value}}sub _collect_collections {my ($config,$import_args,$class,$into)=@_;my@collections =map {splice @$import_args,$_,1}grep {exists$config->{collectors}{$import_args->[$_][0]}}reverse 0 .. $#$import_args;unshift@collections,[INIT=>{}]if$config->{collectors}{INIT};my$col={};my$builder=_mk_collection_builder($col,\@_);for my$collection (@collections){$builder->($collection)}return$col}sub setup_exporter {my ($config)=@_;Carp::croak 'into and into_level may not both be supplied to exporter' if exists$config->{into}and exists$config->{into_level};my$as=delete$config->{as}|| 'import';my$into =exists$config->{into}? delete$config->{into}: exists$config->{into_level}? caller(delete$config->{into_level}): caller(0);my$import=build_exporter($config);Sub::Install::reinstall_sub({code=>$import,into=>$into,as=>$as,})}sub _key_intersection {my ($x,$y)=@_;my%seen=map {$_=>1}keys %$x;my@names=grep {$seen{$_}}keys %$y}my%valid_config_key;BEGIN {%valid_config_key=map {$_=>1}qw(as collectors installer generator exports groups into into_level),qw(exporter),}sub _assert_collector_names_ok {my ($collectors)=@_;for my$reserved_name (grep {/\A[_A-Z]+\z/}keys %$collectors){Carp::croak "unknown reserved collector name: $reserved_name" if$reserved_name ne 'INIT'}}sub _rewrite_build_config {my ($config)=@_;if (my@keys=grep {not exists$valid_config_key{$_}}keys %$config){Carp::croak "unknown options (@keys) passed to Sub::Exporter"}Carp::croak q(into and into_level may not both be supplied to exporter) if exists$config->{into}and exists$config->{into_level};if ($config->{exporter}){Carp::cluck "'exporter' argument to build_exporter is deprecated. Use 'installer' instead; the semantics are identical.";$config->{installer}=delete$config->{exporter}}Carp::croak q(into and into_level may not both be supplied to exporter) if exists$config->{into}and exists$config->{into_level};for (qw(exports collectors)){$config->{$_}=Data::OptList::mkopt_hash($config->{$_},$_,['CODE','SCALAR' ],)}_assert_collector_names_ok($config->{collectors});if (my@names=_key_intersection(@$config{qw(exports collectors)})){Carp::croak "names (@names) used in both collections and exports"}$config->{groups}=Data::OptList::mkopt_hash($config->{groups},'groups',['HASH','ARRAY','CODE','SCALAR',]);$config->{groups}{default}||= [];$config->{groups}{all}||= [keys %{$config->{exports}}];$config->{generator}||= \&default_generator;$config->{installer}||= \&default_installer}sub build_exporter {my ($config)=@_;_rewrite_build_config($config);my$import=sub {my ($class)=shift;my$special=(ref $_[0])? shift(@_): {};Carp::croak q(into and into_level may not both be supplied to exporter) if exists$special->{into}and exists$special->{into_level};if ($special->{exporter}){Carp::cluck "'exporter' special import argument is deprecated. Use 'installer' instead; the semantics are identical.";$special->{installer}=delete$special->{exporter}}my$into =defined$special->{into}? delete$special->{into}: defined$special->{into_level}? caller(delete$special->{into_level}): defined$config->{into}? $config->{into}: defined$config->{into_level}? caller($config->{into_level}): caller(0);my$generator=delete$special->{generator}|| $config->{generator};my$installer=delete$special->{installer}|| $config->{installer};my$import_args=Data::OptList::mkopt([@_ ]);$import_args=[[-default=>undef ]]unless @$import_args;my$collection=_collect_collections($config,$import_args,$class,$into);my$to_import=_expand_groups($class,$config,$import_args,$collection);_do_import({class=>$class,col=>$collection,config=>$config,into=>$into,generator=>$generator,installer=>$installer,},$to_import,)};return$import}sub _do_import {my ($arg,$to_import)=@_;my@todo;for my$pair (@$to_import){my ($name,$import_arg)=@$pair;my ($generator,$as);if ($import_arg and Params::Util::_CODELIKE($import_arg)){$generator=sub {$import_arg};$as=$name}else {$import_arg={$import_arg ? %$import_arg : ()};Carp::croak qq("$name" is not exported by the $arg->{class} module) unless exists$arg->{config}{exports}{$name};$generator=$arg->{config}{exports}{$name};$as=exists$import_arg->{-as}? (delete$import_arg->{-as}): $name}my$code=$arg->{generator}->({class=>$arg->{class},name=>$name,arg=>$import_arg,col=>$arg->{col},generator=>$generator,});push@todo,$as,$code}$arg->{installer}->({class=>$arg->{class},into=>$arg->{into},col=>$arg->{col},},\@todo,)}sub default_generator {my ($arg)=@_;my ($class,$name,$generator)=@$arg{qw(class name generator)};if (not defined$generator){my$code=$class->can($name)or Carp::croak "can't locate exported subroutine $name via $class";return$code}return$generator->($class,$name,$arg->{arg},$arg->{col})if Params::Util::_CODELIKE($generator);return$class->$$generator($name,$arg->{arg},$arg->{col})}sub default_installer {my ($arg,$to_export)=@_;for (my$i=0;$i < @$to_export;$i += 2){my ($as,$code)=@$to_export[$i,$i+1 ];if (ref$as eq 'SCALAR'){$$as=$code}elsif (ref$as){Carp::croak "invalid reference type for $as: " .ref$as}else {Sub::Install::reinstall_sub({code=>$code,into=>$arg->{into},as=>$as })}}}sub default_exporter {Carp::cluck "default_exporter is deprecated; call default_installer instead; the semantics are identical";goto&default_installer}setup_exporter({exports=>[qw(setup_exporter build_exporter),_import=>sub {build_exporter($_[2])},],groups=>{all=>[qw(setup_exporter build_export) ],},collectors=>{-setup=>\&_setup },});sub _setup {my ($value,$arg)=@_;if (ref$value eq 'HASH'){push @{$arg->{import_args}},[_import=>{-as=>'import',%$value }];return 1}elsif (ref$value eq 'ARRAY'){push @{$arg->{import_args}},[_import=>{-as=>'import',exports=>$value }];return 1}return}"jn8:32";
SUB_EXPORTER

$fatpacked{"Sub/Exporter/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SUB_EXPORTER_UTIL';
  use strict;use warnings;package Sub::Exporter::Util;{$Sub::Exporter::Util::VERSION='0.987'}use Data::OptList ();use Params::Util ();sub curry_method {my$override_name=shift;sub {my ($class,$name)=@_;$name=$override_name if defined$override_name;sub {$class->$name(@_)}}}BEGIN {*curry_class=\&curry_method}sub curry_chain {my (@opt_list)=@_;my$pairs=Data::OptList::mkopt(\@opt_list,'args','ARRAY');sub {my ($class)=@_;sub {my$next=$class;for my$i (0 .. $#$pairs){my$pair=$pairs->[$i ];unless (Params::Util::_INVOCANT($next)){my$str=defined$next ? "'$next'" : 'undef';Carp::croak("can't call $pair->[0] on non-invocant $str")}my ($method,$args)=@$pair;if ($i==$#$pairs){return$next->$method($args ? @$args : ())}else {$next=$next->$method($args ? @$args : ())}}}}}sub merge_col {my (%groups)=@_;my%merged;while (my ($default_name,$group)=each%groups){while (my ($export_name,$gen)=each %$group){$merged{$export_name}=sub {my ($class,$name,$arg,$col)=@_;my$merged_arg=exists$col->{$default_name}? {%{$col->{$default_name}},%$arg }: $arg;if (Params::Util::_CODELIKE($gen)){$gen->($class,$name,$merged_arg,$col)}else {$class->$$gen($name,$merged_arg,$col)}}}}return%merged}sub __mixin_class_for {my ($class,$mix_into)=@_;require Package::Generator;my$mixin_class=Package::Generator->new_package({base=>"$class\:\:__mixin__",});no strict 'refs';if (ref$mix_into){unshift @{"$mixin_class" ."::ISA"},ref$mix_into}else {unshift @{"$mix_into" ."::ISA"},$mixin_class}return$mixin_class}sub mixin_installer {sub {my ($arg,$to_export)=@_;my$mixin_class=__mixin_class_for($arg->{class},$arg->{into});bless$arg->{into}=>$mixin_class if ref$arg->{into};Sub::Exporter::default_installer({%$arg,into=>$mixin_class},$to_export,)}}sub mixin_exporter {Carp::cluck "mixin_exporter is deprecated; use mixin_installer instead; it behaves identically";return mixin_installer}sub like {sub {my ($value,$arg)=@_;Carp::croak "no regex supplied to regex group generator" unless$value;my@values=eval {$value->isa('Regexp')}? ($value,undef): @$value;while (my ($re,$opt)=splice@values,0,2){Carp::croak "given pattern for regex group generater is not a Regexp" unless eval {$re->isa('Regexp')};my@exports=keys %{$arg->{config}->{exports}};my@matching=grep {$_ =~ $re}@exports;my%merge=$opt ? %$opt : ();my$prefix=(delete$merge{-prefix})|| '';my$suffix=(delete$merge{-suffix})|| '';for my$name (@matching){my$as=$prefix .$name .$suffix;push @{$arg->{import_args}},[$name=>{%merge,-as=>$as }]}}1}}use Sub::Exporter -setup=>{exports=>[qw(like name_map merge_col curry_method curry_class curry_chain mixin_installer mixin_exporter) ]};1;
SUB_EXPORTER_UTIL

$fatpacked{"Sub/Install.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SUB_INSTALL';
  use strict;use warnings;package Sub::Install;$Sub::Install::VERSION='0.928';use Carp;use Scalar::Util ();sub _name_of_code {my ($code)=@_;require B;my$name=B::svref_2object($code)->GV->NAME;return$name unless$name =~ /\A__ANON__/;return}sub _CODELIKE {(Scalar::Util::reftype($_[0])||'')eq 'CODE' || Scalar::Util::blessed($_[0])&& (overload::Method($_[0],'&{}')? $_[0]: undef)}sub _build_public_installer {my ($installer)=@_;sub {my ($arg)=@_;my ($calling_pkg)=caller(0);for (qw(into from)){$arg->{$_}=$calling_pkg unless$arg->{$_}}Carp::croak "named argument 'code' is not optional" unless$arg->{code};if (_CODELIKE($arg->{code})){$arg->{as}||= _name_of_code($arg->{code})}else {Carp::croak "couldn't find subroutine named $arg->{code} in package $arg->{from}" unless my$code=$arg->{from}->can($arg->{code});$arg->{as}=$arg->{code}unless$arg->{as};$arg->{code}=$code}Carp::croak "couldn't determine name under which to install subroutine" unless$arg->{as};$installer->(@$arg{qw(into as code) })}}my$_misc_warn_re;my$_redef_warn_re;BEGIN {$_misc_warn_re=qr/
      Prototype\ mismatch:\ sub\ .+?  |
      Constant subroutine .+? redefined
    /x;$_redef_warn_re=qr/Subroutine\ .+?\ redefined/x}my$eow_re;BEGIN {$eow_re=qr/ at .+? line \d+\.\Z/};sub _do_with_warn {my ($arg)=@_;my$code=delete$arg->{code};my$wants_code=sub {my$code=shift;sub {my$warn=$SIG{__WARN__}? $SIG{__WARN__}: sub {warn @_};local$SIG{__WARN__}=sub {my ($error)=@_;for (@{$arg->{suppress}}){return if$error =~ $_}for (@{$arg->{croak}}){if (my ($base_error)=$error =~ /\A($_) $eow_re/x){Carp::croak$base_error}}for (@{$arg->{carp}}){if (my ($base_error)=$error =~ /\A($_) $eow_re/x){return$warn->(Carp::shortmess$base_error)}}($arg->{default}|| $warn)->($error)};$code->(@_)}};return$wants_code->($code)if$code;return$wants_code}sub _installer {sub {my ($pkg,$name,$code)=@_;no strict 'refs';*{"$pkg\::$name"}=$code;return$code}}BEGIN {*_ignore_warnings=_do_with_warn({carp=>[$_misc_warn_re,$_redef_warn_re ]});*install_sub=_build_public_installer(_ignore_warnings(_installer));*_carp_warnings=_do_with_warn({carp=>[$_misc_warn_re ],suppress=>[$_redef_warn_re ],});*reinstall_sub=_build_public_installer(_carp_warnings(_installer));*_install_fatal=_do_with_warn({code=>_installer,croak=>[$_redef_warn_re ],})}sub install_installers {my ($into)=@_;for my$method (qw(install_sub reinstall_sub)){my$code=sub {my ($package,$subs)=@_;my ($caller)=caller(0);my$return;for (my ($name,$sub)=%$subs){$return=Sub::Install->can($method)->({code=>$sub,from=>$caller,into=>$package,as=>$name })}return$return};install_sub({code=>$code,into=>$into,as=>$method })}}sub exporter {my ($arg)=@_;my%is_exported=map {$_=>undef}@{$arg->{exports}};sub {my$class=shift;my$target=caller;for (@_){Carp::croak "'$_' is not exported by $class" if!exists$is_exported{$_};install_sub({code=>$_,from=>$class,into=>$target })}}}BEGIN {*import=exporter({exports=>[qw(install_sub reinstall_sub) ]})}1;
SUB_INSTALL

$fatpacked{"Try/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TRY_TINY';
  package Try::Tiny;BEGIN {$Try::Tiny::AUTHORITY='cpan:NUFFIN'}{$Try::Tiny::VERSION='0.18'}use 5.006;use strict;use warnings;use base 'Exporter';our@EXPORT=our@EXPORT_OK=qw(try catch finally);use Carp;$Carp::Internal{+__PACKAGE__}++;BEGIN {eval "use Sub::Name; 1" or *{subname}=sub {1}}sub try (&;@) {my ($try,@code_refs)=@_;my$wantarray=wantarray;my ($catch,@finally)=();for my$code_ref (@code_refs){if (ref($code_ref)eq 'Try::Tiny::Catch'){croak 'A try() may not be followed by multiple catch() blocks' if$catch;$catch=${$code_ref}}elsif (ref($code_ref)eq 'Try::Tiny::Finally'){push@finally,${$code_ref}}else {croak('try() encountered an unexpected argument (' .(defined$code_ref ? $code_ref : 'undef').') - perhaps a missing semi-colon before or')}}my$caller=caller;subname("${caller}::try {...} "=>$try);subname("${caller}::catch {...} "=>$catch)if$catch;subname("${caller}::finally {...} "=>$_)foreach@finally;my$prev_error=$@;my (@ret,$error);my$failed=not eval {$@=$prev_error;if ($wantarray){@ret=$try->()}elsif (defined$wantarray){$ret[0]=$try->()}else {$try->()};return 1};$error=$@;$@=$prev_error;my@guards=map {Try::Tiny::ScopeGuard->_new($_,$failed ? $error : ())}@finally;if ($failed){if ($catch){for ($error){return$catch->($error)}}return}else {return$wantarray ? @ret : $ret[0]}}sub catch (&;@) {my ($block,@rest)=@_;croak 'Useless bare catch()' unless wantarray;return (bless(\$block,'Try::Tiny::Catch'),@rest,)}sub finally (&;@) {my ($block,@rest)=@_;croak 'Useless bare finally()' unless wantarray;return (bless(\$block,'Try::Tiny::Finally'),@rest,)}{package Try::Tiny::ScopeGuard;use constant UNSTABLE_DOLLARAT=>($] < '5.013002')? 1 : 0;sub _new {shift;bless [@_ ]}sub DESTROY {my ($code,@args)=@{$_[0]};local $@ if UNSTABLE_DOLLARAT;eval {$code->(@args);1}or do {warn "Execution of finally() block $code resulted in an exception, which " .'*CAN NOT BE PROPAGATED* due to fundamental limitations of Perl. ' .'Your program will continue as if this event never took place. ' ."Original exception text follows:\n\n" .(defined $@ ? $@ : '$@ left undefined...')."\n" }}}__PACKAGE__ 
TRY_TINY

$fatpacked{"Version/Next.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'VERSION_NEXT';
  use strict;use warnings;package Version::Next;our$VERSION='0.004';use version 0.81 ();use Carp ();use Sub::Exporter 0 (-setup=>{exports=>['next_version']});sub _cleanup {my$version=shift;if ($version eq 'undef'){return "0"}if ($version =~ /^\./){my$num_dots=()=$version =~ /(\.)/g;return$num_dots > 1 ? version->parse($version)->normal : "0$version"}if ($version =~ /\.$/){return "${version}0"}return$version}sub next_version {my$version=shift;return "0" unless defined$version;Carp::croak("Doesn't look like a version number: '$version'")unless version::is_lax($version);$version=_cleanup($version);my$new_ver;my$num_dots=()=$version =~ /(\.)/g;my$has_v=$version =~ /^v/;my$is_alpha=$version =~ /\A[^_]+_\d+\z/;if ($has_v || $num_dots > 1){$version =~ s{^v}{} if$has_v;my@parts=split /\./,$version;if ($is_alpha){push@parts,split /_/,pop@parts}my@new_ver;while (@parts){my$p=pop@parts;if ($p < 999 ||!@parts){unshift@new_ver,$p + 1;last}else {unshift@new_ver,0}}$new_ver=$has_v ? 'v' : '';$new_ver .= join(".",map {0+ $_}@parts,@new_ver);if ($is_alpha){$new_ver =~ s{\A(.*)\.(\d+)}{$1_$2}}}else {my$alpha_neg_offset;if ($is_alpha){$alpha_neg_offset=index($version,"_")+ 1 - length($version);$version =~ s{_}{}}my ($fraction)=$version =~ m{\.(\d+)$};my$n=defined$fraction ? length($fraction): 0;$new_ver=sprintf("%.${n}f",$version + (10**-$n));if ($is_alpha){substr($new_ver,$alpha_neg_offset,0,"_")}}return$new_ver}1;
VERSION_NEXT

$fatpacked{"darwin-2level/Params/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_PARAMS_UTIL';
  package Params::Util;use 5.00503;use strict;require overload;require Exporter;require Scalar::Util;require DynaLoader;use vars qw{$VERSION @ISA @EXPORT_OK %EXPORT_TAGS};$VERSION='1.07';@ISA=qw{Exporter DynaLoader};@EXPORT_OK=qw{_STRING _IDENTIFIER _CLASS _CLASSISA _SUBCLASS _DRIVER _CLASSDOES _NUMBER _POSINT _NONNEGINT _SCALAR _SCALAR0 _ARRAY _ARRAY0 _ARRAYLIKE _HASH _HASH0 _HASHLIKE _CODE _CODELIKE _INVOCANT _REGEX _INSTANCE _INSTANCEDOES _SET _SET0 _HANDLE};%EXPORT_TAGS=(ALL=>\@EXPORT_OK);eval {local$ENV{PERL_DL_NONLAZY}=0 if$ENV{PERL_DL_NONLAZY};bootstrap Params::Util$VERSION;1}unless$ENV{PERL_PARAMS_UTIL_PP};my$SU=eval "$Scalar::Util::VERSION" || 0;if ($SU >= 1.18){Scalar::Util->import('looks_like_number')}else {eval <<'END_PERL'}eval <<'END_PERL' unless defined&_STRING;eval <<'END_PERL' unless defined&_IDENTIFIER;eval <<'END_PERL' unless defined&_CLASS;eval <<'END_PERL' unless defined&_CLASSISA;eval <<'END_PERL' unless defined&_CLASSDOES;eval <<'END_PERL' unless defined&_SUBCLASS;eval <<'END_PERL' unless defined&_NUMBER;eval <<'END_PERL' unless defined&_POSINT;eval <<'END_PERL' unless defined&_NONNEGINT;eval <<'END_PERL' unless defined&_SCALAR;eval <<'END_PERL' unless defined&_SCALAR0;eval <<'END_PERL' unless defined&_ARRAY;eval <<'END_PERL' unless defined&_ARRAY0;eval <<'END_PERL' unless defined&_ARRAYLIKE;eval <<'END_PERL' unless defined&_HASH;eval <<'END_PERL' unless defined&_HASH0;eval <<'END_PERL' unless defined&_HASHLIKE;eval <<'END_PERL' unless defined&_CODE;eval <<'END_PERL' unless defined&_CODELIKE;eval <<'END_PERL' unless defined&_INVOCANT;eval <<'END_PERL' unless defined&_INSTANCE;eval <<'END_PERL' unless defined&_INSTANCEDOES;eval <<'END_PERL' unless defined&_REGEX;eval <<'END_PERL' unless defined&_SET;eval <<'END_PERL' unless defined&_SET0;eval <<'END_PERL' unless defined&_HANDLE;eval <<'END_PERL' unless defined&_DRIVER;1;
  sub looks_like_number {
  	local $_ = shift;
  
  	# checks from perlfaq4
  	return 0 if !defined($_);
  	if (ref($_)) {
  		return overload::Overloaded($_) ? defined(0 + $_) : 0;
  	}
  	return 1 if (/^[+-]?[0-9]+$/); # is a +/- integer
  	return 1 if (/^([+-]?)(?=[0-9]|\.[0-9])[0-9]*(\.[0-9]*)?([Ee]([+-]?[0-9]+))?$/); # a C float
  	return 1 if ($] >= 5.008 and /^(Inf(inity)?|NaN)$/i) or ($] >= 5.006001 and /^Inf$/i);
  
  	0;
  }
  END_PERL
  sub _STRING ($) {
  	(defined $_[0] and ! ref $_[0] and length($_[0])) ? $_[0] : undef;
  }
  END_PERL
  sub _IDENTIFIER ($) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[^\W\d]\w*\z/s) ? $_[0] : undef;
  }
  END_PERL
  sub _CLASS ($) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[^\W\d]\w*(?:::\w+)*\z/s) ? $_[0] : undef;
  }
  END_PERL
  sub _CLASSISA ($$) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[^\W\d]\w*(?:::\w+)*\z/s and $_[0]->isa($_[1])) ? $_[0] : undef;
  }
  END_PERL
  sub _CLASSDOES ($$) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[^\W\d]\w*(?:::\w+)*\z/s and $_[0]->DOES($_[1])) ? $_[0] : undef;
  }
  END_PERL
  sub _SUBCLASS ($$) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[^\W\d]\w*(?:::\w+)*\z/s and $_[0] ne $_[1] and $_[0]->isa($_[1])) ? $_[0] : undef;
  }
  END_PERL
  sub _NUMBER ($) {
  	( defined $_[0] and ! ref $_[0] and looks_like_number($_[0]) )
  	? $_[0]
  	: undef;
  }
  END_PERL
  sub _POSINT ($) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[1-9]\d*$/) ? $_[0] : undef;
  }
  END_PERL
  sub _NONNEGINT ($) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^(?:0|[1-9]\d*)$/) ? $_[0] : undef;
  }
  END_PERL
  sub _SCALAR ($) {
  	(ref $_[0] eq 'SCALAR' and defined ${$_[0]} and ${$_[0]} ne '') ? $_[0] : undef;
  }
  END_PERL
  sub _SCALAR0 ($) {
  	ref $_[0] eq 'SCALAR' ? $_[0] : undef;
  }
  END_PERL
  sub _ARRAY ($) {
  	(ref $_[0] eq 'ARRAY' and @{$_[0]}) ? $_[0] : undef;
  }
  END_PERL
  sub _ARRAY0 ($) {
  	ref $_[0] eq 'ARRAY' ? $_[0] : undef;
  }
  END_PERL
  sub _ARRAYLIKE {
  	(defined $_[0] and ref $_[0] and (
  		(Scalar::Util::reftype($_[0]) eq 'ARRAY')
  		or
  		overload::Method($_[0], '@{}')
  	)) ? $_[0] : undef;
  }
  END_PERL
  sub _HASH ($) {
  	(ref $_[0] eq 'HASH' and scalar %{$_[0]}) ? $_[0] : undef;
  }
  END_PERL
  sub _HASH0 ($) {
  	ref $_[0] eq 'HASH' ? $_[0] : undef;
  }
  END_PERL
  sub _HASHLIKE {
  	(defined $_[0] and ref $_[0] and (
  		(Scalar::Util::reftype($_[0]) eq 'HASH')
  		or
  		overload::Method($_[0], '%{}')
  	)) ? $_[0] : undef;
  }
  END_PERL
  sub _CODE ($) {
  	ref $_[0] eq 'CODE' ? $_[0] : undef;
  }
  END_PERL
  sub _CODELIKE($) {
  	(
  		(Scalar::Util::reftype($_[0])||'') eq 'CODE'
  		or
  		Scalar::Util::blessed($_[0]) and overload::Method($_[0],'&{}')
  	)
  	? $_[0] : undef;
  }
  END_PERL
  sub _INVOCANT($) {
  	(defined $_[0] and
  		(defined Scalar::Util::blessed($_[0])
  		or      
  		# We used to check for stash definedness, but any class-like name is a
  		# valid invocant for UNIVERSAL methods, so we stopped. -- rjbs, 2006-07-02
  		Params::Util::_CLASS($_[0]))
  	) ? $_[0] : undef;
  }
  END_PERL
  sub _INSTANCE ($$) {
  	(Scalar::Util::blessed($_[0]) and $_[0]->isa($_[1])) ? $_[0] : undef;
  }
  END_PERL
  sub _INSTANCEDOES ($$) {
  	(Scalar::Util::blessed($_[0]) and $_[0]->DOES($_[1])) ? $_[0] : undef;
  }
  END_PERL
  sub _REGEX ($) {
  	(defined $_[0] and 'Regexp' eq ref($_[0])) ? $_[0] : undef;
  }
  END_PERL
  sub _SET ($$) {
  	my $set = shift;
  	_ARRAY($set) or return undef;
  	foreach my $item ( @$set ) {
  		_INSTANCE($item,$_[0]) or return undef;
  	}
  	$set;
  }
  END_PERL
  sub _SET0 ($$) {
  	my $set = shift;
  	_ARRAY0($set) or return undef;
  	foreach my $item ( @$set ) {
  		_INSTANCE($item,$_[0]) or return undef;
  	}
  	$set;
  }
  END_PERL
  sub _HANDLE {
  	my $it = shift;
  
  	# It has to be defined, of course
  	unless ( defined $it ) {
  		return undef;
  	}
  
  	# Normal globs are considered to be file handles
  	if ( ref $it eq 'GLOB' ) {
  		return $it;
  	}
  
  	# Check for a normal tied filehandle
  	# Side Note: 5.5.4's tied() and can() doesn't like getting undef
  	if ( tied($it) and tied($it)->can('TIEHANDLE') ) {
  		return $it;
  	}
  
  	# There are no other non-object handles that we support
  	unless ( Scalar::Util::blessed($it) ) {
  		return undef;
  	}
  
  	# Check for a common base classes for conventional IO::Handle object
  	if ( $it->isa('IO::Handle') ) {
  		return $it;
  	}
  
  
  	# Check for tied file handles using Tie::Handle
  	if ( $it->isa('Tie::Handle') ) {
  		return $it;
  	}
  
  	# IO::Scalar is not a proper seekable, but it is valid is a
  	# regular file handle
  	if ( $it->isa('IO::Scalar') ) {
  		return $it;
  	}
  
  	# Yet another special case for IO::String, which refuses (for now
  	# anyway) to become a subclass of IO::Handle.
  	if ( $it->isa('IO::String') ) {
  		return $it;
  	}
  
  	# This is not any sort of object we know about
  	return undef;
  }
  END_PERL
  sub _DRIVER ($$) {
  	(defined _CLASS($_[0]) and eval "require $_[0];" and ! $@ and $_[0]->isa($_[1]) and $_[0] ne $_[1]) ? $_[0] : undef;
  }
  END_PERL
DARWIN-2LEVEL_PARAMS_UTIL

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
     if (my $fat = $_[0]{$_[1]}) {
       return sub {
         return 0 unless length $fat;
         $fat =~ s/^([^\n]*\n?)//;
         $_ = $1;
         return 1;
       };
     }
     return;
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE

#!/usr/bin/env perl
use strict;
use warnings;
use utf8;
use App::Project::CLI;

# For fat-packer
use Version::Next;

App::Project::CLI->new()->run(@ARGV);

