#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"App/Project.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PROJECT';
  package App::Project;
  use 5.008001;
  use strict;
  use warnings;
  use version; our $VERSION = version->declare("v0.0.0");
  
  use Time::Piece qw(gmtime);
  
  our $DEBUG;
  
  sub debug { $DEBUG }
  
  sub new {
      my ($class, @args) = @_;
      my $self = bless {@args}, $class;
      $self->{version} // die 'Must specifies version!';
      $self->{changes_time} = scalar(gmtime());
      return $self;
  }
  
  sub version { return shift->{version}; }
  
  sub changes_time { return shift->{changes_time}; }
  
  1;
  __END__
  
  =encoding utf-8
  
  =head1 NAME
  
  App::Project - [DRAFT] Generic authoring tool(not only for perl project).
  
  =head1 SYNOPSIS
  
      project changes      - Ready to change log for release
      project untracks     - Show untracked files
      project dist         - (not yet) Make your dist tarball
      project migrate      - (not yet) Set up your project ready for this tool
      project release      - Make release tag and push
      project bump_version - Bump version for next release
      project wrapper      - (not yet) Install this command line tool in your project
  
  =head1 THIS IS DRAFT
  
  I'm going to implements this modules.
  
  And thinking about this name because L<App::Project> naming is uncool name :(
  
  =head1 DESCRIPTION
  
  App::Project is a application authoring tool. App::Project provides I<project> command as authoring tool for application project.
  
  App::Project is not only for Perl project.
  
  App::Project inspire of Minilla(as CPAN module auhtoring tool).
  
  B<THIS IS A DEVELOPMENT RELEASE. API MAY CHANGE WITHOUT NOTICE>.
  
  =head1 GETTING STARTED
  
      # First time only
      # TODO: Provide fat pack tool
      % cpanm App::Project
      # App::Project has only a few deps. It should be very quick
      # Make a new distribution
      % cd /path/to/App/
      % project migrate
      # Git commit
      % git commit -m "initial commit"
      # Hack your code!
      % $EDITOR lib/YourCode
      # Done? Test and release it!
      # Make L<git tag> and update change log for release
      % project release
      # Need more portability tool? We provide to generate L<>
      % project wrapper > bin/project
  
  
  It's that easy.
  
  =head1 NOTE
  
  =head2 Why made?
  
  I need generic authoring tool. (e.g. Android application, HTML5 application, and other)
  
  I was impressed L<Minilla>. And I decide make this project.
  
  =head2 Why Perl?
  
  Perl script is high portability, A lot of operation system is installed Perl. 
  
  Make simple script with comparative ease. I don't have plan to be complex interfaces ;)
  
  =head2 App::Project is built on small libraries.
  
  App::Project is built on only few small libraries. You can install App::Project without a huge list of dependencies to heavy modules.
  
  And dependencies are pure perl or perl core(5.12.0+) only, because to higher portability for I<wrapper> script.
  
  =head1 LICENSE
  
  Copyright (C) ichigotake.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 AUTHOR
  
  ichigotake E<lt>ichigotake.san@gmail.comE<gt>
  
  =head1 SEE ALSO
  
  =item1 L<Minilla>
  
  =cut
  
APP_PROJECT

$fatpacked{"App/Project/BumpVersion.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PROJECT_BUMPVERSION';
  package App::Project::BumpVersion;
  use 5.008001;
  use strict;
  use warnings;
  use ExtUtils::MakeMaker qw(prompt);
  use version;
  use Version::Next;
  use App::Project::Logger;
  
  sub new {
      my $class = shift;
      return bless {@_}, $class;
  }
  
  sub run {
      my ($self, $current_version, $opts) = @_;
      my $validate = $opts->{validate} || 0;
      $current_version //= '0.1';
  
      my $is_valid = version::is_lax($current_version);
      if ($validate) {
          return $is_valid ? $current_version : undef;
      }
      if (!$is_valid) {
          errorf("Sorry, version '%s' is invalid.  Stopping.\n", $current_version);
      }
      return $self->default_new_version($current_version);
  }
  
  sub default_new_version {
      my ($self, $version) = @_;
      @_ == 2 or die;
  
      if (not exists_tag($version)) {
          $version;
      } else {
          return Version::Next::next_version("$version");
      }
  }
  
  sub exists_tag {
      my ( $tag ) = @_;
  
      my $x = `git tag -l $tag`;
      chomp $x;
      return !!$x;
  }
  
  
  1;
  
APP_PROJECT_BUMPVERSION

$fatpacked{"App/Project/CLI.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PROJECT_CLI';
  package App::Project::CLI;
  use strict;
  use warnings;
  use utf8;
  use Getopt::Long;
  use Getopt::Compact::WithCmd;
  use Try::Tiny;
  use App::Project::Errors;
  use App::Project::Logger;
  use App::Project::Util;
  
  sub new {
      my $class = shift;
      return bless {@_}, $class;
  }
  
  sub run {
      my ($self, @args) = @_;
      
      local @ARGV = @args;
      my @commands;
      my $go = Getopt::Compact::WithCmd->new(
          name => 'App::Project',
          version => '0.1',
          global_struct => [],
          command_struct => {
              bump_version => {
                  options => [
                      [ [qw/v validate/], 'validate version format', '!', undef, { default => 0 } ],
                  ],
                  args => 'version',
                  desc => 'bump next version',
              },
              changes => {
                  options => [
                      [ [qw/c check/], 'Check can edit Changes', '!', undef, {default => 0} ],
                      [ [qw/d dry-run/], 'Dry run mode', '!', undef, { default => 0 } ],
                  ],
                  args => 'version',
                  desc => 'Edit and commit Changes',
              },
              release => {
                  options => [
                      [ [qw/d dry-run/], 'Dry run mode', '!', undef, { default => 0 } ],
                  ],
                  args => 'version',
                  desc => 'Make release tag and push',
              },
              untracks => {
                  options => [
                      [ [qw/z/], "\0 line termination on output", "!", undef, { default => 0 } ],
                  ],
                  desc => 'Show untracked files',
              },
          },
      );
  
      my $cmd = $go->command || 'help';
      if ($cmd eq 'help') {
          $go->show_usage;
          exit;
      }
      my $klass = sprintf("App::Project::CLI::%s", camelize($cmd));
  
      ## no critic
      if (eval sprintf("require %s; 1;", $klass)) {
          try {
              $klass->run($go);
          } catch {
              /App::Project::Error::CommandExit/ and return;
              errorf("%s\n", $_);
              exit 1;
          }
      } else {
          warnf("Could not find command '%s'\n", $cmd);
          if ($@ !~ /^Can't locate App::Project/) {
              errorf("$@\n");
          }
          exit 2;
      }
  }
  
  1;
  
APP_PROJECT_CLI

$fatpacked{"App/Project/CLI/BumpVersion.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PROJECT_CLI_BUMPVERSION';
  package App::Project::CLI::BumpVersion;
  use strict;
  use warnings;
  use utf8;
  use App::Project::BumpVersion;
  use version;
  
  sub run {
      my ($self, $command, $args, $options) = @_;
      my $version = shift(@$args) // undef;
      my $res = App::Project::BumpVersion->new()->run($version, $options);
      exit 1 unless $res;
      print $res;
  }
  
  1;
  
APP_PROJECT_CLI_BUMPVERSION

$fatpacked{"App/Project/CLI/Changes.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PROJECT_CLI_CHANGES';
  package App::Project::CLI::Changes;
  use strict;
  use warnings;
  use utf8;
  
  use App::Project;
  use App::Project::Flow::CheckChanges;
  use App::Project::Flow::RewriteChanges;
  use App::Project::Logger;
  
  sub run {
      my ($self, $go) = @_;
      my $version = shift(@{$go->args}) or die 'Must specifies version name!';
      my $project = App::Project->new(version => $version);
      App::Project::Flow::CheckChanges->new()->run($project, $go->opts);
      if ($go->opts->{check} || undef) {
          return;
      }
      App::Project::Flow::RewriteChanges->new()->run($project, $go->opts);
  
  }
  
  1;
  
APP_PROJECT_CLI_CHANGES

$fatpacked{"App/Project/CLI/Release.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PROJECT_CLI_RELEASE';
  package App::Project::CLI::Release;
  use strict;
  use warnings;
  use utf8;
  
  use App::Project;
  use App::Project::Flow::Commit;
  use App::Project::Flow::Tag;
  
  sub run {
      my ($self, $go) = @_;
      my $version = shift(@{$go->args}) or die 'Must specifies version name!';
      my $project = App::Project->new(version => $version);
      App::Project::Flow::Commit->new()->run($project, $go->opts);
      App::Project::Flow::Tag->new()->run($project, $go->opts);
  }
  
  1;
  
APP_PROJECT_CLI_RELEASE

$fatpacked{"App/Project/CLI/Untracks.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PROJECT_CLI_UNTRACKS';
  package App::Project::CLI::Untracks;
  use strict;
  use warnings;
  use utf8;
  use App::Project::Logger;
  use App::Project::CheckUntrackedFiles;
  
  sub run {
      my ($self, $command, $args, $options) = @_;
      my @untracks = App::Project::CheckUntrackedFiles->new()->run();
      if (!@untracks) {
          my $unk = join("\n", @untracks);
          errorf("Unknown local files:\n$unk\n\nUpdate .gitignore, or git add them\n");
      }
      print join("\n", @untracks);
  }
  
  1;
  
APP_PROJECT_CLI_UNTRACKS

$fatpacked{"App/Project/CheckUntrackedFiles.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PROJECT_CHECKUNTRACKEDFILES';
  package App::Project::CheckUntrackedFiles;
  use strict;
  use warnings;
  use utf8;
  
  use App::Project::Logger;
  
  sub new {
      my $class = shift;
      return bless {@_}, $class;
  }
  
  sub run {
      my ($self) = @_;
      my $unk = `git ls-files -z --others --exclude-standard`;
      return split("\0", $unk);
  }
  
  1;
  
  __END__
  
  =encoding utf-8
  
  =head1 NAME
  
  App::Project::CheckUntrackedFiles
  
  =head1 DESCRIPTION
  
  Copy from L<Minilla::Release::CheckUntrackedFiles>.
  
APP_PROJECT_CHECKUNTRACKEDFILES

$fatpacked{"App/Project/Errors.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PROJECT_ERRORS';
  package App::Project::Errors;
  use strict;
  use warnings;
  use utf8;
  
  use Carp ();
  
  package App::Project::Error::CommandExit;
  
  use overload '""' => 'message', fallback => 1;
  
  sub throw {
      my ($class, $body) = @_;
      my $self = bless { body => $body, message => Carp::longmess($class) }, $class;
      die $self;
  }
  
  sub body { shift->{body} }
  
  sub message {
      my($self) = @_;
      return $self->{message};
  }
  
  1;
  
APP_PROJECT_ERRORS

$fatpacked{"App/Project/Flow/CheckChanges.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PROJECT_FLOW_CHECKCHANGES';
  package App::Project::Flow::CheckChanges;
  use strict;
  use warnings;
  use utf8;
  use ExtUtils::MakeMaker qw(prompt);
  
  use App::Project::Util qw(edit_file slurp);
  use App::Project::Logger;
  
  sub new {
      my $class = shift;
      return bless {@_}, $class;
  }
  
  sub run {
      my ($self, $project, $opts) = @_;
      $project->version or die 'Must specifies version name!';
  
      if ($ENV{PERL_APP_PROJECT_CHECK_CHANGE_LOG}) {
          infof("Okay, you are debugging now.\n");
          return;
      }
  
      until (slurp('Changes') =~ /^\{\{\$NEXT\}\}\n+[ \t]+\S/m) {
          infof("No mention of version '%s' in changelog file 'Changes'\n", $project->version);
          if (prompt("Edit file?", 'y') =~ /y/i) {
              edit_file('Changes');
          } else {
              errorf("Giving up!\n");
          }
      }
  }
  
  1;
  
APP_PROJECT_FLOW_CHECKCHANGES

$fatpacked{"App/Project/Flow/Commit.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PROJECT_FLOW_COMMIT';
  package App::Project::Flow::Commit;
  use strict;
  use warnings;
  use utf8;
  
  use App::Project::Util qw(cmd);
  use App::Project::Logger;
  
  sub new {
      my $class = shift;
      return bless {@_}, $class;
  }
  
  sub run {
      my ($self, $project, $opts) = @_;
  
      my @modified_files = split /\0/, `git ls-files --deleted --modified -z`;
      return if @modified_files == 0;
  
      my $ver = $project->version;
  
      my $msg = "Checking in changes prior to tagging of version $ver.\n\nChangelog diff is:\n\n";
      $msg .= `git diff Changes`;
  
      if ($opts->{dry_run}) {
          infof("DRY-RUN.  Would have committed message of:\n----------------\n$msg\n-----------\n");
          return;
      }
  
      cmd('git', 'commit', '-a', '-m', $msg);
  
      $self->_push_to_origin();
  }
  
  sub _push_to_origin {
      my ($self) = @_;
  
      # git v1.7.10 is required?
      my $branch = _get_branch()
          or return;
      $branch =~ s/\n//g;
      infof("Pushing to origin\n");
      cmd('git', 'push', 'origin', $branch);
  }
  
  sub _get_branch {
      open my $fh, '<', '.git/HEAD';
      chomp( my $head = do { local $/; <$fh> });
      close $fh;
  
      my ($branch) = $head =~ m!ref: refs/heads/(\S+)!;
      return $branch;
  }
  
  1;
  
APP_PROJECT_FLOW_COMMIT

$fatpacked{"App/Project/Flow/RewriteChanges.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PROJECT_FLOW_REWRITECHANGES';
  package App::Project::Flow::RewriteChanges;
  use strict;
  use warnings;
  use utf8;
  use App::Project::Util qw(slurp_raw spew_raw);
  
  sub new {
      my $class = shift;
      return bless {@_}, $class;
  }
  
  sub run {
      my ($self, $project, $opts) = @_;
      return if $opts->{dry_run};
  
      my $content = slurp_raw('Changes');
      $content =~ s!\{\{\$NEXT\}\}!
          "{{\$NEXT}}\n\n" . $project->version. " " . $project->changes_time->strftime('%Y-%m-%dT%H:%M:%SZ')
          !e;
      spew_raw('Changes' => $content);
  }
  
  
  1;
  
APP_PROJECT_FLOW_REWRITECHANGES

$fatpacked{"App/Project/Flow/Tag.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PROJECT_FLOW_TAG';
  package App::Project::Flow::Tag;
  use strict;
  use warnings;
  use utf8;
  
  use App::Project::Util qw(cmd);
  use App::Project::Logger;
  
  sub run {
      my ($self, $project, $opts) = @_;
      my $version = $project->version;
  
      if ( $opts->{dry_run} ) {
          infof("DRY-RUN.  Would have tagged version $version.\n");
          return;
      }
  
      my $tag = $project->format_tag($version);
      cmd('git', 'tag', $tag);
      cmd('git', "push", 'origin', tag => $tag);
  }
  
  1;
  
APP_PROJECT_FLOW_TAG

$fatpacked{"App/Project/Git.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PROJECT_GIT';
  package App::Project::Git;
  use strict;
  use warnings;
  use utf8;
  
  use parent qw(Exporter);
  use App::Project::Util;
  
  our @EXPORT = qw(git_init git_add git_commit);
  
  sub git_init {
      cmd('git', 'init');
  }
  
  sub git_add {
      cmd('git', 'add', @_ ? @_ : '.');
  }
  
  sub git_commit {
      cmd('git', 'commit', @_);
  }
  
  1;
  
APP_PROJECT_GIT

$fatpacked{"App/Project/Logger.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PROJECT_LOGGER';
  package App::Project::Logger;
  use 5.008001;
  use strict;
  use warnings;
  use utf8;
  use parent qw(Exporter);
  
  use Term::ANSIColor qw(colored);
  require Win32::Console::ANSI if $^O eq 'MSWin32';
  
  use App::Project::Errors;
  
  our @EXPORT = qw(debugf infof warnf errorf);
  
  our $COLOR;
  
  use constant { DEBUG => 1, INFO => 2, WARN => 3, ERROR => 4 };
  
  our $Colors = {
      DEBUG,   => 'green',
      WARN,    => 'yellow',
      INFO,    => 'cyan',
      ERROR,   => 'red',
  };
  
  sub _printf {
      my $type = pop;
      my($temp, @args) = @_;
      _print(sprintf($temp, map { defined($_) ? $_ : '-' } @args), $type);
  }
  
  sub _print {
      my($msg, $type) = @_;
      return if $type == DEBUG && !App::Project->debug;
      $msg = colored $msg, $Colors->{$type} if defined $type && $COLOR;
      my $fh = $type && $type >= WARN ? *STDERR : *STDOUT;
      print {$fh} $msg;
  }
  
  sub infof {
      _printf(@_, INFO);
  }
  
  sub warnf {
      _printf(@_, WARN);
  }
  
  sub debugf {
      _printf(@_, DEBUG);
  }
  
  sub errorf {
      my(@msg) = @_;
      _printf(@msg, ERROR);
  
      my $fmt = shift @msg;
      App::Project::Error::CommandExit->throw(sprintf($fmt, @msg));
  }
  
  1;
  
APP_PROJECT_LOGGER

$fatpacked{"App/Project/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PROJECT_UTIL';
  package App::Project::Util;
  use strict;
  use warnings;
  use utf8;
  use parent qw(Exporter);
  
  use App::Project::Logger;
  use Cwd();
  
  our @EXPORT = qw(camelize cmd edit_file slurp slurp_raw spew_raw);
  
  sub camelize {
      my ($target) = @_;
      $target =~ s/(_|^)(.)/\u$2/g;
      return $target;
  }
  
  sub cmd {
      App::Project::Logger::infof("[%s] \$ %s\n", File::Basename::basename(Cwd::getcwd()), "@_");
      system(@_) == 0
          or App::Project::Logger::errorf("Giving up.\n");
  }
  
  sub edit_file {
      my ($file) = @_;
      my $editor = $ENV{"EDITOR"} || "vi";
      system( $editor, $file );
  }
  
  sub slurp {
      my $fname = shift;
      open my $fh, '<', $fname
          or Carp::croak("Can't open '$fname' for reading: '$!'");
      scalar do { local $/; <$fh> }
  }
  
  sub slurp_raw {
      my $fname = shift;
      open my $fh, '<:raw', $fname
          or Carp::croak("Can't open '$fname' for reading: '$!'");
      scalar do { local $/; <$fh> }
  }
  
  sub spew_raw {
      my $fname = shift;
      open my $fh, '>:raw', $fname
          or Carp::croak("Can't open '$fname' for writing: '$!'");
      print {$fh} $_[0];
  }
  
  1;
  
APP_PROJECT_UTIL

$fatpacked{"Getopt/Compact/WithCmd.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GETOPT_COMPACT_WITHCMD';
  package Getopt::Compact::WithCmd;use strict;use warnings;use 5.008_001;use Data::Dumper ();use List::Util qw(max);use Getopt::Long qw(GetOptionsFromArray);use Carp ();use constant DEFAULT_CONFIG=>(no_auto_abbrev=>1,no_ignore_case=>1,bundling=>1,);our$VERSION='0.22';my$TYPE_MAP={'Bool'=>'!','Incr'=>'+','Str'=>'=s','Int'=>'=i','Num'=>'=f','ExNum'=>'=o',};my$TYPE_GEN={};sub new {my ($class,%args)=@_;my$self=bless {cmd=>$args{cmd}|| do {require File::Basename;File::Basename::basename($0)},name=>$args{name},version=>$args{version}|| $::VERSION,modes=>$args{modes},opt=>{},usage=>exists$args{usage}&&!$args{usage}? 0 : 1,args=>$args{args}|| '',_argv=>\@ARGV,struct=>[],summary=>{},requires=>{},ret=>0,error=>undef,other_usage=>undef,commands=>[],_struct=>$args{command_struct}|| {},},$class;my%config=(DEFAULT_CONFIG,%{$args{configure}|| {}});my@gconf=grep$config{$_},keys%config;Getopt::Long::Configure(@gconf)if@gconf;$self->_init_summary($args{command_struct});$self->_init_struct($args{global_struct}|| []);my$opthash=$self->_parse_struct || return$self;if ($args{command_struct}){if (my@gopts=$self->_parse_argv){$self->{ret}=$self->_parse_option(\@gopts,$opthash);unshift@ARGV,@gopts;return$self unless$self->{ret};return$self if$self->_want_help}$self->_check_requires}else {$self->{ret}=$self->_parse_option(\@ARGV,$opthash);return$self unless$self->{ret};return$self if$self->_want_help;$self->_check_requires;return$self}$self->_parse_command_struct($args{command_struct});return$self}sub new_from_array {my ($class,$args,%options)=@_;unless (ref$args eq 'ARRAY'){Carp::croak("Usage: $class->new_from_array(\\\@args, %options)")}local*ARGV=$args;return$class->new(%options)}sub new_from_string {my ($class,$str,%options)=@_;unless (defined$str){Carp::croak("Usage: $class->new_from_string(\$str, %options)")}require Text::ParseWords;my$args=[Text::ParseWords::shellwords($str)];local*ARGV=$args;return$class->new(%options)}sub args {$_[0]->{_argv}}sub error {$_[0]->{error}||''}sub command {$_[0]->{command}}sub commands {$_[0]->{commands}}sub status {$_[0]->{ret}}sub is_success {$_[0]->{ret}}sub pod2usage {Carp::carp('Not implemented')}sub opts {my($self)=@_;my$opt=$self->{opt};if ($self->{usage}&& ($opt->{help}|| $self->status==0)){print$self->usage;exit!$self->status}return$opt}sub usage {my($self,@targets)=@_;my$usage='';my(@help,@commands);if ((defined$self->command && $self->command eq 'help')|| @targets){delete$self->{command};@targets=@{$self->{_argv}}unless@targets;for (my$i=0;$i < @targets;$i++){my$target=$targets[$i];last unless defined$target;unless (ref$self->{_struct}{$target}eq 'HASH'){$self->{error}="Unknown command: $target";last}else {$self->{command}=$target;push @{$self->{commands}},$target;$self->_init_struct($self->{_struct}{$target}{options});$self->_extends_usage($self->{_struct}{$target});if (ref$self->{_struct}{$target}{command_struct}eq 'HASH'){$self->{_struct}=$self->{_struct}{$target}{command_struct}}else {$self->{summary}={}}}}}my($name,$version,$cmd,$struct,$args,$summary,$error,$other_usage)=map $self->{$_}|| '',qw/name version cmd struct args summary error other_usage/;$usage .= "$error\n" if$error;if ($name){$usage .= $name;$usage .= " v$version" if$version;$usage .= "\n"}if ($self->command && $self->command ne 'help'){my$sub_command=join q{ },@{$self->commands}? @{$self->commands}: $self->command;$usage .= "usage: $cmd $sub_command [options]"}else {$usage .= "usage: $cmd [options]";$usage .= ' COMMAND' if keys %$summary}$usage .= ($args ? " $args" : '')."\n\n";for my$o (@$struct){my ($name_spec,$desc,$arg_spec,$dist,$opts)=@$o;$desc='' unless defined$desc;my@onames=$self->_option_names($name_spec);my$optname=join (', ',map {(length($_)> 1 ? '--' : '-').$_}@onames);$optname='    '.$optname unless length($onames[0])==1;my$info=do {local$Data::Dumper::Indent=0;local$Data::Dumper::Terse=1;my$info=[];push @$info,$self->_opt_spec2name($arg_spec)|| $arg_spec || '';push @$info,$opts->{required}? "(required)" : '';push @$info,defined$opts->{default}? "(default: ".Data::Dumper::Dumper($opts->{default}).")" : '';$info};push@help,[$optname,$info,ucfirst($desc)]}if (@help){require Text::Table;my$sep=\'   ';$usage .= "options:\n";$usage .= Text::Table->new($sep,'',$sep,'',$sep,'')->load($self->_format_info(@help))->stringify."\n"}if (defined$other_usage && length$other_usage > 0){$other_usage =~ s/\n$//ms;$usage .= "$other_usage\n\n"}if (!$self->command || $self->{has_sub_command}){for my$command (sort keys %$summary){push@commands,[$command,ucfirst$summary->{$command}]}if (@commands){require Text::Table;my$sep=\'   ';$usage .= "Implemented commands are:\n";$usage .= Text::Table->new($sep,'',$sep,'')->load(@commands)->stringify."\n";my$help_command="$cmd help COMMAND";if (@{$self->commands}){my$sub_commands=join q{ },@{$self->commands};$help_command="$cmd $sub_commands COMMAND --help"}$usage .= "See '$help_command' for more information on a specific command.\n\n"}}return$usage}sub show_usage {my$self=shift;print$self->usage(@_);exit!$self->status}sub completion {my($self,$shell)=@_;$shell ||= 'bash';if ($shell eq 'bash'){return$self->_completion_bash}else {Carp::carp("Not implemented: completion for $shell");return ""}}sub show_completion {my$self=shift;print$self->completion(@_);exit!$self->status}sub _completion_bash {my$self=shift;my$comp='';my$prog=$self->{name}|| substr($0,rindex($0,'/')+1);my$fname=$prog;$fname =~ s/[.-]/_/g;my@global_opts;my@commands;my$case={word=>'"$cmd"',cases=>[],};@global_opts=$self->_options2optarg($self->{struct});for my$cmd (sort keys %{$self->{_struct}}){my$s=$self->{_struct}{$cmd};my@opts=$self->_options2optarg($s->{options});my@commands2;if (ref$s->{command_struct}eq 'HASH'){for my$cmd (sort keys %{$s->{command_struct}}){my$s=$s->{command_struct}{$cmd};my@opts=$self->_options2optarg($s->{options});push@commands2,{cmd=>$cmd,opts=>\@opts,}}}push@commands,{cmd=>$cmd,opts=>\@opts,subcmd=>\@commands2,args=>($s->{args}|| ''),}}$comp .= "_$fname() {\n";$comp .= <<'EOC';$comp .= sprintf qq{  local global_opts="%s"\n},join(" ",map {@{$_->{opt}}}@global_opts);$comp .= sprintf qq{  local cmds="%s"\n},join(" ",map {$_->{cmd}}@commands);$comp .= "\n";for my$command (@commands){my$case_prev={word=>'"$prev"',cases=>[_opts2casecmd(@{$command->{opts}}),{pat=>'*',cmd=>['COMPREPLY=($(compgen -W "'._gen_wordlist($command).'" -- "$cur"))'],},],};if (scalar(@{$command->{subcmd}})> 0){my@cases;for my$subcommand (@{$command->{subcmd}}){next if (scalar(@{$subcommand->{opts}})<= 0);push@cases,{pat=>$subcommand->{cmd},cmd=>[{word=>'"$prev"',cases=>[_opts2casecmd(@{$subcommand->{opts}}),{pat=>'*',cmd=>['COMPREPLY=($(compgen -W "'._gen_wordlist($subcommand).'" -- "$cur"))'],},],}],}}push@cases,{pat=>'*',cmd=>[$case_prev ],};push @{$case->{cases}},{pat=>$command->{cmd},cmd=>[{word=>'"${cmd[1]}"',cases=>[@cases],}],}}else {push @{$case->{cases}},{pat=>$command->{cmd},cmd=>[$case_prev ],}}}push @{$case->{cases}},{pat=>'*',cmd=>[{word=>'"$prev"',cases=>[_opts2casecmd(@global_opts),{pat=>'*',cmd=>['COMPREPLY=($(compgen -W "$global_opts $cmds" -- "$cur"))'],},],}],};my@c=_generate_case_command($case);$comp .= join("\n",map {"  ".$_}@c)."\n";$comp .= <<"EOC";return$comp}sub _generate_case_command {my$case=shift;my@line;push@line,"case $case->{word} in";for my$c (@{$case->{cases}}){push@line,"  $c->{pat})";for my$cmd (@{$c->{cmd}},';;'){if (ref$cmd eq 'HASH'){push@line,map {"    ".$_}_generate_case_command->($cmd)}else {push@line,"    ".$cmd}}}push@line,"esac";return@line}sub _options2optarg {my($self,$opts)=@_;my@optarg;for my$o (@{$opts}){my ($name_spec,$desc,$arg_spec,$dist,$opts)=@$o;my@onames=map {(length($_)> 1 ? '--' : '-').$_}$self->_option_names($name_spec);my$arg=$self->_opt_spec2name($arg_spec)|| $arg_spec || '';$arg='' if$arg eq 'Incr';push@optarg,{opt=>\@onames,arg=>$arg,}}return@optarg}sub _opts2casecmd {my@cases;for my$o (grep {$_->{arg}}@_){push@cases,{pat=>join("|",@{$o->{opt}}),cmd=>['COMPREPLY=($(compgen -W "'.$o->{arg}.'" -- "$cur"))'],}}return@cases}sub _gen_wordlist {my$command=shift;return join(" ",'-h','--help',(map {@{$_->{opt}}}@{$command->{opts}}),($command->{args}||''),(map {$_->{cmd}}@{$command->{subcmd}}),)}sub _opt_spec2name {my ($self,$spec)=@_;my$name='';return$name unless defined$spec;my ($type,$dest)=$spec =~ /^[=:]?([!+isof])([@%])?/;if ($type){$name=$type eq '!' ? 'Bool' : $type eq '+' ? 'Incr' : $type eq 's' ? 'Str' : $type eq 'i' ? 'Int' : $type eq 'f' ? 'Num' : $type eq 'o' ? 'ExNum' : ''}if ($dest){$name=$dest eq '@' ? "Array[$name]" : $dest eq '%' ? "Hash[$name]" : $name}return$name}sub _format_info {my ($self,@help)=@_;my$type_max=0;my$required_max=0;my$default_max=0;for my$row (@help){my ($type,$required,$default)=@{$row->[1]};$type_max=max$type_max,length($type);$required_max=max$required_max,length($required);$default_max=max$default_max,length($default)}for my$row (@help){my ($type,$required,$default)=@{$row->[1]};my$parts=[];for my$stuff ([$type_max,$type],[$required_max,$required],[$default_max,$default]){push @$parts,sprintf '%-*s',@$stuff if$stuff->[0]> 0}$row->[1]=join ' ',@$parts}return@help}sub _parse_command_struct {my ($self,$command_struct)=@_;$command_struct ||= {};my$command_map={map {$_=>1}keys %$command_struct };my$command=shift@ARGV;unless (defined$command){$self->{ret}=$self->_check_requires;return$self}unless ($command_map->{help}){$command_map->{help}=1;$command_struct->{help}={args=>'[COMMAND]',desc=>'show help message',}}unless (exists$command_map->{$command}){$self->{error}="Unknown command: $command";$self->{ret}=0;return$self}$self->{command}||= $command;if ($command eq 'help'){$self->{ret}=0;delete$self->{error};if (defined$ARGV[0]&& exists$command_struct->{$ARGV[0]}){my$nested_struct=$command_struct->{$ARGV[0]}{command_struct};$self->_init_nested_struct($nested_struct)if$nested_struct}return$self}push @{$self->{commands}||= []},$command;$self->_init_struct($command_struct->{$command}{options});$self->_extends_usage($command_struct->{$command});my$opthash=$self->_parse_struct || return$self;if (my$nested_struct=$command_struct->{$command}{command_struct}){$self->_init_nested_struct($nested_struct);my@opts=$self->_parse_argv($nested_struct);$self->{ret}=$self->_parse_option(\@opts,$opthash);unshift@ARGV,@opts;$self->_check_requires;if ($self->_want_help){delete$self->{error};$self->{ret}=0}return$self unless$self->{ret};$self->_parse_command_struct($nested_struct)}else {$self->{ret}=$self->_parse_option(\@ARGV,$opthash);$self->_check_requires;$self->{has_sub_command}=0;if ($self->_want_help){delete$self->{error};$self->{ret}=0}}return$self}sub _want_help {exists $_[0]->{opt}{help}&& $_[0]->{opt}{help}? 1 : 0}sub _init_nested_struct {my ($self,$nested_struct)=@_;$self->{summary}={};$self->_init_summary($nested_struct);$self->{has_sub_command}=1}sub _parse_option {my ($self,$argv,$opthash)=@_;local$SIG{__WARN__}=sub {$self->{error}=join '',@_;chomp$self->{error}};my$ret=GetOptionsFromArray($argv,%$opthash)? 1 : 0;$self->{parsed_opthash}=$opthash;return$ret}sub _parse_argv {my ($self,$struct)=@_;$struct ||= $self->{_struct};my@opts;while (@ARGV){my$argv=shift@ARGV;push@opts,$argv;last if exists$struct->{$argv}}return@opts}sub _parse_struct {my ($self)=@_;my$struct=$self->{struct};my$opthash={};my$default_opthash={};my$default_args=[];for my$s (@$struct){my($m,$descr,$spec,$ref,$opts)=@$s;my@onames=$self->_option_names($m);my($longname)=grep length($_)> 1,@onames;my ($type,$cb)=$self->_compile_spec($spec);my$o=join('|',@onames).($type||'');my$dest=$longname ? $longname : $onames[0];$opts ||= {};my$destination;if (ref$cb eq 'CODE'){my$t=substr($type,-1,1)eq '@' ? 'Array' : substr($type,-1,1)eq '%' ? 'Hash' : '';if (ref$ref eq 'CODE'){$destination=sub {$ref->($_[0],$cb->($_[1]))}}elsif (ref$ref){if (ref$ref eq 'SCALAR' || ref$ref eq 'REF'){$$ref=$t eq 'Array' ? []: $t eq 'Hash' ? {}: undef}elsif (ref$ref eq 'ARRAY'){@$ref=()}elsif (ref$ref eq 'HASH'){%$ref=()}$destination=sub {if ($t eq 'Array'){if (ref$ref eq 'SCALAR' || ref$ref eq 'REF'){push @{$$ref},scalar$cb->($_[1])}elsif (ref$ref eq 'ARRAY'){push @$ref,scalar$cb->($_[1])}elsif (ref$ref eq 'HASH'){my@kv=split '=',$_[1],2;die qq(Option $_[0], key "$_[1]", requires a value\n) unless@kv==2;$ref->{$kv[0]}=scalar$cb->($kv[1])}}elsif ($t eq 'Hash'){if (ref$ref eq 'SCALAR' || ref$ref eq 'REF'){$$ref->{$_[1]}=scalar$cb->($_[2])}elsif (ref$ref eq 'ARRAY'){push @$ref,$_[1],scalar$cb->($_[2])}elsif (ref$ref eq 'HASH'){$ref->{$_[1]}=scalar$cb->($_[2])}}else {if (ref$ref eq 'SCALAR' || ref$ref eq 'REF'){$$ref=$cb->($_[1])}elsif (ref$ref eq 'ARRAY'){@$ref=(scalar$cb->($_[1]))}elsif (ref$ref eq 'HASH'){my@kv=split '=',$_[1],2;die qq(Option $_[0], key "$_[1]", requires a value\n) unless@kv==2;%$ref=($kv[0]=>scalar$cb->($kv[1]))}}}}else {$destination=sub {if ($t eq 'Array'){$self->{opt}{$dest}||= [];push @{$self->{opt}{$dest}},scalar$cb->($_[1])}elsif ($t eq 'Hash'){$self->{opt}{$dest}||= {};$self->{opt}{$dest}{$_[1]}=$cb->($_[2])}else {$self->{opt}{$dest}=$cb->($_[1])}}}}else {$destination=ref$ref ? $ref : \$self->{opt}{$dest}}if (exists$opts->{default}){my$value=$opts->{default};if (ref$value eq 'ARRAY'){push @$default_args,map {("--$dest",$_)}grep {defined $_}@$value}elsif (ref$value eq 'HASH'){push @$default_args,map {(my$key=$_)=~ s/=/\\=/g;("--$dest"=>"$key=$value->{$_}")}grep {defined$value->{$_}}keys %$value}elsif (not ref$value){if (!$spec || ($TYPE_MAP->{$spec}|| $spec)eq '!'){push @$default_args,"--$dest" if$value}else {push @$default_args,"--$dest",$value if defined$value}}else {$self->{error}="Invalid default option for $dest";$self->{ret}=0}$default_opthash->{$o}=$destination}$opthash->{$o}=$destination;$self->{requires}{$dest}=$o if$opts->{required}}return if$self->{error};if (@$default_args){$self->{ret}=$self->_parse_option($default_args,$default_opthash);unshift@ARGV,@$default_args;return unless$self->{ret}}return$opthash}sub _init_struct {my ($self,$struct)=@_;$self->{struct}=ref$struct eq 'ARRAY' ? $struct : ref$struct eq 'HASH' ? $self->_normalize_struct($struct): [];if (ref$self->{modes}eq 'ARRAY'){my@modeopt;for my$m (@{$self->{modes}}){my($mc)=$m =~ /^(\w)/;push@modeopt,[[$mc,$m],qq($m mode)]}unshift @$struct,@modeopt}unshift @{$self->{struct}},[[qw(h help)],qq(this help message)]if$self->{usage}&&!$self->_has_option('help')}sub _normalize_struct {my ($self,$struct)=@_;my$result=[];for my$option (keys %$struct){my$data=$struct->{$option}|| {};$data=ref$data eq 'HASH' ? $data : {};my$row=[];push @$row,[$option,ref$data->{alias}eq 'ARRAY' ? @{$data->{alias}}: defined$data->{alias}? $data->{alias}: (),];push @$row,$data->{desc};push @$row,$data->{type};push @$row,$data->{dest};push @$row,$data->{opts};push @$result,$row}return$result}sub _compile_spec {my ($self,$spec)=@_;return if!defined$spec or $spec eq '';return$spec if$self->_opt_spec2name($spec);my ($type,$cb);if ($spec =~ /^(Array|Hash)\[(\w+)\]$/){$type=$TYPE_MAP->{$2}|| Carp::croak("Can't find type constraint '$2'");$type .= $1 eq 'Array' ? '@' : '%';$cb=$TYPE_GEN->{$2}}elsif ($type=$TYPE_MAP->{$spec}){$cb=$TYPE_GEN->{$spec}}else {Carp::croak("Can't find type constraint '$spec'")}return$type,$cb}sub add_type {my ($class,$name,$src_type,$cb)=@_;unless (defined$name && $src_type && ref$cb eq 'CODE'){Carp::croak("Usage: $class->add_type(\$name, \$src_type, \$cb)")}unless ($TYPE_MAP->{$src_type}){Carp::croak("$src_type is not defined src type")}$TYPE_MAP->{$name}=$TYPE_MAP->{$src_type};$TYPE_GEN->{$name}=$cb}sub _init_summary {my ($self,$command_struct)=@_;if ($command_struct){for my$key (keys %$command_struct){$self->{summary}{$key}=$command_struct->{$key}->{desc}|| ''}}else {$self->{summary}={}}}sub _extends_usage {my ($self,$command_option)=@_;for my$key (qw/args other_usage/){$self->{$key}=$command_option->{$key}if exists$command_option->{$key}}}sub _check_requires {my ($self)=@_;for my$dest (sort keys %{$self->{requires}}){unless (defined$self->{opt}{$dest}){unless (defined ${$self->{parsed_opthash}{$self->{requires}{$dest}}}){$self->{ret}=0;$self->{error}="`--$dest` option must be specified";return 0}}}return 1}sub _option_names {my($self,$m)=@_;my@sorted=sort {my ($la,$lb)=(length($a),length($b));return$la <=> $lb if$la < 2 or $lb < 2;return 0}ref$m eq 'ARRAY' ? @$m : $m;return@sorted}sub _has_option {my($self,$option)=@_;return 1 if grep {$_ eq $option}map {$self->_option_names($_->[0])}@{$self->{struct}};return 0}1;
    COMPREPLY=()
    local cur=${COMP_WORDS[COMP_CWORD]}
    local prev=${COMP_WORDS[COMP_CWORD-1]}
    local cmd=()
    for ((i=1; i<COMP_CWORD; i++)); do
      # skip global opts and type to find cmd
      if [[ "${COMP_WORDS[$i]}" != -* && "${COMP_WORDS[$i]}" != [A-Z]* ]]; then
        cmd[${#cmd[@]}]=${COMP_WORDS[$i]}
      fi
    done
  
  EOC
  }
  
  complete -F _$fname $prog
  EOC
GETOPT_COMPACT_WITHCMD

$fatpacked{"Getopt/Long.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GETOPT_LONG';
  package Getopt::Long;use 5.004;use strict;use vars qw($VERSION);$VERSION=2.42;use vars qw($VERSION_STRING);$VERSION_STRING="2.42";use Exporter;use vars qw(@ISA @EXPORT @EXPORT_OK);@ISA=qw(Exporter);sub GetOptions(@);sub GetOptionsFromArray(@);sub GetOptionsFromString(@);sub Configure(@);sub HelpMessage(@);sub VersionMessage(@);BEGIN {@EXPORT=qw(&GetOptions $REQUIRE_ORDER $PERMUTE $RETURN_IN_ORDER);@EXPORT_OK=qw(&HelpMessage &VersionMessage &Configure &GetOptionsFromArray &GetOptionsFromString)}use vars@EXPORT,@EXPORT_OK;use vars qw($error $debug $major_version $minor_version);use vars qw($autoabbrev $getopt_compat $ignorecase $bundling $order $passthrough);use vars qw($genprefix $caller $gnu_compat $auto_help $auto_version $longprefix);sub config(@);sub ConfigDefaults();sub ParseOptionSpec($$);sub OptCtl($);sub FindOption($$$$$);sub ValidValue ($$$$$);my$requested_version=0;sub ConfigDefaults() {if (defined$ENV{"POSIXLY_CORRECT"}){$genprefix="(--|-)";$autoabbrev=0;$bundling=0;$getopt_compat=0;$order=$REQUIRE_ORDER}else {$genprefix="(--|-|\\+)";$autoabbrev=1;$bundling=0;$getopt_compat=1;$order=$PERMUTE}$debug=0;$error=0;$ignorecase=1;$passthrough=0;$gnu_compat=0;$longprefix="(--)"}sub import {my$pkg=shift;my@syms=();my@config=();my$dest=\@syms;for (@_){if ($_ eq ':config'){$dest=\@config;next}push(@$dest,$_)}local$Exporter::ExportLevel=1;push(@syms,qw(&GetOptions))if@syms;$requested_version=0;$pkg->SUPER::import(@syms);Configure(@config)if@config}($REQUIRE_ORDER,$PERMUTE,$RETURN_IN_ORDER)=(0..2);($major_version,$minor_version)=$VERSION =~ /^(\d+)\.(\d+)/;ConfigDefaults();package Getopt::Long::Parser;my$default_config=do {Getopt::Long::Configure ()};sub new {my$that=shift;my$class=ref($that)|| $that;my%atts=@_;my$self={caller_pkg=>(caller)[0]};bless ($self,$class);if (defined$atts{config}){my$save=Getopt::Long::Configure ($default_config,@{$atts{config}});$self->{settings}=Getopt::Long::Configure ($save);delete ($atts{config})}else {$self->{settings}=$default_config}if (%atts){die(__PACKAGE__.": unhandled attributes: ".join(" ",sort(keys(%atts)))."\n")}$self}sub configure {my ($self)=shift;my$save=Getopt::Long::Configure ($self->{settings},@_);$self->{settings}=Getopt::Long::Configure ($save)}sub getoptions {my ($self)=shift;return$self->getoptionsfromarray(\@ARGV,@_)}sub getoptionsfromarray {my ($self)=shift;my$save=Getopt::Long::Configure ($self->{settings});my$ret=0;$Getopt::Long::caller=$self->{caller_pkg};eval {local ($SIG{__DIE__})='DEFAULT';$ret=Getopt::Long::GetOptionsFromArray (@_)};Getopt::Long::Configure ($save);die ($@)if $@;return$ret}package Getopt::Long;use constant CTL_TYPE=>0;use constant CTL_CNAME=>1;use constant CTL_DEFAULT=>2;use constant CTL_DEST=>3;use constant CTL_DEST_SCALAR=>0;use constant CTL_DEST_ARRAY=>1;use constant CTL_DEST_HASH=>2;use constant CTL_DEST_CODE=>3;use constant CTL_AMIN=>4;use constant CTL_AMAX=>5;use constant PAT_INT=>"[-+]?_*[0-9][0-9_]*";use constant PAT_XINT=>"(?:"."[-+]?_*[1-9][0-9_]*"."|"."0x_*[0-9a-f][0-9a-f_]*"."|"."0b_*[01][01_]*"."|"."0[0-7_]*".")";use constant PAT_FLOAT=>"[-+]?[0-9_]+(\.[0-9_]+)?([eE][-+]?[0-9_]+)?";sub GetOptions(@) {unshift(@_,\@ARGV);goto&GetOptionsFromArray}sub GetOptionsFromString(@) {my ($string)=shift;require Text::ParseWords;my$args=[Text::ParseWords::shellwords($string)];$caller ||= (caller)[0];my$ret=GetOptionsFromArray($args,@_);return ($ret,$args)if wantarray;if (@$args){$ret=0;warn("GetOptionsFromString: Excess data \"@$args\" in string \"$string\"\n")}$ret}sub GetOptionsFromArray(@) {my ($argv,@optionlist)=@_;my$argend='--';my%opctl=();my$pkg=$caller || (caller)[0];my@ret=();my%linkage;my$userlinkage;my$opt;my$prefix=$genprefix;$error='';if ($debug){local ($^W)=0;print STDERR ("Getopt::Long $Getopt::Long::VERSION ","called from package \"$pkg\".","\n  ","argv: (@$argv)","\n  ","autoabbrev=$autoabbrev,"."bundling=$bundling,","getopt_compat=$getopt_compat,","gnu_compat=$gnu_compat,","order=$order,","\n  ","ignorecase=$ignorecase,","requested_version=$requested_version,","passthrough=$passthrough,","genprefix=\"$genprefix\",","longprefix=\"$longprefix\".","\n")}$userlinkage=undef;if (@optionlist && ref($optionlist[0])and UNIVERSAL::isa($optionlist[0],'HASH')){$userlinkage=shift (@optionlist);print STDERR ("=> user linkage: $userlinkage\n")if$debug}if (@optionlist && $optionlist[0]=~ /^\W+$/ &&!($optionlist[0]eq '<>' && @optionlist > 0 && ref($optionlist[1]))){$prefix=shift (@optionlist);$prefix =~ s/(\W)/\\$1/g;$prefix="([" .$prefix ."])";print STDERR ("=> prefix=\"$prefix\"\n")if$debug}%opctl=();while (@optionlist){my$opt=shift (@optionlist);unless (defined($opt)){$error .= "Undefined argument in option spec\n";next}$opt=$+ if$opt =~ /^$prefix+(.*)$/s;if ($opt eq '<>'){if ((defined$userlinkage)&&!(@optionlist > 0 && ref($optionlist[0]))&& (exists$userlinkage->{$opt})&& ref($userlinkage->{$opt})){unshift (@optionlist,$userlinkage->{$opt})}unless (@optionlist > 0 && ref($optionlist[0])&& ref($optionlist[0])eq 'CODE'){$error .= "Option spec <> requires a reference to a subroutine\n";shift (@optionlist)if@optionlist && ref($optionlist[0]);next}$linkage{'<>'}=shift (@optionlist);next}my ($name,$orig)=ParseOptionSpec ($opt,\%opctl);unless (defined$name){$error .= $orig;shift (@optionlist)if@optionlist && ref($optionlist[0]);next}if (defined$userlinkage){unless (@optionlist > 0 && ref($optionlist[0])){if (exists$userlinkage->{$orig}&& ref($userlinkage->{$orig})){print STDERR ("=> found userlinkage for \"$orig\": ","$userlinkage->{$orig}\n")if$debug;unshift (@optionlist,$userlinkage->{$orig})}else {next}}}if (@optionlist > 0 && ref($optionlist[0])){print STDERR ("=> link \"$orig\" to $optionlist[0]\n")if$debug;my$rl=ref($linkage{$orig}=shift (@optionlist));if ($rl eq "ARRAY"){$opctl{$name}[CTL_DEST]=CTL_DEST_ARRAY}elsif ($rl eq "HASH"){$opctl{$name}[CTL_DEST]=CTL_DEST_HASH}elsif ($rl eq "SCALAR" || $rl eq "REF"){}elsif ($rl eq "CODE"){}else {$error .= "Invalid option linkage for \"$opt\"\n"}}else {my$ov=$orig;$ov =~ s/\W/_/g;if ($opctl{$name}[CTL_DEST]==CTL_DEST_ARRAY){print STDERR ("=> link \"$orig\" to \@$pkg","::opt_$ov\n")if$debug;eval ("\$linkage{\$orig} = \\\@".$pkg."::opt_$ov;")}elsif ($opctl{$name}[CTL_DEST]==CTL_DEST_HASH){print STDERR ("=> link \"$orig\" to \%$pkg","::opt_$ov\n")if$debug;eval ("\$linkage{\$orig} = \\\%".$pkg."::opt_$ov;")}else {print STDERR ("=> link \"$orig\" to \$$pkg","::opt_$ov\n")if$debug;eval ("\$linkage{\$orig} = \\\$".$pkg."::opt_$ov;")}}if ($opctl{$name}[CTL_TYPE]eq 'I' && ($opctl{$name}[CTL_DEST]==CTL_DEST_ARRAY || $opctl{$name}[CTL_DEST]==CTL_DEST_HASH)){$error .= "Invalid option linkage for \"$opt\"\n"}}die ($error)if$error;$error=0;if (defined($auto_version)? $auto_version : ($requested_version >= 2.3203)){if (!defined($opctl{version})){$opctl{version}=['','version',0,CTL_DEST_CODE,undef];$linkage{version}=\&VersionMessage}$auto_version=1}if (defined($auto_help)? $auto_help : ($requested_version >= 2.3203)){if (!defined($opctl{help})&&!defined($opctl{'?'})){$opctl{help}=$opctl{'?'}=['','help',0,CTL_DEST_CODE,undef];$linkage{help}=\&HelpMessage}$auto_help=1}if ($debug){my ($arrow,$k,$v);$arrow="=> ";while (($k,$v)=each(%opctl)){print STDERR ($arrow,"\$opctl{$k} = $v ",OptCtl($v),"\n");$arrow="   "}}my$goon=1;while ($goon && @$argv > 0){$opt=shift (@$argv);print STDERR ("=> arg \"",$opt,"\"\n")if$debug;if (defined($opt)&& $opt eq $argend){push (@ret,$argend)if$passthrough;last}my$tryopt=$opt;my$found;my$key;my$arg;my$ctl;($found,$opt,$ctl,$arg,$key)=FindOption ($argv,$prefix,$argend,$opt,\%opctl);if ($found){next unless defined$opt;my$argcnt=0;while (defined$arg){print STDERR ("=> cname for \"$opt\" is ")if$debug;$opt=$ctl->[CTL_CNAME];print STDERR ("\"$ctl->[CTL_CNAME]\"\n")if$debug;if (defined$linkage{$opt}){print STDERR ("=> ref(\$L{$opt}) -> ",ref($linkage{$opt}),"\n")if$debug;if (ref($linkage{$opt})eq 'SCALAR' || ref($linkage{$opt})eq 'REF'){if ($ctl->[CTL_TYPE]eq '+'){print STDERR ("=> \$\$L{$opt} += \"$arg\"\n")if$debug;if (defined ${$linkage{$opt}}){${$linkage{$opt}}+= $arg}else {${$linkage{$opt}}=$arg}}elsif ($ctl->[CTL_DEST]==CTL_DEST_ARRAY){print STDERR ("=> ref(\$L{$opt}) auto-vivified"," to ARRAY\n")if$debug;my$t=$linkage{$opt};$$t=$linkage{$opt}=[];print STDERR ("=> push(\@{\$L{$opt}, \"$arg\")\n")if$debug;push (@{$linkage{$opt}},$arg)}elsif ($ctl->[CTL_DEST]==CTL_DEST_HASH){print STDERR ("=> ref(\$L{$opt}) auto-vivified"," to HASH\n")if$debug;my$t=$linkage{$opt};$$t=$linkage{$opt}={};print STDERR ("=> \$\$L{$opt}->{$key} = \"$arg\"\n")if$debug;$linkage{$opt}->{$key}=$arg}else {print STDERR ("=> \$\$L{$opt} = \"$arg\"\n")if$debug;${$linkage{$opt}}=$arg}}elsif (ref($linkage{$opt})eq 'ARRAY'){print STDERR ("=> push(\@{\$L{$opt}, \"$arg\")\n")if$debug;push (@{$linkage{$opt}},$arg)}elsif (ref($linkage{$opt})eq 'HASH'){print STDERR ("=> \$\$L{$opt}->{$key} = \"$arg\"\n")if$debug;$linkage{$opt}->{$key}=$arg}elsif (ref($linkage{$opt})eq 'CODE'){print STDERR ("=> &L{$opt}(\"$opt\"",$ctl->[CTL_DEST]==CTL_DEST_HASH ? ", \"$key\"" : "",", \"$arg\")\n")if$debug;my$eval_error=do {local $@;local$SIG{__DIE__}='DEFAULT';eval {&{$linkage{$opt}}(Getopt::Long::CallBack->new (name=>$opt,ctl=>$ctl,opctl=>\%opctl,linkage=>\%linkage,prefix=>$prefix,),$ctl->[CTL_DEST]==CTL_DEST_HASH ? ($key): (),$arg)};$@};print STDERR ("=> die($eval_error)\n")if$debug && $eval_error ne '';if ($eval_error =~ /^!/){if ($eval_error =~ /^!FINISH\b/){$goon=0}}elsif ($eval_error ne ''){warn ($eval_error);$error++}}else {print STDERR ("Invalid REF type \"",ref($linkage{$opt}),"\" in linkage\n");die("Getopt::Long -- internal error!\n")}}elsif ($ctl->[CTL_DEST]==CTL_DEST_ARRAY){if (defined$userlinkage->{$opt}){print STDERR ("=> push(\@{\$L{$opt}}, \"$arg\")\n")if$debug;push (@{$userlinkage->{$opt}},$arg)}else {print STDERR ("=>\$L{$opt} = [\"$arg\"]\n")if$debug;$userlinkage->{$opt}=[$arg]}}elsif ($ctl->[CTL_DEST]==CTL_DEST_HASH){if (defined$userlinkage->{$opt}){print STDERR ("=> \$L{$opt}->{$key} = \"$arg\"\n")if$debug;$userlinkage->{$opt}->{$key}=$arg}else {print STDERR ("=>\$L{$opt} = {$key => \"$arg\"}\n")if$debug;$userlinkage->{$opt}={$key=>$arg}}}else {if ($ctl->[CTL_TYPE]eq '+'){print STDERR ("=> \$L{$opt} += \"$arg\"\n")if$debug;if (defined$userlinkage->{$opt}){$userlinkage->{$opt}+= $arg}else {$userlinkage->{$opt}=$arg}}else {print STDERR ("=>\$L{$opt} = \"$arg\"\n")if$debug;$userlinkage->{$opt}=$arg}}$argcnt++;last if$argcnt >= $ctl->[CTL_AMAX]&& $ctl->[CTL_AMAX]!=-1;undef($arg);if ($argcnt < $ctl->[CTL_AMIN]){if (@$argv){if (ValidValue($ctl,$argv->[0],1,$argend,$prefix)){$arg=shift(@$argv);if ($ctl->[CTL_TYPE]=~ /^[iIo]$/){$arg =~ tr/_//d;$arg=$ctl->[CTL_TYPE]eq 'o' && $arg =~ /^0/ ? oct($arg): 0+$arg}($key,$arg)=$arg =~ /^([^=]+)=(.*)/ if$ctl->[CTL_DEST]==CTL_DEST_HASH;next}warn("Value \"$$argv[0]\" invalid for option $opt\n");$error++}else {warn("Insufficient arguments for option $opt\n");$error++}}if (@$argv && ValidValue($ctl,$argv->[0],0,$argend,$prefix)){$arg=shift(@$argv);if ($ctl->[CTL_TYPE]=~ /^[iIo]$/){$arg =~ tr/_//d;$arg=$ctl->[CTL_TYPE]eq 'o' && $arg =~ /^0/ ? oct($arg): 0+$arg}($key,$arg)=$arg =~ /^([^=]+)=(.*)/ if$ctl->[CTL_DEST]==CTL_DEST_HASH;next}}}elsif ($order==$PERMUTE){my$cb;if ((defined ($cb=$linkage{'<>'}))){print STDERR ("=> &L{$tryopt}(\"$tryopt\")\n")if$debug;my$eval_error=do {local $@;local$SIG{__DIE__}='DEFAULT';eval {&$cb($tryopt)};$@};print STDERR ("=> die($eval_error)\n")if$debug && $eval_error ne '';if ($eval_error =~ /^!/){if ($eval_error =~ /^!FINISH\b/){$goon=0}}elsif ($eval_error ne ''){warn ($eval_error);$error++}}else {print STDERR ("=> saving \"$tryopt\" ","(not an option, may permute)\n")if$debug;push (@ret,$tryopt)}next}else {unshift (@$argv,$tryopt);return ($error==0)}}if (@ret && $order==$PERMUTE){print STDERR ("=> restoring \"",join('" "',@ret),"\"\n")if$debug;unshift (@$argv,@ret)}return ($error==0)}sub OptCtl ($) {my ($v)=@_;my@v=map {defined($_)? ($_): ("<undef>")}@$v;"[".join(",","\"$v[CTL_TYPE]\"","\"$v[CTL_CNAME]\"","\"$v[CTL_DEFAULT]\"",("\$","\@","\%","\&")[$v[CTL_DEST]|| 0],$v[CTL_AMIN]|| '',$v[CTL_AMAX]|| '',)."]"}sub ParseOptionSpec ($$) {my ($opt,$opctl)=@_;if ($opt !~ m;^
  		   (
  		     # Option name
  		     (?: \w+[-\w]* )
  		     # Alias names, or "?"
  		     (?: \| (?: \? | \w[-\w]* ) )*
  		     # Aliases
  		     (?: \| (?: [^-|!+=:][^|!+=:]* )? )*
  		   )?
  		   (
  		     # Either modifiers ...
  		     [!+]
  		     |
  		     # ... or a value/dest/repeat specification
  		     [=:] [ionfs] [@%]? (?: \{\d*,?\d*\} )?
  		     |
  		     # ... or an optional-with-default spec
  		     : (?: -?\d+ | \+ ) [@%]?
  		   )?
  		   $;x){return (undef,"Error in option spec: \"$opt\"\n")}my ($names,$spec)=($1,$2);$spec='' unless defined$spec;my$orig;my@names;if (defined$names){@names=split (/\|/,$names);$orig=$names[0]}else {@names=('');$orig=''}my$entry;if ($spec eq '' || $spec eq '+' || $spec eq '!'){$entry=[$spec,$orig,undef,CTL_DEST_SCALAR,0,0]}elsif ($spec =~ /^:(-?\d+|\+)([@%])?$/){my$def=$1;my$dest=$2;my$type=$def eq '+' ? 'I' : 'i';$dest ||= '$';$dest=$dest eq '@' ? CTL_DEST_ARRAY : $dest eq '%' ? CTL_DEST_HASH : CTL_DEST_SCALAR;$entry=[$type,$orig,$def eq '+' ? undef : $def,$dest,0,1]}else {my ($mand,$type,$dest)=$spec =~ /^([=:])([ionfs])([@%])?(\{(\d+)?(,)?(\d+)?\})?$/;return (undef,"Cannot repeat while bundling: \"$opt\"\n")if$bundling && defined($4);my ($mi,$cm,$ma)=($5,$6,$7);return (undef,"{0} is useless in option spec: \"$opt\"\n")if defined($mi)&&!$mi &&!defined($ma)&&!defined($cm);$type='i' if$type eq 'n';$dest ||= '$';$dest=$dest eq '@' ? CTL_DEST_ARRAY : $dest eq '%' ? CTL_DEST_HASH : CTL_DEST_SCALAR;$mi=$mand eq '=' ? 1 : 0 unless defined$mi;$mand=$mi ? '=' : ':';$ma=$mi ? $mi : 1 unless defined$ma || defined$cm;return (undef,"Max must be greater than zero in option spec: \"$opt\"\n")if defined($ma)&&!$ma;return (undef,"Max less than min in option spec: \"$opt\"\n")if defined($ma)&& $ma < $mi;$entry=[$type,$orig,undef,$dest,$mi,$ma||-1]}my$dups='';for (@names){$_=lc ($_)if$ignorecase > (($bundling && length($_)==1)? 1 : 0);if (exists$opctl->{$_}){$dups .= "Duplicate specification \"$opt\" for option \"$_\"\n"}if ($spec eq '!'){$opctl->{"no$_"}=$entry;$opctl->{"no-$_"}=$entry;$opctl->{$_}=[@$entry];$opctl->{$_}->[CTL_TYPE]=''}else {$opctl->{$_}=$entry}}if ($dups && $^W){for (split(/\n+/,$dups)){warn($_."\n")}}($names[0],$orig)}sub FindOption ($$$$$) {my ($argv,$prefix,$argend,$opt,$opctl)=@_;print STDERR ("=> find \"$opt\"\n")if$debug;return (0)unless defined($opt);return (0)unless$opt =~ /^($prefix)(.*)$/s;return (0)if$opt eq "-" &&!defined$opctl->{''};$opt=substr($opt,length($1));my$starter=$1;print STDERR ("=> split \"$starter\"+\"$opt\"\n")if$debug;my$optarg;my$rest;if (($starter=~/^$longprefix$/ || ($getopt_compat && ($bundling==0 || $bundling==2)))&& (my$oppos=index($opt,'=',1))> 0){my$optorg=$opt;$opt=substr($optorg,0,$oppos);$optarg=substr($optorg,$oppos + 1);print STDERR ("=> option \"",$opt,"\", optarg = \"$optarg\"\n")if$debug}my$tryopt=$opt;if ($bundling && $starter eq '-'){$tryopt=$ignorecase ? lc($opt): $opt;if ($bundling==2 && length($tryopt)> 1 && defined ($opctl->{$tryopt})){print STDERR ("=> $starter$tryopt overrides unbundling\n")if$debug}else {$tryopt=$opt;$rest=length ($tryopt)> 0 ? substr ($tryopt,1): '';$tryopt=substr ($tryopt,0,1);$tryopt=lc ($tryopt)if$ignorecase > 1;print STDERR ("=> $starter$tryopt unbundled from ","$starter$tryopt$rest\n")if$debug;$rest=undef unless$rest ne ''}}elsif ($autoabbrev && $opt ne ""){my@names=sort(keys (%$opctl));$opt=lc ($opt)if$ignorecase;$tryopt=$opt;my$pat=quotemeta ($opt);my@hits=grep (/^$pat/,@names);print STDERR ("=> ",scalar(@hits)," hits (@hits) with \"$pat\" ","out of ",scalar(@names),"\n")if$debug;unless ((@hits <= 1)|| (grep ($_ eq $opt,@hits)==1)){my%hit;for (@hits){my$hit=$opctl->{$_}->[CTL_CNAME]if defined$opctl->{$_}->[CTL_CNAME];$hit="no" .$hit if$opctl->{$_}->[CTL_TYPE]eq '!';$hit{$hit}=1}if (keys(%hit)==2){if ($auto_version && exists($hit{version})){delete$hit{version}}elsif ($auto_help && exists($hit{help})){delete$hit{help}}}unless (keys(%hit)==1){return (0)if$passthrough;warn ("Option ",$opt," is ambiguous (",join(", ",@hits),")\n");$error++;return (1,undef)}@hits=keys(%hit)}if (@hits==1 && $hits[0]ne $opt){$tryopt=$hits[0];$tryopt=lc ($tryopt)if$ignorecase;print STDERR ("=> option \"$opt\" -> \"$tryopt\"\n")if$debug}}elsif ($ignorecase){$tryopt=lc ($opt)}my$ctl=$opctl->{$tryopt};unless (defined$ctl){return (0)if$passthrough;if ($bundling==1 && length($starter)==1){$opt=substr($opt,0,1);unshift (@$argv,$starter.$rest)if defined$rest}if ($opt eq ""){warn ("Missing option after ",$starter,"\n")}else {warn ("Unknown option: ",$opt,"\n")}$error++;return (1,undef)}$opt=$tryopt;print STDERR ("=> found ",OptCtl($ctl)," for \"",$opt,"\"\n")if$debug;my$type=$ctl->[CTL_TYPE];my$arg;if ($type eq '' || $type eq '!' || $type eq '+'){if (defined$optarg){return (0)if$passthrough;warn ("Option ",$opt," does not take an argument\n");$error++;undef$opt}elsif ($type eq '' || $type eq '+'){$arg=1}else {$opt =~ s/^no-?//i;$arg=0}unshift (@$argv,$starter.$rest)if defined$rest;return (1,$opt,$ctl,$arg)}my$mand=$ctl->[CTL_AMIN];if ($gnu_compat && defined$optarg && $optarg eq ''){return (1,$opt,$ctl,$type eq 's' ? '' : 0);$optarg=0 unless$type eq 's'}if (defined$optarg ? ($optarg eq ''):!(defined$rest || @$argv > 0)){if ($mand){return (0)if$passthrough;warn ("Option ",$opt," requires an argument\n");$error++;return (1,undef)}if ($type eq 'I'){my@c=@$ctl;$c[CTL_TYPE]='+';return (1,$opt,\@c,1)}return (1,$opt,$ctl,defined($ctl->[CTL_DEFAULT])? $ctl->[CTL_DEFAULT]: $type eq 's' ? '' : 0)}$arg=(defined$rest ? $rest : (defined$optarg ? $optarg : shift (@$argv)));my$key;if ($ctl->[CTL_DEST]==CTL_DEST_HASH && defined$arg){($key,$arg)=($arg =~ /^([^=]*)=(.*)$/s)? ($1,$2): ($arg,defined($ctl->[CTL_DEFAULT])? $ctl->[CTL_DEFAULT]: ($mand ? undef : ($type eq 's' ? "" : 1)));if (!defined$arg){warn ("Option $opt, key \"$key\", requires a value\n");$error++;unshift (@$argv,$starter.$rest)if defined$rest;return (1,undef)}}my$key_valid=$ctl->[CTL_DEST]==CTL_DEST_HASH ? "[^=]+=" : "";if ($type eq 's'){return (1,$opt,$ctl,$arg,$key)if$mand;return (1,$opt,$ctl,$arg,$key)if$ctl->[CTL_DEST]==CTL_DEST_HASH;return (1,$opt,$ctl,$arg,$key)if defined$optarg || defined$rest;return (1,$opt,$ctl,$arg,$key)if$arg eq "-";if ($arg eq $argend || $arg =~ /^$prefix.+/){unshift (@$argv,$arg);$arg=''}}elsif ($type eq 'i' || $type eq 'I' || $type eq 'o'){my$o_valid=$type eq 'o' ? PAT_XINT : PAT_INT;if ($bundling && defined$rest && $rest =~ /^($key_valid)($o_valid)(.*)$/si){($key,$arg,$rest)=($1,$2,$+);chop($key)if$key;$arg=($type eq 'o' && $arg =~ /^0/)? oct($arg): 0+$arg;unshift (@$argv,$starter.$rest)if defined$rest && $rest ne ''}elsif ($arg =~ /^$o_valid$/si){$arg =~ tr/_//d;$arg=($type eq 'o' && $arg =~ /^0/)? oct($arg): 0+$arg}else {if (defined$optarg || $mand){if ($passthrough){unshift (@$argv,defined$rest ? $starter.$rest : $arg)unless defined$optarg;return (0)}warn ("Value \"",$arg,"\" invalid for option ",$opt," (",$type eq 'o' ? "extended " : '',"number expected)\n");$error++;unshift (@$argv,$starter.$rest)if defined$rest;return (1,undef)}else {unshift (@$argv,defined$rest ? $starter.$rest : $arg);if ($type eq 'I'){my@c=@$ctl;$c[CTL_TYPE]='+';return (1,$opt,\@c,1)}$arg=defined($ctl->[CTL_DEFAULT])? $ctl->[CTL_DEFAULT]: 0}}}elsif ($type eq 'f'){my$o_valid=PAT_FLOAT;if ($bundling && defined$rest && $rest =~ /^($key_valid)($o_valid)(.*)$/s){$arg =~ tr/_//d;($key,$arg,$rest)=($1,$2,$+);chop($key)if$key;unshift (@$argv,$starter.$rest)if defined$rest && $rest ne ''}elsif ($arg =~ /^$o_valid$/){$arg =~ tr/_//d}else {if (defined$optarg || $mand){if ($passthrough){unshift (@$argv,defined$rest ? $starter.$rest : $arg)unless defined$optarg;return (0)}warn ("Value \"",$arg,"\" invalid for option ",$opt," (real number expected)\n");$error++;unshift (@$argv,$starter.$rest)if defined$rest;return (1,undef)}else {unshift (@$argv,defined$rest ? $starter.$rest : $arg);$arg=0.0}}}else {die("Getopt::Long internal error (Can't happen)\n")}return (1,$opt,$ctl,$arg,$key)}sub ValidValue ($$$$$) {my ($ctl,$arg,$mand,$argend,$prefix)=@_;if ($ctl->[CTL_DEST]==CTL_DEST_HASH){return 0 unless$arg =~ /[^=]+=(.*)/;$arg=$1}my$type=$ctl->[CTL_TYPE];if ($type eq 's'){return (1)if$mand;return (1)if$arg eq "-";return 0 if$arg eq $argend || $arg =~ /^$prefix.+/;return 1}elsif ($type eq 'i' || $type eq 'I' || $type eq 'o'){my$o_valid=$type eq 'o' ? PAT_XINT : PAT_INT;return$arg =~ /^$o_valid$/si}elsif ($type eq 'f'){my$o_valid=PAT_FLOAT;return$arg =~ /^$o_valid$/}die("ValidValue: Cannot happen\n")}sub Configure (@) {my (@options)=@_;my$prevconfig=[$error,$debug,$major_version,$minor_version,$autoabbrev,$getopt_compat,$ignorecase,$bundling,$order,$gnu_compat,$passthrough,$genprefix,$auto_version,$auto_help,$longprefix ];if (ref($options[0])eq 'ARRAY'){($error,$debug,$major_version,$minor_version,$autoabbrev,$getopt_compat,$ignorecase,$bundling,$order,$gnu_compat,$passthrough,$genprefix,$auto_version,$auto_help,$longprefix)=@{shift(@options)}}my$opt;for$opt (@options){my$try=lc ($opt);my$action=1;if ($try =~ /^no_?(.*)$/s){$action=0;$try=$+}if (($try eq 'default' or $try eq 'defaults')&& $action){ConfigDefaults ()}elsif (($try eq 'posix_default' or $try eq 'posix_defaults')){local$ENV{POSIXLY_CORRECT};$ENV{POSIXLY_CORRECT}=1 if$action;ConfigDefaults ()}elsif ($try eq 'auto_abbrev' or $try eq 'autoabbrev'){$autoabbrev=$action}elsif ($try eq 'getopt_compat'){$getopt_compat=$action;$genprefix=$action ? "(--|-|\\+)" : "(--|-)"}elsif ($try eq 'gnu_getopt'){if ($action){$gnu_compat=1;$bundling=1;$getopt_compat=0;$genprefix="(--|-)";$order=$PERMUTE}}elsif ($try eq 'gnu_compat'){$gnu_compat=$action}elsif ($try =~ /^(auto_?)?version$/){$auto_version=$action}elsif ($try =~ /^(auto_?)?help$/){$auto_help=$action}elsif ($try eq 'ignorecase' or $try eq 'ignore_case'){$ignorecase=$action}elsif ($try eq 'ignorecase_always' or $try eq 'ignore_case_always'){$ignorecase=$action ? 2 : 0}elsif ($try eq 'bundling'){$bundling=$action}elsif ($try eq 'bundling_override'){$bundling=$action ? 2 : 0}elsif ($try eq 'require_order'){$order=$action ? $REQUIRE_ORDER : $PERMUTE}elsif ($try eq 'permute'){$order=$action ? $PERMUTE : $REQUIRE_ORDER}elsif ($try eq 'pass_through' or $try eq 'passthrough'){$passthrough=$action}elsif ($try =~ /^prefix=(.+)$/ && $action){$genprefix=$1;$genprefix="(" .quotemeta($genprefix).")";eval {'' =~ /$genprefix/};die("Getopt::Long: invalid pattern \"$genprefix\"\n")if $@}elsif ($try =~ /^prefix_pattern=(.+)$/ && $action){$genprefix=$1;$genprefix="(" .$genprefix .")" unless$genprefix =~ /^\(.*\)$/;eval {'' =~ m"$genprefix"};die("Getopt::Long: invalid pattern \"$genprefix\"\n")if $@}elsif ($try =~ /^long_prefix_pattern=(.+)$/ && $action){$longprefix=$1;$longprefix="(" .$longprefix .")" unless$longprefix =~ /^\(.*\)$/;eval {'' =~ m"$longprefix"};die("Getopt::Long: invalid long prefix pattern \"$longprefix\"\n")if $@}elsif ($try eq 'debug'){$debug=$action}else {die("Getopt::Long: unknown or erroneous config parameter \"$opt\"\n")}}$prevconfig}sub config (@) {Configure (@_)}sub VersionMessage(@) {my$pa=setup_pa_args("version",@_);my$v=$main::VERSION;my$fh=$pa->{-output}|| ($pa->{-exitval}eq "NOEXIT" || $pa->{-exitval}< 2)? \*STDOUT : \*STDERR;print$fh (defined($pa->{-message})? $pa->{-message}: (),$0,defined$v ? " version $v" : (),"\n","(",__PACKAGE__,"::","GetOptions"," version ",defined($Getopt::Long::VERSION_STRING)? $Getopt::Long::VERSION_STRING : $VERSION,";"," Perl version ",$] >= 5.006 ? sprintf("%vd",$^V): $],")\n");exit($pa->{-exitval})unless$pa->{-exitval}eq "NOEXIT"}sub HelpMessage(@) {eval {require Pod::Usage;import Pod::Usage;1}|| die("Cannot provide help: cannot load Pod::Usage\n");pod2usage(setup_pa_args("help",@_))}sub setup_pa_args($@) {my$tag=shift;@_=()if @_==2 && $_[0]eq $tag;my$pa;if (@_ > 1){$pa={@_ }}else {$pa=shift || {}}if (UNIVERSAL::isa($pa,'HASH')){$pa->{-message}=$pa->{-msg};delete($pa->{-msg})}elsif ($pa =~ /^-?\d+$/){$pa={-exitval=>$pa }}else {$pa={-message=>$pa }}$pa->{-verbose}=0 unless exists($pa->{-verbose});$pa->{-exitval}=0 unless exists($pa->{-exitval});$pa}sub VERSION {$requested_version=$_[1];shift->SUPER::VERSION(@_)}package Getopt::Long::CallBack;sub new {my ($pkg,%atts)=@_;bless {%atts },$pkg}sub name {my$self=shift;''.$self->{name}}use overload '""'=>\&name,fallback=>1;1;
GETOPT_LONG

$fatpacked{"Text/Aligner.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEXT_ALIGNER';
  package Text::Aligner;use strict;use warnings;use 5.008;BEGIN {use Exporter ();use vars qw ($VERSION @ISA @EXPORT @EXPORT_OK %EXPORT_TAGS);$VERSION='0.12';@ISA=qw (Exporter);@EXPORT=qw ();@EXPORT_OK=qw ( align);%EXPORT_TAGS=()}sub align ($@) {my$ali=Text::Aligner->new(shift);$ali->_alloc(map ref eq 'SCALAR' ? $$_ : $_,@_);if (defined wantarray){my@just=map$ali->_justify(ref eq 'SCALAR' ? $$_ : $_),@_;return@just if wantarray;return join "\n",@just,''}else {for (@_){$_=$ali->_justify($_)for ref eq 'SCALAR' ? $$_ : $_}}}sub _new {my$class=shift;my ($width,$pos)=@_;bless {width=>$width,pos=>$pos,left=>Text::Aligner::MaxKeeper->new,right=>Text::Aligner::MaxKeeper->new,},$class}sub new {my ($class,$spec)=@_;$spec ||= 0;my$al;if (!ref($spec)and $spec =~ s/^auto/num/){$al=Text::Aligner::Auto->_new($spec)}else {$al=$class->_new(_compile_alispec($spec))}$al}sub _measure0 {my$al=shift;my$obj=shift;$obj='' unless defined$obj;my ($w,$p);if (ref$obj){($w,$p)=($obj->$al->{width}->(),$obj->$al->{pos}->())}else {($w,$p)=($al->{width}->($obj),$al->{pos}->($obj))}$_ ||= 0 for$w,$p;($p,$w - $p)}use Term::ANSIColor 2.02;sub _measure {my$al=shift;my$obj=shift;$obj='' unless defined$obj;my ($wmeth,$pmeth)=@{$al}{qw(width pos)};$obj=Term::ANSIColor::colorstrip($obj)unless ref$obj;my$w=ref$wmeth ? $wmeth->($obj): $obj->$wmeth;my$p=ref$pmeth ? $pmeth->($obj): $obj->$pmeth;$_ ||= 0 for$w,$p;($p,$w - $p)}sub _status {my@lr=($_[0]->{left}->max,$_[0]->{right}->max);return unless defined($lr[0])and defined($lr[1]);@lr}sub _alloc {my$al=shift;for (@_){my ($l,$r)=$al->_measure($_);$al->{left}->remember($l);$al->{right}->remember($r)}$al}sub _forget {my$al=shift;for (map defined()? $_ : '',@_){my ($l,$r)=$al->_measure($_);$al->{left}->forget($l);$al->{right}->forget($r)}$al}sub _justify {my$al=shift;my$str=shift;$str .= '';my ($l_pad,$r_pad)=$al->_padding($str);substr($str,0,-$l_pad)='' if$l_pad < 0;substr($str,$r_pad)='' if$r_pad < 0;join$str,' ' x $l_pad,' ' x $r_pad}sub _padding {my$al=shift;my$str=shift;my ($this_l,$this_r)=$al->_measure($str);my ($l_pad,$r_pad)=(0,0);if ($al->_status){($l_pad,$r_pad)=$al->_status;$l_pad -= $this_l;$r_pad -= $this_r}($l_pad,$r_pad)}sub _compile_alispec {my$width=sub {length shift};my$pos;local $_=shift || '';if (ref()eq 'Regexp'){my$regex=$_;$pos=sub {local $_=shift;return m/$regex/ ? $-[0]: length}}else {s/^left/0/;s/^center/0.5/;s/^right/1/;if (_is_number($_)){my$proportion=$_;$pos=sub {int($proportion*length shift)}}elsif ($_ =~ /^(?:num|point)(?:\((.*))?/){my$point=defined $1 ? $1 : '';$point =~ s/\)$//;length$point or $point='.';$pos=sub {index(shift().$point,$point)}}else {$pos=sub {0}}}($width,$pos)}sub _is_number {my ($x)=@_;return 0 unless defined$x;return 0 if$x !~ /\d/;return 1 if$x =~ /^-?\d+\.?\d*$/;$x=Term::ANSIColor::colorstrip($x);$x =~ /^-?\d+\.?\d*$/}package Text::Aligner::Auto;sub _new {my$class=shift;my$numspec=shift;bless {num=>Text::Aligner->new('num'),other=>Text::Aligner->new,},$class}sub _alloc {my$aa=shift;my@num=grep _is_number($_),@_;my@other=grep!_is_number($_),@_;$aa->{num}->_alloc(@num);$aa->{other}->_alloc(@other);$aa}sub _forget {my$aa=shift;$aa->{num}->_forget(grep _is_number($_),@_);$aa->{other}->_forget(grep!_is_number($_),@_);$aa}sub _justify {my ($aa,$str)=@_;$str=$aa->{_is_number($str)? 'num' : 'other'}->_justify($str);my$combi=Text::Aligner->new;$combi->_alloc($aa->{num}->_justify(''))if$aa->{num}->_status;$combi->_alloc($aa->{other}->_justify(''))if$aa->{other}->_status;$combi->_justify($str)}BEGIN {*_is_number=\ &Text::Aligner::_is_number}package Text::Aligner::MaxKeeper;sub new {bless {max=>undef,seen=>{},},shift}sub max {$_[0]->{max}}sub remember {my ($mk,$val)=@_;_to_max($mk->{max},$val);$mk->{seen}->{$val}++;$mk}sub forget {my ($mk,$val)=@_;if (exists$mk->{seen}->{$val}){my$seen=$mk->{seen};unless (--$seen->{$val}){delete$seen->{$val};if ($mk->{max}==$val){undef$mk->{max};_to_max($mk->{max},keys %$seen)}}}$mk}sub _to_max {my$var=\ shift;defined $_ and (not defined $$var or $$var < $_)and $$var=$_ for @_;$$var}1;
TEXT_ALIGNER

$fatpacked{"Text/Table.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEXT_TABLE';
  package Text::Table;use strict;use warnings;use 5.008;use List::Util qw(sum max);use Text::Aligner qw(align);BEGIN {our$VERSION='1.130'}use overload '""'=>'stringify',;sub _is_sep {my$datum=shift;return (defined($datum)and ((ref($datum)eq 'SCALAR')or (ref($datum)eq 'HASH' and $datum->{is_sep})))}sub _get_sep_title_body {my$sep=shift;return +(ref($sep)eq 'HASH')? @{$sep}{qw(title body)}: split(/\n/,${$sep},-1)}sub _parse_sep {my$sep=shift;if (!defined($sep)){$sep=''}my ($title,$body)=_get_sep_title_body($sep);if (!defined($body)){$body=$title}($title,$body)=align('left',$title,$body);return {is_sep=>1,title=>$title,body=>$body,}}sub _default_if_empty {my ($ref,$default)=@_;if (!(defined($$ref)&& length($$ref))){$$ref=$default}return}sub _is_align {my$align=shift;return$align =~ /\A(?:left|center|right)/}sub _parse_spec {my$spec=shift;if (!defined($spec)){$spec=''}my$alispec=qr/^ *(?:left|center|right|num|point|auto)/;my ($title,$align,$align_title,$align_title_lines,$sample);if (ref ($spec)eq 'HASH'){($title,$align,$align_title,$align_title_lines,$sample)=@{$spec}{qw(title align align_title align_title_lines sample)}}else {my$alispec=qr/&(.*)/;if ($spec =~ $alispec){($title,$align,$sample)=($spec =~ /(.*)^$alispec\n?(.*)/sm)}else {$title=$spec}for my$s ($title,$sample){if (defined($s)){chomp($s)}}}for my$x ($title,$sample){if (!defined($x)){$x=[]}elsif (ref($x)ne 'ARRAY'){$x=[split /\n/,$x,-1]}}_default_if_empty(\$align,'auto');unless (ref$align eq 'Regexp' or $align =~ /^(?:left|center|right|num\(?|point\(?|auto)/){_warn("Invalid align specification: '$align', using 'auto'");$align='auto'}_default_if_empty(\$align_title,'left');if (!_is_align($align_title)){_warn("Invalid align_title specification: " ."'$align_title', using 'left'",);$align_title='left'}_default_if_empty(\$align_title_lines,$align_title);if (!_is_align($align_title_lines)){_warn("Invalid align_title_lines specification: " ."'$align_title_lines', using 'left'",);$align_title_lines='left'}return {title=>$title,align=>$align,align_title=>$align_title,align_title_lines=>$align_title_lines,sample=>$sample,}}sub new {my$tb=bless {},shift;return$tb->_entitle([@_ ])}sub _blank {my$self=shift;if (@_){$self->{blank}=shift}return$self->{blank}}sub _cols {my$self=shift;if (@_){$self->{cols}=shift}return$self->{cols}}sub _forms {my$self=shift;if (@_){$self->{forms}=shift}return$self->{forms}}sub _lines {my$self=shift;if (@_){$self->{lines}=shift}return$self->{lines}}sub _spec {my$self=shift;if (@_){$self->{spec}=shift}return$self->{spec}}sub _titles {my$self=shift;if (@_){$self->{titles}=shift}return$self->{titles}}sub _entitle {my ($tb,$sep_list)=@_;my (@seps,@spec);my$sep;for my$sep_item (@{$sep_list}){if (_is_sep ($sep_item)){$sep=_parse_sep($sep_item)}else {push@seps,$sep;push@spec,_parse_spec($sep_item);undef$sep}}push@seps,$sep;my$title_form=_compile_field_format('title',\@seps);my$body_form=_compile_field_format('body',\@seps);my@titles=map {[@{$_->{title}}]}@spec;my$title_height=max(0,map {scalar(@$_)}@titles);for my$title (@titles){push @{$title},('')x ($title_height - @{$title})}for my$t_idx (0 .. $#titles){align($spec[$t_idx]->{align_title_lines},@{$titles[$t_idx]})}$tb->_spec(\@spec);$tb->_cols([map [],1 .. @spec]);$tb->_forms([$title_form,$body_form]);$tb->_titles(\@titles);$tb->_clear_cache;return$tb}sub _compile_format {my$seps=shift;for my$idx (0 .. $#$seps){if (!defined($seps->[$idx])){$seps->[$idx]=($idx==0 or $idx==$#$seps)? '' : q{ }}else {$seps->[$idx]=~ s/%/%%/g}}return join '%s',@$seps}sub _compile_field_format {my ($field,$seps)=@_;return _compile_format([map {defined($_)? $_->{$field}: undef}@$seps])}sub _recover_separators {my$format=shift;my@seps=split /(?<!%)%s/,$format,-1;for my$s (@seps){$s =~ s/%%/%/g}return \@seps}sub select {my$tb=shift;my@args=map$tb->_select_group($_),@_;my@sel=map$tb->_check_index($_),grep!_is_sep($_),@args;for my$arg (@args){if (!_is_sep($arg)){$arg=$tb->_spec->[$arg]}}my$sub=ref($tb)->new(@args);@{$sub->{cols}}=map {[@$_ ]}@{$tb->_cols}[@sel];$sub}sub _select_group {my ($tb,$group)=@_;return$group unless ref$group eq 'ARRAY';GROUP_LOOP: for my$g (@$group){if (_is_sep($g)){next GROUP_LOOP}$tb->_check_index($g);if (grep {$_}@{$tb->_cols->[$g]}){return @$group}return}return}sub _check_index {my$tb=shift;my ($i)=@_;my$n=$tb->n_cols;my$ok=eval {use warnings FATAL=>'numeric';-$n <= $i and $i < $n};_warn("Invalid column index '$_'")if $@ or not $ok;shift}sub _clear_cache {my ($tb)=@_;$tb->_blank(undef());$tb->_lines(undef());return}sub add {my$tb=shift;if (!$tb->n_cols){$tb->_entitle([('')x @_])}for my$row (_transpose([map {[defined()? split(/\n/): '' ]}@_ ])){$tb->_add(@$row)}$tb->_clear_cache;return$tb}sub _add {my$tb=shift;for my$col (@{$tb->_cols}){push @{$col},shift(@_)}$tb->_clear_cache;return$tb}sub load {my$tb=shift;for my$row (@_){if (!defined($row)){$row=''}$tb->add((ref($row)eq 'ARRAY')? (@$row): (split ' ',$row))}$tb}sub clear {my$tb=shift;for my$col (@{$tb->_cols}){$col=[]}$tb->_clear_cache;return$tb}sub n_cols {scalar @{$_[0]->{spec}}}sub title_height {$_[0]->n_cols and scalar @{$_[0]->_titles->[0]}}sub body_height {my ($tb)=@_;return ($tb->n_cols && scalar @{$tb->_cols->[0]})}sub table_height {my$tb=shift;return$tb->title_height + $tb->body_height}BEGIN {*height=\&table_height}sub width {my ($tb)=@_;return$tb->height && (length(($tb->table(0))[0])- 1)}sub _normalize_col_index {my ($tb,$col_index)=@_;$col_index ||= 0;if ($col_index < 0){$col_index += $tb->n_cols}if ($col_index < 0){$col_index=0}elsif ($col_index > $tb->n_cols){$col_index=$tb->n_cols}return$col_index}sub colrange {my ($tb,$proto_col_index)=@_;my$col_index=$tb->_normalize_col_index($proto_col_index);return (0,0)unless$tb->width;my@widths=map {length}@{$tb->_blank},'';@widths=@widths[0 .. $col_index];my$width=pop@widths;my$pos=sum(@widths)|| 0;my$seps_aref=_recover_separators($tb->_forms->[0]);my$sep_sum=0;for my$sep (@$seps_aref[0 .. $col_index]){$sep_sum += length($sep)}return ($pos+$sep_sum,$width)}sub table {my$tb=shift;return$tb->_table_portion($tb->height,0,@_)}sub title {my$tb=shift;return$tb->_table_portion($tb->title_height,0,@_)}sub body {my$tb=shift;return$tb->_table_portion($tb->body_height,$tb->title_height,@_)}sub stringify {my ($tb)=@_;return (scalar ($tb->table()))}sub _table_portion_as_aref {my$tb=shift;my$total=shift;my$offset=shift;my ($from,$n)=(0,$total);if (@_){$from=shift;$n=@_ ? shift : 1}($from,$n)=_limit_range($total,$from,$n);my$limit=$tb->title_height;$from += $offset;return [map$tb->_assemble_line($_ >= $limit,$tb->_table_line($_),0),$from .. $from + $n - 1 ]}sub _table_portion {my$tb=shift;my$lines_aref=$tb->_table_portion_as_aref(@_);return (wantarray ? @$lines_aref : join('',@$lines_aref))}sub _limit_range {my ($total,$from,$n)=@_;$from ||= 0;$from += $total if$from < 0;$n=$total unless defined$n;return (0,0)if$from + $n < 0 or $from >= $total;$from=0 if$from < 0;$n=$total - $from if$n > $total - $from;return($from,$n)}sub _table_line {my ($tb,$idx)=@_;if (!$tb->_lines){$tb->_lines([$tb->_build_table_lines ])}return$tb->_lines->[$idx]}sub _build_table_lines {my$tb=shift;my@cols=map {[map {defined($_)? $_ : ''}@$_ ]}@{$tb->_cols()};for my$col (@cols){push @$col,''}for my$col_idx (0 .. $#cols){push @{$cols[$col_idx]},@{$tb->_spec->[$col_idx]->{sample}}}for my$col_idx (0 .. $#cols){align($tb->_spec->[$col_idx]->{align},@{$cols[$col_idx]})}for my$col (@cols){splice(@{$col},1 + $tb->body_height)}for my$col_idx (0 .. $#cols){unshift @{$cols[$col_idx]},@{$tb->_titles->[$col_idx]}}for my$col_idx (0 .. $#cols){align($tb->_spec->[$col_idx]->{align_title},@{$cols[$col_idx]})}my@blank;for my$col (@cols){push@blank,pop(@$col)}$tb->_blank(\@blank);return _transpose_n($tb->height,\@cols)}sub _transpose_n {my ($n,$cols)=@_;return map {[map {shift @$_}@$cols]}1 .. $n}sub _transpose {my ($cols)=@_;my$m=max (map {scalar(@$_)}@$cols,[]);return _transpose_n($m,$cols)}sub _assemble_line {my ($tb,$in_body,$line_aref,$replace_spaces)=@_;my$format=$tb->_forms->[!!$in_body];if ($replace_spaces){$format =~ s/\s/=/g}return sprintf($format,@$line_aref)."\n"}sub _text_rule {my ($tb,$rule,$char,$alt)=@_;if (defined$alt){$rule =~ s/(.)/$1 eq ' ' ? $char : $alt/ge}else {$rule =~ s/ /$char/g if$char ne ' '}return$rule}sub _rule {my$tb=shift;return + (!$tb->width)? '' : $tb->_positive_width_rule(@_)}sub _positive_width_rule {my ($tb,$in_body,$char,$alt)=@_;my$rule=$tb->_assemble_line($in_body,$tb->_blank,((ref($char)eq "CODE")? 1 : 0),);return$tb->_render_rule($rule,$char,$alt)}sub _render_rule {my ($tb,$rule,$char,$alt)=@_;if (ref($char)eq "CODE"){return$tb->_render_rule_with_callbacks($rule,$char,$alt)}else {_default_if_empty(\$char,' ');return$tb->_text_rule($rule,$char,$alt)}}sub _get_fixed_len_string {my ($s,$len)=@_;$s=substr($s,0,$len);$s .= ' ' x ($len - length($s));return$s}sub _render_rule_with_callbacks {my ($tb,$rule,$char,$alt)=@_;my%callbacks=('char'=>{cb=>$char,idx=>0,},'alt'=>{cb=>$alt,idx=>0,},);my$calc_substitution=sub {my$s=shift;my$len=length($s);my$which=(($s =~ /\A /)? 'char' : 'alt');my$rec=$callbacks{$which};return _get_fixed_len_string(scalar ($rec->{cb}->($rec->{idx}++,$len)),$len,)};$rule =~ s/((.)\2*)/$calc_substitution->($1)/ge;return$rule}sub rule {my$tb=shift;return$tb->_rule(0,@_)}sub body_rule {my$tb=shift;return$tb->_rule(1,@_)}use Carp;{my ($warn,$fatal)=(0,0);sub warnings {my (undef,$toggle)=@_;$toggle ||= 'on';if ($toggle eq 'off'){($warn,$fatal)=(0,0)}elsif ($toggle eq 'fatal'){($warn,$fatal)=(1,1)}else {($warn,$fatal)=(1,0)}return$fatal ? 'fatal' : $warn ? 'on' : 'off'}sub _warn {my$msg=shift;return unless$warn;if ($fatal){croak($msg)}carp($msg);return}}
TEXT_TABLE

$fatpacked{"Try/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TRY_TINY';
  package Try::Tiny;BEGIN {$Try::Tiny::AUTHORITY='cpan:NUFFIN'}$Try::Tiny::VERSION='0.22';use 5.006;use strict;use warnings;use Exporter 5.57 'import';our@EXPORT=our@EXPORT_OK=qw(try catch finally);use Carp;$Carp::Internal{+__PACKAGE__}++;BEGIN {eval "use Sub::Name; 1" or *{subname}=sub {1}}sub try (&;@) {my ($try,@code_refs)=@_;my$wantarray=wantarray;my ($catch,@finally)=();for my$code_ref (@code_refs){if (ref($code_ref)eq 'Try::Tiny::Catch'){croak 'A try() may not be followed by multiple catch() blocks' if$catch;$catch=${$code_ref}}elsif (ref($code_ref)eq 'Try::Tiny::Finally'){push@finally,${$code_ref}}else {croak('try() encountered an unexpected argument (' .(defined$code_ref ? $code_ref : 'undef').') - perhaps a missing semi-colon before or')}}my$caller=caller;subname("${caller}::try {...} "=>$try);subname("${caller}::catch {...} "=>$catch)if$catch;subname("${caller}::finally {...} "=>$_)foreach@finally;my$prev_error=$@;my (@ret,$error);my$failed=not eval {$@=$prev_error;if ($wantarray){@ret=$try->()}elsif (defined$wantarray){$ret[0]=$try->()}else {$try->()};return 1};$error=$@;$@=$prev_error;my@guards=map {Try::Tiny::ScopeGuard->_new($_,$failed ? $error : ())}@finally;if ($failed){if ($catch){for ($error){return$catch->($error)}}return}else {return$wantarray ? @ret : $ret[0]}}sub catch (&;@) {my ($block,@rest)=@_;croak 'Useless bare catch()' unless wantarray;return (bless(\$block,'Try::Tiny::Catch'),@rest,)}sub finally (&;@) {my ($block,@rest)=@_;croak 'Useless bare finally()' unless wantarray;return (bless(\$block,'Try::Tiny::Finally'),@rest,)}{package Try::Tiny::ScopeGuard;use constant UNSTABLE_DOLLARAT=>($] < '5.013002')? 1 : 0;sub _new {shift;bless [@_ ]}sub DESTROY {my ($code,@args)=@{$_[0]};local $@ if UNSTABLE_DOLLARAT;eval {$code->(@args);1}or do {warn "Execution of finally() block $code resulted in an exception, which " .'*CAN NOT BE PROPAGATED* due to fundamental limitations of Perl. ' .'Your program will continue as if this event never took place. ' ."Original exception text follows:\n\n" .(defined $@ ? $@ : '$@ left undefined...')."\n" }}}__PACKAGE__ 
TRY_TINY

$fatpacked{"darwin-2level/Cwd.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_CWD';
  package Cwd;use strict;use Exporter;use vars qw(@ISA @EXPORT @EXPORT_OK $VERSION);$VERSION='3.40';my$xs_version=$VERSION;$VERSION =~ tr/_//;@ISA=qw/Exporter/;@EXPORT=qw(cwd getcwd fastcwd fastgetcwd);push@EXPORT,qw(getdcwd) if $^O eq 'MSWin32';@EXPORT_OK=qw(chdir abs_path fast_abs_path realpath fast_realpath);if ($^O eq 'os2'){local $^W=0;*cwd=defined&sys_cwd ? \&sys_cwd : \&_os2_cwd;*getcwd=\&cwd;*fastgetcwd=\&cwd;*fastcwd=\&cwd;*fast_abs_path=\&sys_abspath if defined&sys_abspath;*abs_path=\&fast_abs_path;*realpath=\&fast_abs_path;*fast_realpath=\&fast_abs_path;return 1}my$use_vms_feature;BEGIN {if ($^O eq 'VMS'){if (eval {local$SIG{__DIE__};require VMS::Feature}){$use_vms_feature=1}}}sub _vms_unix_rpt {my$unix_rpt;if ($use_vms_feature){$unix_rpt=VMS::Feature::current("filename_unix_report")}else {my$env_unix_rpt=$ENV{'DECC$FILENAME_UNIX_REPORT'}|| '';$unix_rpt=$env_unix_rpt =~ /^[ET1]/i}return$unix_rpt}sub _vms_efs {my$efs;if ($use_vms_feature){$efs=VMS::Feature::current("efs_charset")}else {my$env_efs=$ENV{'DECC$EFS_CHARSET'}|| '';$efs=$env_efs =~ /^[ET1]/i}return$efs}eval {if ($] >= 5.006){require XSLoader;XSLoader::load(__PACKAGE__,$xs_version)}else {require DynaLoader;push@ISA,'DynaLoader';__PACKAGE__->bootstrap($xs_version)}};my%METHOD_MAP=(VMS=>{cwd=>'_vms_cwd',getcwd=>'_vms_cwd',fastcwd=>'_vms_cwd',fastgetcwd=>'_vms_cwd',abs_path=>'_vms_abs_path',fast_abs_path=>'_vms_abs_path',},MSWin32=>{cwd=>'_NT_cwd',getcwd=>'_NT_cwd',fastcwd=>'_NT_cwd',fastgetcwd=>'_NT_cwd',abs_path=>'fast_abs_path',realpath=>'fast_abs_path',},dos=>{cwd=>'_dos_cwd',getcwd=>'_dos_cwd',fastgetcwd=>'_dos_cwd',fastcwd=>'_dos_cwd',abs_path=>'fast_abs_path',},qnx=>{cwd=>'_qnx_cwd',getcwd=>'_qnx_cwd',fastgetcwd=>'_qnx_cwd',fastcwd=>'_qnx_cwd',abs_path=>'_qnx_abs_path',fast_abs_path=>'_qnx_abs_path',},cygwin=>{getcwd=>'cwd',fastgetcwd=>'cwd',fastcwd=>'cwd',abs_path=>'fast_abs_path',realpath=>'fast_abs_path',},epoc=>{cwd=>'_epoc_cwd',getcwd=>'_epoc_cwd',fastgetcwd=>'_epoc_cwd',fastcwd=>'_epoc_cwd',abs_path=>'fast_abs_path',},MacOS=>{getcwd=>'cwd',fastgetcwd=>'cwd',fastcwd=>'cwd',abs_path=>'fast_abs_path',},);$METHOD_MAP{NT}=$METHOD_MAP{MSWin32};my$pwd_cmd;for my$try ('/bin/pwd','/usr/bin/pwd','/QOpenSys/bin/pwd',){if(-x $try){$pwd_cmd=$try;last}}my$found_pwd_cmd=defined($pwd_cmd);unless ($pwd_cmd){$pwd_cmd='pwd'}sub _carp {require Carp;Carp::carp(@_)}sub _croak {require Carp;Carp::croak(@_)}sub _backtick_pwd {my@localize=grep exists$ENV{$_},qw(PATH IFS CDPATH ENV BASH_ENV);local@ENV{@localize};my$cwd=`$pwd_cmd`;local $/="\n";chomp($cwd)if defined$cwd;$cwd}unless ($METHOD_MAP{$^O}{cwd}or defined&cwd){my$sep=$Config::Config{path_sep}|| ':';my$os=$^O;if (defined$ENV{PATH}and $os ne 'MSWin32'){my@candidates=split($sep,$ENV{PATH});while (!$found_pwd_cmd and @candidates){my$candidate=shift@candidates;$found_pwd_cmd=1 if -x "$candidate/pwd"}}if($os eq 'MacOS' || $found_pwd_cmd){*cwd=\&_backtick_pwd}else {*cwd=\&getcwd}}if ($^O eq 'cygwin'){local $^W=0;my$orig_cwd=\&cwd;*cwd=sub {&$orig_cwd()}}*fastgetcwd=\&cwd;sub _perl_getcwd {abs_path('.')}sub fastcwd_ {my($odev,$oino,$cdev,$cino,$tdev,$tino);my(@path,$path);local(*DIR);my($orig_cdev,$orig_cino)=stat('.');($cdev,$cino)=($orig_cdev,$orig_cino);for (;;){my$direntry;($odev,$oino)=($cdev,$cino);CORE::chdir('..')|| return undef;($cdev,$cino)=stat('.');last if$odev==$cdev && $oino==$cino;opendir(DIR,'.')|| return undef;for (;;){$direntry=readdir(DIR);last unless defined$direntry;next if$direntry eq '.';next if$direntry eq '..';($tdev,$tino)=lstat($direntry);last unless$tdev!=$odev || $tino!=$oino}closedir(DIR);return undef unless defined$direntry;unshift(@path,$direntry)}$path='/' .join('/',@path);if ($^O eq 'apollo'){$path="/".$path}$path =~ /^(.*)\z/s && CORE::chdir($1)or return undef;($cdev,$cino)=stat('.');die "Unstable directory path, current directory changed unexpectedly" if$cdev!=$orig_cdev || $cino!=$orig_cino;$path}if (not defined&fastcwd){*fastcwd=\&fastcwd_}my$chdir_init=0;sub chdir_init {if ($ENV{'PWD'}and $^O ne 'os2' and $^O ne 'dos' and $^O ne 'MSWin32'){my($dd,$di)=stat('.');my($pd,$pi)=stat($ENV{'PWD'});if (!defined$dd or!defined$pd or $di!=$pi or $dd!=$pd){$ENV{'PWD'}=cwd()}}else {my$wd=cwd();$wd=Win32::GetFullPathName($wd)if $^O eq 'MSWin32';$ENV{'PWD'}=$wd}if ($^O ne 'MSWin32' and $ENV{'PWD'}=~ m|(/[^/]+(/[^/]+/[^/]+))(.*)|s){my($pd,$pi)=stat($2);my($dd,$di)=stat($1);if (defined$pd and defined$dd and $di==$pi and $dd==$pd){$ENV{'PWD'}="$2$3"}}$chdir_init=1}sub chdir {my$newdir=@_ ? shift : '';$newdir =~ s|///*|/|g unless $^O eq 'MSWin32';chdir_init()unless$chdir_init;my$newpwd;if ($^O eq 'MSWin32'){$newpwd=Win32::GetFullPathName($newdir)}return 0 unless CORE::chdir$newdir;if ($^O eq 'VMS'){return$ENV{'PWD'}=$ENV{'DEFAULT'}}elsif ($^O eq 'MacOS'){return$ENV{'PWD'}=cwd()}elsif ($^O eq 'MSWin32'){$ENV{'PWD'}=$newpwd;return 1}if (ref$newdir eq 'GLOB'){$ENV{'PWD'}=cwd()}elsif ($newdir =~ m#^/#s){$ENV{'PWD'}=$newdir}else {my@curdir=split(m#/#,$ENV{'PWD'});@curdir=('')unless@curdir;my$component;for$component (split(m#/#,$newdir)){next if$component eq '.';pop(@curdir),next if$component eq '..';push(@curdir,$component)}$ENV{'PWD'}=join('/',@curdir)|| '/'}1}sub _perl_abs_path {my$start=@_ ? shift : '.';my($dotdots,$cwd,@pst,@cst,$dir,@tst);unless (@cst=stat($start)){_carp("stat($start): $!");return ''}unless (-d _){my ($dir,$file)=$start =~ m{^(.*)/(.+)$} or return cwd().'/' .$start;if (-l $start){my$link_target=readlink($start);die "Can't resolve link $start: $!" unless defined$link_target;require File::Spec;$link_target=$dir .'/' .$link_target unless File::Spec->file_name_is_absolute($link_target);return abs_path($link_target)}return$dir ? abs_path($dir)."/$file" : "/$file"}$cwd='';$dotdots=$start;do {$dotdots .= '/..';@pst=@cst;local*PARENT;unless (opendir(PARENT,$dotdots)){require File::Spec;return File::Spec->rel2abs($start,_backtick_pwd())}unless (@cst=stat($dotdots)){_carp("stat($dotdots): $!");closedir(PARENT);return ''}if ($pst[0]==$cst[0]&& $pst[1]==$cst[1]){$dir=undef}else {do {unless (defined ($dir=readdir(PARENT))){_carp("readdir($dotdots): $!");closedir(PARENT);return ''}$tst[0]=$pst[0]+1 unless (@tst=lstat("$dotdots/$dir"))}while ($dir eq '.' || $dir eq '..' || $tst[0]!=$pst[0]|| $tst[1]!=$pst[1])}$cwd=(defined$dir ? "$dir" : "")."/$cwd" ;closedir(PARENT)}while (defined$dir);chop($cwd)unless$cwd eq '/';$cwd}my$Curdir;sub fast_abs_path {local$ENV{PWD}=$ENV{PWD}|| '';my$cwd=getcwd();require File::Spec;my$path=@_ ? shift : ($Curdir ||= File::Spec->curdir);($path)=$path =~ /(.*)/s;($cwd)=$cwd =~ /(.*)/s;unless (-e $path){_croak("$path: No such file or directory")}unless (-d _){my ($vol,$dir,$file)=File::Spec->splitpath($path);return File::Spec->catfile($cwd,$path)unless length$dir;if (-l $path){my$link_target=readlink($path);die "Can't resolve link $path: $!" unless defined$link_target;$link_target=File::Spec->catpath($vol,$dir,$link_target)unless File::Spec->file_name_is_absolute($link_target);return fast_abs_path($link_target)}return$dir eq File::Spec->rootdir ? File::Spec->catpath($vol,$dir,$file): fast_abs_path(File::Spec->catpath($vol,$dir,'')).'/' .$file}if (!CORE::chdir($path)){_croak("Cannot chdir to $path: $!")}my$realpath=getcwd();if (!((-d $cwd)&& (CORE::chdir($cwd)))){_croak("Cannot chdir back to $cwd: $!")}$realpath}*fast_realpath=\&fast_abs_path;sub _vms_cwd {return$ENV{'DEFAULT'}}sub _vms_abs_path {return$ENV{'DEFAULT'}unless @_;my$path=shift;my$efs=_vms_efs;my$unix_rpt=_vms_unix_rpt;if (defined&VMS::Filespec::vmsrealpath){my$path_unix=0;my$path_vms=0;$path_unix=1 if ($path =~ m#(?<=\^)/#);$path_unix=1 if ($path =~ /^\.\.?$/);$path_vms=1 if ($path =~ m#[\[<\]]#);$path_vms=1 if ($path =~ /^--?$/);my$unix_mode=$path_unix;if ($efs){if ($path_vms==$path_unix){$unix_mode=$unix_rpt}else {$unix_mode=0 if$path_vms}}if ($unix_mode){return VMS::Filespec::unixrealpath($path)}my$new_path=VMS::Filespec::vmsrealpath($path);$new_path=VMS::Filespec::pathify($new_path)if -d $path;return$new_path}if (-l $path){my$link_target=readlink($path);die "Can't resolve link $path: $!" unless defined$link_target;return _vms_abs_path($link_target)}my$pathified=VMS::Filespec::pathify($path);$path=$pathified if defined$pathified;return VMS::Filespec::rmsexpand($path)}sub _os2_cwd {$ENV{'PWD'}=`cmd /c cd`;chomp$ENV{'PWD'};$ENV{'PWD'}=~ s:\\:/:g ;return$ENV{'PWD'}}sub _win32_cwd_simple {$ENV{'PWD'}=`cd`;chomp$ENV{'PWD'};$ENV{'PWD'}=~ s:\\:/:g ;return$ENV{'PWD'}}sub _win32_cwd {if (*{$DynaLoader::{boot_DynaLoader}}{CODE}){$ENV{'PWD'}=Win32::GetCwd()}else {chomp($ENV{'PWD'}=`cd`)}$ENV{'PWD'}=~ s:\\:/:g ;return$ENV{'PWD'}}*_NT_cwd=defined&Win32::GetCwd ? \&_win32_cwd : \&_win32_cwd_simple;sub _dos_cwd {if (!defined&Dos::GetCwd){$ENV{'PWD'}=`command /c cd`;chomp$ENV{'PWD'};$ENV{'PWD'}=~ s:\\:/:g }else {$ENV{'PWD'}=Dos::GetCwd()}return$ENV{'PWD'}}sub _qnx_cwd {local$ENV{PATH}='';local$ENV{CDPATH}='';local$ENV{ENV}='';$ENV{'PWD'}=`/usr/bin/fullpath -t`;chomp$ENV{'PWD'};return$ENV{'PWD'}}sub _qnx_abs_path {local$ENV{PATH}='';local$ENV{CDPATH}='';local$ENV{ENV}='';my$path=@_ ? shift : '.';local*REALPATH;defined(open(REALPATH,'-|')|| exec '/usr/bin/fullpath','-t',$path)or die "Can't open /usr/bin/fullpath: $!";my$realpath=<REALPATH>;close REALPATH;chomp$realpath;return$realpath}sub _epoc_cwd {$ENV{'PWD'}=EPOC::getcwd();return$ENV{'PWD'}}if (exists$METHOD_MAP{$^O}){my$map=$METHOD_MAP{$^O};for my$name (keys %$map){local $^W=0;no strict 'refs';*{$name}=\&{$map->{$name}}}}*abs_path=\&_perl_abs_path unless defined&abs_path;*getcwd=\&_perl_getcwd unless defined&getcwd;*realpath=\&abs_path;1;
DARWIN-2LEVEL_CWD

$fatpacked{"darwin-2level/File/Spec.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_FILE_SPEC';
  package File::Spec;use strict;use vars qw(@ISA $VERSION);$VERSION='3.40';$VERSION =~ tr/_//;my%module=(MacOS=>'Mac',MSWin32=>'Win32',os2=>'OS2',VMS=>'VMS',epoc=>'Epoc',NetWare=>'Win32',symbian=>'Win32',dos=>'OS2',cygwin=>'Cygwin');my$module=$module{$^O}|| 'Unix';require "File/Spec/$module.pm";@ISA=("File::Spec::$module");1;
DARWIN-2LEVEL_FILE_SPEC

$fatpacked{"darwin-2level/File/Spec/Cygwin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_FILE_SPEC_CYGWIN';
  package File::Spec::Cygwin;use strict;use vars qw(@ISA $VERSION);require File::Spec::Unix;$VERSION='3.40';$VERSION =~ tr/_//;@ISA=qw(File::Spec::Unix);sub canonpath {my($self,$path)=@_;return unless defined$path;$path =~ s|\\|/|g;my$node='';if ($path =~ s@^(//[^/]+)(?:/|\z)@/@s){$node=$1}return$node .$self->SUPER::canonpath($path)}sub catdir {my$self=shift;return unless @_;if ($_[0]and ($_[0]eq '/' or $_[0]eq '\\')){shift;return$self->SUPER::catdir('',@_)}$self->SUPER::catdir(@_)}sub file_name_is_absolute {my ($self,$file)=@_;return 1 if$file =~ m{^([a-z]:)?[\\/]}is;return$self->SUPER::file_name_is_absolute($file)}my$tmpdir;sub tmpdir {return$tmpdir if defined$tmpdir;$tmpdir=$_[0]->_tmpdir($ENV{TMPDIR},"/tmp",$ENV{'TMP'},$ENV{'TEMP'},'C:/temp')}sub case_tolerant {return 1 unless $^O eq 'cygwin' and defined&Cygwin::mount_flags;my$drive=shift;if (!$drive){my@flags=split(/,/,Cygwin::mount_flags('/cygwin'));my$prefix=pop(@flags);if (!$prefix || $prefix eq 'cygdrive'){$drive='/cygdrive/c'}elsif ($prefix eq '/'){$drive='/c'}else {$drive="$prefix/c"}}my$mntopts=Cygwin::mount_flags($drive);if ($mntopts and ($mntopts =~ /,managed/)){return 0}eval {require Win32API::File}or return 1;my$osFsType="\0"x256;my$osVolName="\0"x256;my$ouFsFlags=0;Win32API::File::GetVolumeInformation($drive,$osVolName,256,[],[],$ouFsFlags,$osFsType,256);if ($ouFsFlags & Win32API::File::FS_CASE_SENSITIVE()){return 0}else {return 1}}1;
DARWIN-2LEVEL_FILE_SPEC_CYGWIN

$fatpacked{"darwin-2level/File/Spec/Epoc.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_FILE_SPEC_EPOC';
  package File::Spec::Epoc;use strict;use vars qw($VERSION @ISA);$VERSION='3.40';$VERSION =~ tr/_//;require File::Spec::Unix;@ISA=qw(File::Spec::Unix);sub case_tolerant {return 1}sub canonpath {my ($self,$path)=@_;return unless defined$path;$path =~ s|/+|/|g;$path =~ s|(/\.)+/|/|g;$path =~ s|^(\./)+||s unless$path eq "./";$path =~ s|^/(\.\./)+|/|s;$path =~ s|/\Z(?!\n)|| unless$path eq "/";return$path}1;
DARWIN-2LEVEL_FILE_SPEC_EPOC

$fatpacked{"darwin-2level/File/Spec/Functions.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_FILE_SPEC_FUNCTIONS';
  package File::Spec::Functions;use File::Spec;use strict;use vars qw(@ISA @EXPORT @EXPORT_OK %EXPORT_TAGS $VERSION);$VERSION='3.40';$VERSION =~ tr/_//;require Exporter;@ISA=qw(Exporter);@EXPORT=qw(canonpath catdir catfile curdir rootdir updir no_upwards file_name_is_absolute path);@EXPORT_OK=qw(devnull tmpdir splitpath splitdir catpath abs2rel rel2abs case_tolerant);%EXPORT_TAGS=(ALL=>[@EXPORT_OK,@EXPORT ]);for my$meth (@EXPORT,@EXPORT_OK){my$sub=File::Spec->can($meth);no strict 'refs';*{$meth}=sub {&$sub('File::Spec',@_)}}1;
DARWIN-2LEVEL_FILE_SPEC_FUNCTIONS

$fatpacked{"darwin-2level/File/Spec/Mac.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_FILE_SPEC_MAC';
  package File::Spec::Mac;use strict;use vars qw(@ISA $VERSION);require File::Spec::Unix;$VERSION='3.40';$VERSION =~ tr/_//;@ISA=qw(File::Spec::Unix);my$macfiles;if ($^O eq 'MacOS'){$macfiles=eval {require Mac::Files}}sub case_tolerant {1}sub canonpath {my ($self,$path)=@_;return$path}sub catdir {my$self=shift;return '' unless @_;my@args=@_;my$first_arg;my$relative;if ($args[0]eq ''){shift@args;$relative=0;$first_arg=$self->rootdir}elsif ($args[0]=~ /^[^:]+:/){$relative=0;$first_arg=shift@args;$first_arg="$first_arg:" unless ($first_arg =~ /:\Z(?!\n)/)}else {$relative=1;if ($args[0]=~ /^::+\Z(?!\n)/){$first_arg=':'}elsif ($args[0]eq ':'){$first_arg=shift@args}else {$first_arg=shift@args;$first_arg="$first_arg:" unless ($first_arg =~ /:\Z(?!\n)/)}}my$result=$first_arg;while (@args){my$arg=shift@args;unless (($arg eq '')|| ($arg eq ':')){if ($arg =~ /^::+\Z(?!\n)/){my$updir_count=length($arg)- 1;while ((@args)&& ($args[0]=~ /^::+\Z(?!\n)/)){$arg=shift@args;$updir_count += (length($arg)- 1)}$arg=(':' x $updir_count)}else {$arg =~ s/^://s;$arg="$arg:" unless ($arg =~ /:\Z(?!\n)/)}$result .= $arg}}if (($relative)&& ($result !~ /^:/)){$result=":$result"}unless ($relative){$result =~ s/([^:]+:)(:*)(.*)\Z(?!\n)/$1$3/}return$result}sub catfile {my$self=shift;return '' unless @_;my$file=pop @_;return$file unless @_;my$dir=$self->catdir(@_);$file =~ s/^://s;return$dir.$file}sub curdir {return ":"}sub devnull {return "Dev:Null"}sub rootdir {return '' unless$macfiles;my$system=Mac::Files::FindFolder(&Mac::Files::kOnSystemDisk,&Mac::Files::kSystemFolderType);$system =~ s/:.*\Z(?!\n)/:/s;return$system}my$tmpdir;sub tmpdir {return$tmpdir if defined$tmpdir;$tmpdir=$_[0]->_tmpdir($ENV{TMPDIR})}sub updir {return "::"}sub file_name_is_absolute {my ($self,$file)=@_;if ($file =~ /:/){return (!($file =~ m/^:/s))}elsif ($file eq ''){return 1 }else {return 0}}sub path {return unless exists$ENV{Commands};return split(/,/,$ENV{Commands})}sub splitpath {my ($self,$path,$nofile)=@_;my ($volume,$directory,$file);if ($nofile){($volume,$directory)=$path =~ m|^((?:[^:]+:)?)(.*)|s}else {$path =~ m|^( (?: [^:]+: )? )
                 ( (?: .*: )? )
                 ( .* )
               |xs;$volume=$1;$directory=$2;$file=$3}$volume='' unless defined($volume);$directory=":$directory" if ($volume && $directory);if ($directory){$directory .= ':' unless (substr($directory,-1)eq ':');$directory=":$directory" unless (substr($directory,0,1)eq ':')}else {$directory=''}$file='' unless defined($file);return ($volume,$directory,$file)}sub splitdir {my ($self,$path)=@_;my@result=();my ($head,$sep,$tail,$volume,$directories);return@result if ((!defined($path))|| ($path eq ''));return (':')if ($path eq ':');($volume,$sep,$directories)=$path =~ m|^((?:[^:]+:)?)(:*)(.*)|s;if ($volume){push (@result,$volume);$sep .= ':'}while ($sep || $directories){if (length($sep)> 1){my$updir_count=length($sep)- 1;for (my$i=0;$i<$updir_count;$i++){push (@result,'::')}}$sep='';if ($directories){($head,$sep,$tail)=$directories =~ m|^((?:[^:]+)?)(:*)(.*)|s;push (@result,$head);$directories=$tail}}return@result}sub catpath {my ($self,$volume,$directory,$file)=@_;if ((!$volume)&& (!$directory)){$file =~ s/^:// if$file;return$file }my ($dir_volume,$dir_dirs)=$self->splitpath($directory,1);$volume=$dir_volume unless length$volume;my$path=$volume;$path .= ':' unless (substr($path,-1)eq ':');if ($directory){$directory=$dir_dirs if$volume;$directory =~ s/^://;$path .= $directory;$path .= ':' unless (substr($path,-1)eq ':')}if ($file){$file =~ s/^://;$path .= $file}return$path}sub _resolve_updirs {my$path=shift @_;my$proceed;do {$proceed=($path =~ s/^(.*):[^:]+::(.*?)\z/$1:$2/)}while ($proceed);return$path}sub abs2rel {my($self,$path,$base)=@_;if (!$self->file_name_is_absolute($path)){$path=$self->rel2abs($path)}if (!defined($base)|| $base eq ''){$base=$self->_cwd()}elsif (!$self->file_name_is_absolute($base)){$base=$self->rel2abs($base);$base=_resolve_updirs($base)}else {$base=_resolve_updirs($base)}my ($path_vol,$path_dirs,$path_file)=$self->splitpath($path);my ($base_vol,$base_dirs)=$self->splitpath($base);return$path unless lc($path_vol)eq lc($base_vol);my@pathchunks=$self->splitdir($path_dirs);my@basechunks=$self->splitdir($base_dirs);while (@pathchunks && @basechunks && lc($pathchunks[0])eq lc($basechunks[0])){shift@pathchunks ;shift@basechunks }$path_dirs=$self->catdir(':',@pathchunks);$base_dirs=(':' x @basechunks).':' ;return$self->catpath('',$self->catdir($base_dirs,$path_dirs),$path_file)}sub rel2abs {my ($self,$path,$base)=@_;if (!$self->file_name_is_absolute($path)){if (!defined($base)|| $base eq ''){$base=$self->_cwd()}elsif (!$self->file_name_is_absolute($base)){$base=$self->rel2abs($base)}my ($path_dirs,$path_file)=($self->splitpath($path))[1,2];my ($base_vol,$base_dirs)=$self->splitpath($base);$path_dirs=':' if ($path_dirs eq '');$base_dirs =~ s/:$//;$base_dirs=$base_dirs .$path_dirs;$path=$self->catpath($base_vol,$base_dirs,$path_file)}return$path}1;
DARWIN-2LEVEL_FILE_SPEC_MAC

$fatpacked{"darwin-2level/File/Spec/OS2.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_FILE_SPEC_OS2';
  package File::Spec::OS2;use strict;use vars qw(@ISA $VERSION);require File::Spec::Unix;$VERSION='3.40';$VERSION =~ tr/_//;@ISA=qw(File::Spec::Unix);sub devnull {return "/dev/nul"}sub case_tolerant {return 1}sub file_name_is_absolute {my ($self,$file)=@_;return scalar($file =~ m{^([a-z]:)?[\\/]}is)}sub path {my$path=$ENV{PATH};$path =~ s:\\:/:g;my@path=split(';',$path);for (@path){$_='.' if $_ eq ''}return@path}sub _cwd {return Cwd::sys_cwd()}my$tmpdir;sub tmpdir {return$tmpdir if defined$tmpdir;my@d=@ENV{qw(TMPDIR TEMP TMP)};$tmpdir=$_[0]->_tmpdir(@d,'/tmp','/')}sub catdir {my$self=shift;my@args=@_;for (@args){tr[\\][/];$_ .= "/" unless m{/$}}return$self->canonpath(join('',@args))}sub canonpath {my ($self,$path)=@_;return unless defined$path;$path =~ s/^([a-z]:)/\l$1/s;$path =~ s|\\|/|g;$path =~ s|([^/])/+|$1/|g;$path =~ s|(/\.)+/|/|g;$path =~ s|^(\./)+(?=[^/])||s;$path =~ s|/\Z(?!\n)|| unless$path =~ m#^([a-z]:)?/\Z(?!\n)#si;$path =~ s{^/\.\.$}{/};1 while$path =~ s{^/\.\.}{};return$path}sub splitpath {my ($self,$path,$nofile)=@_;my ($volume,$directory,$file)=('','','');if ($nofile){$path =~ m{^( (?:[a-zA-Z]:|(?:\\\\|//)[^\\/]+[\\/][^\\/]+)? ) 
                   (.*)
               }xs;$volume=$1;$directory=$2}else {$path =~ m{^ ( (?: [a-zA-Z]: |
                        (?:\\\\|//)[^\\/]+[\\/][^\\/]+
                    )?
                  )
                  ( (?:.*[\\\\/](?:\.\.?\Z(?!\n))?)? )
                  (.*)
               }xs;$volume=$1;$directory=$2;$file=$3}return ($volume,$directory,$file)}sub splitdir {my ($self,$directories)=@_ ;split m|[\\/]|,$directories,-1}sub catpath {my ($self,$volume,$directory,$file)=@_;$volume .= $1 if ($volume =~ m@^([\\/])[\\/][^\\/]+[\\/][^\\/]+\Z(?!\n)@s && $directory =~ m@^[^\\/]@s);$volume .= $directory ;if ($volume !~ m@^[a-zA-Z]:\Z(?!\n)@s && $volume =~ m@[^\\/]\Z(?!\n)@ && $file =~ m@[^\\/]@){$volume =~ m@([\\/])@ ;my$sep=$1 ? $1 : '/' ;$volume .= $sep }$volume .= $file ;return$volume }sub abs2rel {my($self,$path,$base)=@_;if (!$self->file_name_is_absolute($path)){$path=$self->rel2abs($path)}else {$path=$self->canonpath($path)}if (!defined($base)|| $base eq ''){$base=$self->_cwd()}elsif (!$self->file_name_is_absolute($base)){$base=$self->rel2abs($base)}else {$base=$self->canonpath($base)}my ($path_volume,$path_directories,$path_file)=$self->splitpath($path,1);my ($base_volume,$base_directories)=$self->splitpath($base,1);return$path unless$path_volume eq $base_volume;my@pathchunks=$self->splitdir($path_directories);my@basechunks=$self->splitdir($base_directories);while (@pathchunks && @basechunks && lc($pathchunks[0])eq lc($basechunks[0])){shift@pathchunks ;shift@basechunks }$path_directories=CORE::join('/',@pathchunks);$base_directories=CORE::join('/',@basechunks);$base_directories =~ s|[^\\/]+|..|g ;if ($path_directories ne '' && $base_directories ne ''){$path_directories="$base_directories/$path_directories" }else {$path_directories="$base_directories$path_directories" }return$self->canonpath($self->catpath("",$path_directories,$path_file))}sub rel2abs {my ($self,$path,$base)=@_;if (!$self->file_name_is_absolute($path)){if (!defined($base)|| $base eq ''){$base=$self->_cwd()}elsif (!$self->file_name_is_absolute($base)){$base=$self->rel2abs($base)}else {$base=$self->canonpath($base)}my ($path_directories,$path_file)=($self->splitpath($path,1))[1,2];my ($base_volume,$base_directories)=$self->splitpath($base,1);$path=$self->catpath($base_volume,$self->catdir($base_directories,$path_directories),$path_file)}return$self->canonpath($path)}1;
DARWIN-2LEVEL_FILE_SPEC_OS2

$fatpacked{"darwin-2level/File/Spec/Unix.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_FILE_SPEC_UNIX';
  package File::Spec::Unix;use strict;use vars qw($VERSION);$VERSION='3.40';$VERSION =~ tr/_//;sub canonpath {my ($self,$path)=@_;return unless defined$path;my$node='';my$double_slashes_special=$^O eq 'qnx' || $^O eq 'nto';if ($double_slashes_special && ($path =~ s{^(//[^/]+)/?\z}{}s || $path =~ s{^(//[^/]+)/}{/}s)){$node=$1}$path =~ s|/{2,}|/|g;$path =~ s{(?:/\.)+(?:/|\z)}{/}g;$path =~ s|^(?:\./)+||s unless$path eq "./";$path =~ s|^/(?:\.\./)+|/|;$path =~ s|^/\.\.$|/|;$path =~ s|/\z|| unless$path eq "/";return "$node$path"}sub catdir {my$self=shift;$self->canonpath(join('/',@_,''))}sub catfile {my$self=shift;my$file=$self->canonpath(pop @_);return$file unless @_;my$dir=$self->catdir(@_);$dir .= "/" unless substr($dir,-1)eq "/";return$dir.$file}sub curdir {'.'}sub devnull {'/dev/null'}sub rootdir {'/'}my$tmpdir;sub _tmpdir {return$tmpdir if defined$tmpdir;my$self=shift;my@dirlist=@_;{no strict 'refs';if (${"\cTAINT"}){require Scalar::Util;@dirlist=grep {!Scalar::Util::tainted($_)}@dirlist}elsif ($] < 5.007){@dirlist=grep {eval {eval('1'.substr $_,0,0)}}@dirlist}}for (@dirlist){next unless defined && -d && -w _;$tmpdir=$_;last}$tmpdir=$self->curdir unless defined$tmpdir;$tmpdir=defined$tmpdir && $self->canonpath($tmpdir);return$tmpdir}sub tmpdir {return$tmpdir if defined$tmpdir;$tmpdir=$_[0]->_tmpdir($ENV{TMPDIR},"/tmp")}sub updir {'..'}sub no_upwards {my$self=shift;return grep(!/^\.{1,2}\z/s,@_)}sub case_tolerant {0}sub file_name_is_absolute {my ($self,$file)=@_;return scalar($file =~ m:^/:s)}sub path {return ()unless exists$ENV{PATH};my@path=split(':',$ENV{PATH});for (@path){$_='.' if $_ eq ''}return@path}sub join {my$self=shift;return$self->catfile(@_)}sub splitpath {my ($self,$path,$nofile)=@_;my ($volume,$directory,$file)=('','','');if ($nofile){$directory=$path}else {$path =~ m|^ ( (?: .* / (?: \.\.?\z )? )? ) ([^/]*) |xs;$directory=$1;$file=$2}return ($volume,$directory,$file)}sub splitdir {return split m|/|,$_[1],-1}sub catpath {my ($self,$volume,$directory,$file)=@_;if ($directory ne '' && $file ne '' && substr($directory,-1)ne '/' && substr($file,0,1)ne '/'){$directory .= "/$file" }else {$directory .= $file }return$directory }sub abs2rel {my($self,$path,$base)=@_;$base=$self->_cwd()unless defined$base and length$base;($path,$base)=map$self->canonpath($_),$path,$base;my$path_directories;my$base_directories;if (grep$self->file_name_is_absolute($_),$path,$base){($path,$base)=map$self->rel2abs($_),$path,$base;my ($path_volume)=$self->splitpath($path,1);my ($base_volume)=$self->splitpath($base,1);return$path unless$path_volume eq $base_volume;$path_directories=($self->splitpath($path,1))[1];$base_directories=($self->splitpath($base,1))[1];if (!length($base_directories)and $self->file_name_is_absolute($base)){$base_directories=$self->rootdir}}else {my$wd=($self->splitpath($self->_cwd(),1))[1];$path_directories=$self->catdir($wd,$path);$base_directories=$self->catdir($wd,$base)}my@pathchunks=$self->splitdir($path_directories);my@basechunks=$self->splitdir($base_directories);if ($base_directories eq $self->rootdir){return$self->curdir if$path_directories eq $self->rootdir;shift@pathchunks;return$self->canonpath($self->catpath('',$self->catdir(@pathchunks),''))}my@common;while (@pathchunks && @basechunks && $self->_same($pathchunks[0],$basechunks[0])){push@common,shift@pathchunks ;shift@basechunks }return$self->curdir unless@pathchunks || @basechunks;my@reverse_base;while(defined(my$dir=shift@basechunks)){if($dir ne $self->updir){unshift@reverse_base,$self->updir;push@common,$dir}elsif(@common){if(@reverse_base && $reverse_base[0]eq $self->updir){shift@reverse_base;pop@common}else {unshift@reverse_base,pop@common}}}my$result_dirs=$self->catdir(@reverse_base,@pathchunks);return$self->canonpath($self->catpath('',$result_dirs,''))}sub _same {$_[1]eq $_[2]}sub rel2abs {my ($self,$path,$base)=@_;if (!$self->file_name_is_absolute($path)){if (!defined($base)|| $base eq ''){$base=$self->_cwd()}elsif (!$self->file_name_is_absolute($base)){$base=$self->rel2abs($base)}else {$base=$self->canonpath($base)}$path=$self->catdir($base,$path)}return$self->canonpath($path)}sub _cwd {require Cwd;Cwd::getcwd()}sub _collapse {my($fs,$path)=@_;my$updir=$fs->updir;my$curdir=$fs->curdir;my($vol,$dirs,$file)=$fs->splitpath($path);my@dirs=$fs->splitdir($dirs);pop@dirs if@dirs && $dirs[-1]eq '';my@collapsed;for my$dir (@dirs){if($dir eq $updir and @collapsed and length$collapsed[-1]and $collapsed[-1]ne $updir and $collapsed[-1]ne $curdir){pop@collapsed}else {push@collapsed,$dir}}return$fs->catpath($vol,$fs->catdir(@collapsed),$file)}1;
DARWIN-2LEVEL_FILE_SPEC_UNIX

$fatpacked{"darwin-2level/File/Spec/VMS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_FILE_SPEC_VMS';
  package File::Spec::VMS;use strict;use vars qw(@ISA $VERSION);require File::Spec::Unix;$VERSION='3.40';$VERSION =~ tr/_//;@ISA=qw(File::Spec::Unix);use File::Basename;use VMS::Filespec;my$use_feature;BEGIN {if (eval {local$SIG{__DIE__};require VMS::Feature}){$use_feature=1}}sub _unix_rpt {my$unix_rpt;if ($use_feature){$unix_rpt=VMS::Feature::current("filename_unix_report")}else {my$env_unix_rpt=$ENV{'DECC$FILENAME_UNIX_REPORT'}|| '';$unix_rpt=$env_unix_rpt =~ /^[ET1]/i}return$unix_rpt}sub canonpath {my($self,$path)=@_;return undef unless defined$path;my$unix_rpt=$self->_unix_rpt;if ($path =~ m|/|){my$pathify=$path =~ m|/\Z(?!\n)|;$path=$self->SUPER::canonpath($path);return$path if$unix_rpt;$path=$pathify ? vmspath($path): vmsify($path)}$path =~ s/(?<!\^)</[/;$path =~ s/(?<!\^)>/]/;$path =~ s/(?<!\^)\]\[\./\.\]\[/g;$path =~ s/(?<!\^)\[000000\.\]\[/\[/g;$path =~ s/(?<!\^)\[000000\./\[/g;$path =~ s/(?<!\^)\.\]\[000000\]/\]/g;$path =~ s/(?<!\^)\.\]\[/\./g;1 while ($path =~ s/(?<!\^)([\[\.])(-+)\.(-+)([\.\]])/$1$2$3$4/);1 while ($path =~ s/(?<!\^)([\[\.])[^\]\.]+\.-(-+)([\]\.])/$1$2$3/);$path =~ s/(?<!\^)\[\.-/[-/;$path =~ s/(?<!\^)\.[^\]\.]+\.-\./\./g;$path =~ s/(?<!\^)\[[^\]\.]+\.-\./\[/g;$path =~ s/(?<!\^)\.[^\]\.]+\.-\]/\]/g;$path =~ s/(?<!\^)\[[^\]\.]+\.-\]/\[000000\]/g;$path =~ s/(?<!\^)\[\]// unless$path eq '[]';return$unix_rpt ? unixify($path): $path}sub catdir {my$self=shift;my$dir=pop;my$unix_rpt=$self->_unix_rpt;my@dirs=grep {defined()&& length()}@_;my$rslt;if (@dirs){my$path=(@dirs==1 ? $dirs[0]: $self->catdir(@dirs));my ($spath,$sdir)=($path,$dir);$spath =~ s/\.dir\Z(?!\n)//i;$sdir =~ s/\.dir\Z(?!\n)//i;if ($unix_rpt){$spath=unixify($spath)unless$spath =~ m#/#;$sdir=unixify($sdir)unless$sdir =~ m#/#;return$self->SUPER::catdir($spath,$sdir)}$sdir=$self->eliminate_macros($sdir)unless$sdir =~ /^[\w\-]+\Z(?!\n)/s;$rslt=$self->fixpath($self->eliminate_macros($spath)."/$sdir",1);if ($spath =~ /^[\[<][^.\-]/s){$rslt =~ s/^[^\[<]+//s}}else {if (not defined$dir or not length$dir){$rslt=''}else {$rslt=$unix_rpt ? $dir : vmspath($dir)}}return$self->canonpath($rslt)}sub catfile {my$self=shift;my$tfile=pop();my$file=$self->canonpath($tfile);my@files=grep {defined()&& length()}@_;my$unix_rpt=$self->_unix_rpt;my$rslt;if (@files){my$path=(@files==1 ? $files[0]: $self->catdir(@files));my$spath=$path;$spath =~ s/\.dir\Z(?!\n)//i;if ($spath =~ /^(?<!\^)[^\)\]\/:>]+\)\Z(?!\n)/s && basename($file)eq $file){$rslt="$spath$file"}else {$rslt=$self->eliminate_macros($spath);$rslt .= (defined($rslt)&& length($rslt)? '/' : '').unixify($file);$rslt=vmsify($rslt)unless$unix_rpt}}else {my$xfile=(defined($file)&& length($file))? $file : '';$rslt=$unix_rpt ? $file : vmsify($file)}return$self->canonpath($rslt)unless$unix_rpt;return$rslt}sub curdir {my$self=shift @_;return '.' if ($self->_unix_rpt);return '[]'}sub devnull {my$self=shift @_;return '/dev/null' if ($self->_unix_rpt);return "_NLA0:"}sub rootdir {my$self=shift @_;if ($self->_unix_rpt){my$try='/';my ($dev1,$ino1)=stat('/');my ($dev2,$ino2)=stat('.');if (($dev1!=$dev2)|| ($ino1!=$ino2)){return$try}return '/sys$disk/'}return 'SYS$DISK:[000000]'}my$tmpdir;sub tmpdir {my$self=shift @_;return$tmpdir if defined$tmpdir;if ($self->_unix_rpt){$tmpdir=$self->_tmpdir('/tmp','/sys$scratch',$ENV{TMPDIR});return$tmpdir}$tmpdir=$self->_tmpdir('sys$scratch:',$ENV{TMPDIR})}sub updir {my$self=shift @_;return '..' if ($self->_unix_rpt);return '[-]'}sub case_tolerant {return 1}sub path {my (@dirs,$dir,$i);while ($dir=$ENV{'DCL$PATH;' .$i++}){push(@dirs,$dir)}return@dirs}sub file_name_is_absolute {my ($self,$file)=@_;$file=$ENV{$file}while$file =~ /^[\w\$\-]+\Z(?!\n)/s && $ENV{$file};return scalar($file =~ m!^/!s || $file =~ m![<\[][^.\-\]>]! || $file =~ /:[^<\[]/)}sub splitpath {my($self,$path,$nofile)=@_;my($dev,$dir,$file)=('','','');my$vmsify_path=vmsify($path);if ($nofile){if($vmsify_path =~ /(.*)\](.+)/){$vmsify_path=$1.'.'.$2.']'}$vmsify_path =~ /(.+:)?(.*)/s;$dir=defined $2 ? $2 : '';return ($1 || '',$dir,$file)}else {$vmsify_path =~ /(.+:)?([\[<].*[\]>])?(.*)/s;return ($1 || '',$2 || '',$3)}}sub splitdir {my($self,$dirspec)=@_;my@dirs=();return@dirs if ((!defined$dirspec)|| ('' eq $dirspec));$dirspec =~ s/(?<!\^)</[/;$dirspec =~ s/(?<!\^)>/]/;$dirspec =~ s/(?<!\^)\]\[\./\.\]\[/g;$dirspec =~ s/(?<!\^)\[000000\.\]\[/\[/g;$dirspec =~ s/(?<!\^)\[000000\./\[/g;$dirspec =~ s/(?<!\^)\.\]\[000000\]/\]/g;$dirspec =~ s/(?<!\^)\.\]\[/\./g;while ($dirspec =~ s/(^|[\[\<\.])\-(\-+)($|[\]\>\.])/$1-.$2$3/g){}$dirspec="[$dirspec]" unless$dirspec =~ /(?<!\^)[\[<]/;$dirspec =~ s/^(\[|<)\./$1/;@dirs=split /(?<!\^)\./,vmspath($dirspec);$dirs[0]=~ s/^[\[<]//s;$dirs[-1]=~ s/[\]>]\Z(?!\n)//s;@dirs}sub catpath {my($self,$dev,$dir,$file)=@_;my ($dir_volume,$dir_dir,$dir_file)=$self->splitpath($dir);$dev=$dir_volume unless length$dev;$dir=length$dir_file ? $self->catfile($dir_dir,$dir_file): $dir_dir;if ($dev =~ m|^(?<!\^)/+([^/]+)|){$dev="$1:"}else {$dev .= ':' unless$dev eq '' or $dev =~ /:\Z(?!\n)/}if (length($dev)or length($dir)){$dir="[$dir]" unless$dir =~ /(?<!\^)[\[<\/]/;$dir=vmspath($dir)}$dir='' if length($dev)&& ($dir eq '[]' || $dir eq '<>');"$dev$dir$file"}sub abs2rel {my$self=shift;return vmspath(File::Spec::Unix::abs2rel($self,@_))if grep m{/},@_;my($path,$base)=@_;$base=$self->_cwd()unless defined$base and length$base;for ($path,$base){$_=$self->canonpath($_)}my ($path_volume,$path_directories,$path_file)=$self->splitpath($path);my ($base_volume,$base_directories,$base_file)=$self->splitpath($base);return$path unless lc($path_volume)eq lc($base_volume);for ($path,$base){$_=$self->rel2abs($_)}my@pathchunks=$self->splitdir($path_directories);my$pathchunks=@pathchunks;unshift(@pathchunks,'000000')unless$pathchunks[0]eq '000000';my@basechunks=$self->splitdir($base_directories);my$basechunks=@basechunks;unshift(@basechunks,'000000')unless$basechunks[0]eq '000000';while (@pathchunks && @basechunks && lc($pathchunks[0])eq lc($basechunks[0])){shift@pathchunks ;shift@basechunks }if ((@basechunks > 0)|| ($basechunks!=$pathchunks)){$path_directories=join '.',('-' x @basechunks,@pathchunks)}else {$path_directories=join '.',@pathchunks}$path_directories='['.$path_directories.']';return$self->canonpath($self->catpath('',$path_directories,$path_file))}sub rel2abs {my$self=shift ;my ($path,$base)=@_;return undef unless defined$path;if ($path =~ m/\//){$path=(-d $path || $path =~ m/\/\z/ ? vmspath($path): vmsify($path))}$base=vmspath($base)if defined$base && $base =~ m/\//;if (!$self->file_name_is_absolute($path)){if (!defined($base)|| $base eq ''){$base=$self->_cwd}elsif (!$self->file_name_is_absolute($base)){$base=$self->rel2abs($base)}else {$base=$self->canonpath($base)}my ($path_directories,$path_file)=($self->splitpath($path))[1,2];my ($base_volume,$base_directories)=$self->splitpath($base);$path_directories='' if$path_directories eq '[]' || $path_directories eq '<>';my$sep='' ;$sep='.' if ($base_directories =~ m{[^.\]>]\Z(?!\n)} && $path_directories =~ m{^[^.\[<]}s);$base_directories="$base_directories$sep$path_directories";$base_directories =~ s{\.?[\]>][\[<]\.?}{.};$path=$self->catpath($base_volume,$base_directories,$path_file)}return$self->canonpath($path)}sub eliminate_macros {my($self,$path)=@_;return '' unless (defined$path)&& ($path ne '');$self={}unless ref$self;if ($path =~ /\s/){return join ' ',map {$self->eliminate_macros($_)}split /\s+/,$path}my$npath=unixify($path);$npath =~ s{\0$}{};my($complex)=0;my($head,$macro,$tail);while ($npath =~ m#(.*?)\$\((\S+?)\)(.*)#gs){if (defined$self->{$2}){($head,$macro,$tail)=($1,$2,$3);if (ref$self->{$macro}){if (ref$self->{$macro}eq 'ARRAY'){$macro=join ' ',@{$self->{$macro}}}else {print "Note: can't expand macro \$($macro) containing ",ref($self->{$macro}),"\n\t(using MMK-specific deferred substitutuon; MMS will break)\n";$macro="\cB$macro\cB";$complex=1}}else {($macro=unixify($self->{$macro}))=~ s#/\Z(?!\n)##}$npath="$head$macro$tail"}}if ($complex){$npath =~ s#\cB(.*?)\cB#\${$1}#gs}$npath}sub fixpath {my($self,$path,$force_path)=@_;return '' unless$path;$self=bless {},$self unless ref$self;my($fixedpath,$prefix,$name);if ($path =~ /\s/){return join ' ',map {$self->fixpath($_,$force_path)}split /\s+/,$path}if ($path =~ m#^\$\([^\)]+\)\Z(?!\n)#s || $path =~ m#[/:>\]]#){if ($force_path or $path =~ /(?:DIR\)|\])\Z(?!\n)/){$fixedpath=vmspath($self->eliminate_macros($path))}else {$fixedpath=vmsify($self->eliminate_macros($path))}}elsif ((($prefix,$name)=($path =~ m#^\$\(([^\)]+)\)(.+)#s))&& $self->{$prefix}){my($vmspre)=$self->eliminate_macros("\$($prefix)");$vmspre=($vmspre =~ m|/| or $prefix =~ /DIR\Z(?!\n)/)? vmspath($vmspre): '';$fixedpath=($vmspre ? $vmspre : $self->{$prefix}).$name;$fixedpath=vmspath($fixedpath)if$force_path}else {$fixedpath=$path;$fixedpath=vmspath($fixedpath)if$force_path}if (!defined($force_path)and $fixedpath !~ /[:>(.\]]/){$fixedpath=vmspath($fixedpath)if -d $fixedpath}$fixedpath =~ s/\.000000([\]>])/$1/;if ($path =~ /^[\[>][^.\-]/){$fixedpath =~ s/^[^\[<]+//}$fixedpath}1;
DARWIN-2LEVEL_FILE_SPEC_VMS

$fatpacked{"darwin-2level/File/Spec/Win32.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DARWIN-2LEVEL_FILE_SPEC_WIN32';
  package File::Spec::Win32;use strict;use vars qw(@ISA $VERSION);require File::Spec::Unix;$VERSION='3.40';$VERSION =~ tr/_//;@ISA=qw(File::Spec::Unix);my$DRIVE_RX='[a-zA-Z]:';my$UNC_RX='(?:\\\\\\\\|//)[^\\\\/]+[\\\\/][^\\\\/]+';my$VOL_RX="(?:$DRIVE_RX|$UNC_RX)";sub devnull {return "nul"}sub rootdir {'\\'}my$tmpdir;sub tmpdir {return$tmpdir if defined$tmpdir;$tmpdir=$_[0]->_tmpdir(map($ENV{$_},qw(TMPDIR TEMP TMP)),'SYS:/temp','C:\system\temp','C:/temp','/tmp','/')}sub case_tolerant {eval {require Win32API::File}or return 1;my$drive=shift || "C:";my$osFsType="\0"x256;my$osVolName="\0"x256;my$ouFsFlags=0;Win32API::File::GetVolumeInformation($drive,$osVolName,256,[],[],$ouFsFlags,$osFsType,256);if ($ouFsFlags & Win32API::File::FS_CASE_SENSITIVE()){return 0}else {return 1}}sub file_name_is_absolute {my ($self,$file)=@_;if ($file =~ m{^($VOL_RX)}o){my$vol=$1;return ($vol =~ m{^$UNC_RX}o ? 2 : $file =~ m{^$DRIVE_RX[\\/]}o ? 2 : 0)}return$file =~ m{^[\\/]} ? 1 : 0}sub catfile {shift;shift,return _canon_cat("/",@_)if $_[0]eq "";return _canon_cat(($_[0].'\\'),@_[1..$#_])if $_[0]=~ m{^$DRIVE_RX\z}o;return _canon_cat(@_)}sub catdir {shift;return "" unless @_;shift,return _canon_cat("/",@_)if $_[0]eq "";return _canon_cat(($_[0].'\\'),@_[1..$#_])if $_[0]=~ m{^$DRIVE_RX\z}o;return _canon_cat(@_)}sub path {my@path=split(';',$ENV{PATH});s/"//g for@path;@path=grep length,@path;unshift(@path,".");return@path}sub canonpath {return $_[1]if!defined($_[1])or $_[1]eq '';return _canon_cat($_[1])}sub splitpath {my ($self,$path,$nofile)=@_;my ($volume,$directory,$file)=('','','');if ($nofile){$path =~ m{^ ( $VOL_RX ? ) (.*) }sox;$volume=$1;$directory=$2}else {$path =~ m{^ ( $VOL_RX ? )
                  ( (?:.*[\\/](?:\.\.?\Z(?!\n))?)? )
                  (.*)
               }sox;$volume=$1;$directory=$2;$file=$3}return ($volume,$directory,$file)}sub splitdir {my ($self,$directories)=@_ ;if ($directories !~ m|[\\/]\Z(?!\n)|){return split(m|[\\/]|,$directories)}else {my(@directories)=split(m|[\\/]|,"${directories}dummy");$directories[$#directories ]='' ;return@directories }}sub catpath {my ($self,$volume,$directory,$file)=@_;my$v;$volume .= $v if ((($v)=$volume =~ m@^([\\/])[\\/][^\\/]+[\\/][^\\/]+\Z(?!\n)@s)&& $directory =~ m@^[^\\/]@s);$volume .= $directory ;if ($volume !~ m@^[a-zA-Z]:\Z(?!\n)@s && $volume =~ m@[^\\/]\Z(?!\n)@ && $file =~ m@[^\\/]@){$volume =~ m@([\\/])@ ;my$sep=$1 ? $1 : '\\' ;$volume .= $sep }$volume .= $file ;return$volume }sub _same {lc($_[1])eq lc($_[2])}sub rel2abs {my ($self,$path,$base)=@_;my$is_abs=$self->file_name_is_absolute($path);return$self->canonpath($path)if$is_abs==2;if ($is_abs){my$vol=($self->splitpath($self->_cwd()))[0];return$self->canonpath($vol .$path)}if (!defined($base)|| $base eq ''){require Cwd ;$base=Cwd::getdcwd(($self->splitpath($path))[0])if defined&Cwd::getdcwd ;$base=$self->_cwd()unless defined$base }elsif (!$self->file_name_is_absolute($base)){$base=$self->rel2abs($base)}else {$base=$self->canonpath($base)}my ($path_directories,$path_file)=($self->splitpath($path,1))[1,2];my ($base_volume,$base_directories)=$self->splitpath($base,1);$path=$self->catpath($base_volume,$self->catdir($base_directories,$path_directories),$path_file);return$self->canonpath($path)}sub _canon_cat {my ($first,@rest)=@_;my$volume=$first =~ s{ \A ([A-Za-z]:) ([\\/]?) }{}x ? ucfirst($1).($2 ? "\\" : ""): $first =~ s{ \A (?:\\\\|//) ([^\\/]+)
  				 (?: [\\/] ([^\\/]+) )?
  	       			 [\\/]? }{}xs ? "\\\\$1".(defined $2 ? "\\$2" : "")."\\" : $first =~ s{ \A [\\/] }{}x ? "\\" : "";my$path=join "\\",$first,@rest;$path =~ tr#\\/#\\\\#s;$path =~ s{(?:
  		(?:\A|\\)		# at begin or after a slash
  		\.
  		(?:\\\.)*		# and more
  		(?:\\|\z) 		# at end or followed by slash
  	       )+			# performance boost -- I do not know why
  	     }{\\}gx;$path =~ s{ (\A|\\)			# at begin or after a slash
      		\.\.\.
  		(?=\\|\z) 		# at end or followed by slash
  	     }{$1..\\..}gx;while ($path =~ s{(?:
  		(?:\A|\\)		# at begin or after a slash
  		[^\\]+			# rip this 'yy' off
  		\\\.\.
  		(?<!\A\.\.\\\.\.)	# do *not* replace ^..\..
  		(?<!\\\.\.\\\.\.)	# do *not* replace \..\..
  		(?:\\|\z) 		# at end or followed by slash
  	       )+			# performance boost -- I do not know why
  	     }{\\}sx){}$path =~ s#\A\\##;$path =~ s#\\\z##;if ($volume =~ m#\\\z#){$path =~ s{ \A			# at begin
  		    \.\.
  		    (?:\\\.\.)*		# and more
  		    (?:\\|\z) 		# at end or followed by slash
  		 }{}x;return $1 if$path eq "" and $volume =~ m#\A(\\\\.*)\\\z#s}return$path ne "" || $volume ? $volume.$path : "."}1;
DARWIN-2LEVEL_FILE_SPEC_WIN32

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
     if (my $fat = $_[0]{$_[1]}) {
       return sub {
         return 0 unless length $fat;
         $fat =~ s/^([^\n]*\n?)//;
         $_ = $1;
         return 1;
       };
     }
     return;
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE

#!/usr/bin/env perl
use strict;
use warnings;
use utf8;
use App::Project::CLI;

# For fatpack
use Text::Table;

App::Project::CLI->new()->run(@ARGV);

