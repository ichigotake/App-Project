#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"App/Project.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PROJECT';
  package App::Project;
  use 5.008001;
  use strict;
  use warnings;
  use version; our $VERSION = version->declare("v0.0.0");
  
  use Time::Piece qw(gmtime);
  
  our $DEBUG;
  
  sub debug { $DEBUG }
  
  sub new {
      my ($class, @args) = @_;
      my $self = bless {@args}, $class;
      $self->{version} // die 'Must specifies version!';
      $self->{changes_time} = scalar(gmtime());
      return $self;
  }
  
  sub version { return shift->{version}; }
  
  sub changes_time { return shift->{changes_time}; }
  
  1;
  __END__
  
  =encoding utf-8
  
  =head1 NAME
  
  App::Project - [DRAFT] Generic authoring tool(not only for perl project).
  
  =head1 SYNOPSIS
  
      project changes      - Ready to change log for release
      project untracks     - Show untracked files
      project dist         - (not yet) Make your dist tarball
      project migrate      - (not yet) Set up your project ready for this tool
      project release      - Make release tag and push
      project bump_version - Bump version for next release
      project wrapper      - (not yet) Install this command line tool in your project
  
  =head1 THIS IS DRAFT
  
  I'm going to implements this modules.
  
  And thinking about this name because L<App::Project> naming is uncool name :(
  
  =head1 DESCRIPTION
  
  App::Project is a application authoring tool. App::Project provides I<project> command as authoring tool for application project.
  
  App::Project is not only for Perl project.
  
  App::Project inspire of Minilla(as CPAN module auhtoring tool).
  
  B<THIS IS A DEVELOPMENT RELEASE. API MAY CHANGE WITHOUT NOTICE>.
  
  =head1 GETTING STARTED
  
      # First time only
      # TODO: Provide fat pack tool
      % cpanm App::Project
      # App::Project has only a few deps. It should be very quick
      # Make a new distribution
      % cd /path/to/App/
      % project migrate
      # Git commit
      % git commit -m "initial commit"
      # Hack your code!
      % $EDITOR lib/YourCode
      # Done? Test and release it!
      # Make L<git tag> and update change log for release
      % project release
      # Need more portability tool? We provide to generate L<>
      % project wrapper > bin/project
  
  
  It's that easy.
  
  =head1 NOTE
  
  =head2 Why made?
  
  I need generic authoring tool. (e.g. Android application, HTML5 application, and other)
  
  I was impressed L<Minilla>. And I decide make this project.
  
  =head2 Why Perl?
  
  Perl script is high portability, A lot of operation system is installed Perl. 
  
  Make simple script with comparative ease. I don't have plan to be complex interfaces ;)
  
  =head2 App::Project is built on small libraries.
  
  App::Project is built on only few small libraries. You can install App::Project without a huge list of dependencies to heavy modules.
  
  And dependencies are pure perl or perl core(5.12.0+) only, because to higher portability for I<wrapper> script.
  
  =head1 LICENSE
  
  Copyright (C) ichigotake.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 AUTHOR
  
  ichigotake E<lt>ichigotake.san@gmail.comE<gt>
  
  =head1 SEE ALSO
  
  =item1 L<Minilla>
  
  =cut
  
APP_PROJECT

$fatpacked{"App/Project/BumpVersion.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PROJECT_BUMPVERSION';
  package App::Project::BumpVersion;
  use 5.008001;
  use strict;
  use warnings;
  use ExtUtils::MakeMaker qw(prompt);
  use version;
  use Version::Next;
  use App::Project::Logger;
  
  sub new {
      my $class = shift;
      return bless {@_}, $class;
  }
  
  sub run {
      my ($self, $current_version, $opts) = @_;
      my $validate = $opts->{validate} || 0;
      $current_version //= '0.1';
  
      my $is_valid = version::is_lax($current_version);
      if ($validate) {
          return $is_valid ? $current_version : undef;
      }
      if (!$is_valid) {
          errorf("Sorry, version '%s' is invalid.  Stopping.\n", $current_version);
      }
      return $self->default_new_version($current_version);
  }
  
  sub default_new_version {
      my ($self, $version) = @_;
      @_ == 2 or die;
  
      if (not exists_tag($version)) {
          $version;
      } else {
          return Version::Next::next_version("$version");
      }
  }
  
  sub exists_tag {
      my ( $tag ) = @_;
  
      my $x = `git tag -l $tag`;
      chomp $x;
      return !!$x;
  }
  
  
  1;
  
APP_PROJECT_BUMPVERSION

$fatpacked{"App/Project/CLI.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PROJECT_CLI';
  package App::Project::CLI;
  use strict;
  use warnings;
  use utf8;
  use Getopt::Long;
  use Getopt::Compact::WithCmd;
  use Try::Tiny;
  use App::Project::Errors;
  use App::Project::Logger;
  use App::Project::Util;
  
  sub new {
      my $class = shift;
      return bless {@_}, $class;
  }
  
  sub run {
      my ($self, @args) = @_;
      
      local @ARGV = @args;
      my @commands;
      my $go = Getopt::Compact::WithCmd->new(
          name => 'App::Project',
          version => '0.1',
          global_struct => [],
          command_struct => {
              bump_version => {
                  options => [
                      [ [qw/v validate/], 'validate version format', '!', undef, { default => 0 } ],
                  ],
                  args => 'version',
                  desc => 'bump next version',
              },
              changes => {
                  options => [
                      [ [qw/c check/], 'Check can edit Changes', '!', undef, {default => 0} ],
                      [ [qw/d dry-run/], 'Dry run mode', '!', undef, { default => 0 } ],
                  ],
                  args => 'version',
                  desc => 'Edit and commit Changes',
              },
              release => {
                  options => [
                      [ [qw/d dry-run/], 'Dry run mode', '!', undef, { default => 0 } ],
                  ],
                  args => 'version',
                  desc => 'Make release tag and push',
              },
              untracks => {
                  options => [
                      [ [qw/z/], "\0 line termination on output", "!", undef, { default => 0 } ],
                  ],
                  desc => 'Show untracked files',
              },
          },
      );
  
      my $cmd = $go->command || 'help';
      if ($cmd eq 'help') {
          $go->show_usage;
          exit;
      }
      my $klass = sprintf("App::Project::CLI::%s", camelize($cmd));
  
      ## no critic
      if (eval sprintf("require %s; 1;", $klass)) {
          try {
              $klass->run($go);
          } catch {
              /App::Project::Error::CommandExit/ and return;
              errorf("%s\n", $_);
              exit 1;
          }
      } else {
          warnf("Could not find command '%s'\n", $cmd);
          if ($@ !~ /^Can't locate App::Project/) {
              errorf("$@\n");
          }
          exit 2;
      }
  }
  
  1;
  
APP_PROJECT_CLI

$fatpacked{"App/Project/CLI/BumpVersion.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PROJECT_CLI_BUMPVERSION';
  package App::Project::CLI::BumpVersion;
  use strict;
  use warnings;
  use utf8;
  use App::Project::BumpVersion;
  use version;
  
  sub run {
      my ($self, $command, $args, $options) = @_;
      my $version = shift(@$args) // undef;
      my $res = App::Project::BumpVersion->new()->run($version, $options);
      exit 1 unless $res;
      print $res;
  }
  
  1;
  
APP_PROJECT_CLI_BUMPVERSION

$fatpacked{"App/Project/CLI/Changes.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PROJECT_CLI_CHANGES';
  package App::Project::CLI::Changes;
  use strict;
  use warnings;
  use utf8;
  
  use App::Project;
  use App::Project::Flow::CheckChanges;
  use App::Project::Flow::RewriteChanges;
  use App::Project::Logger;
  
  sub run {
      my ($self, $go) = @_;
      my $version = shift(@{$go->args}) or die 'Must specifies version name!';
      my $project = App::Project->new(version => $version);
      App::Project::Flow::CheckChanges->new()->run($project, $go->opts);
      if ($go->opts->{check} || undef) {
          return;
      }
      App::Project::Flow::RewriteChanges->new()->run($project, $go->opts);
  
  }
  
  1;
  
APP_PROJECT_CLI_CHANGES

$fatpacked{"App/Project/CLI/Release.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PROJECT_CLI_RELEASE';
  package App::Project::CLI::Release;
  use strict;
  use warnings;
  use utf8;
  
  use App::Project;
  use App::Project::Flow::Commit;
  use App::Project::Flow::Tag;
  
  sub run {
      my ($self, $go) = @_;
      my $version = shift(@{$go->args}) or die 'Must specifies version name!';
      my $project = App::Project->new(version => $version);
      App::Project::Flow::Commit->new()->run($project, $go->opts);
      App::Project::Flow::Tag->new()->run($project, $go->opts);
  }
  
  1;
  
APP_PROJECT_CLI_RELEASE

$fatpacked{"App/Project/CLI/Untracks.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PROJECT_CLI_UNTRACKS';
  package App::Project::CLI::Untracks;
  use strict;
  use warnings;
  use utf8;
  use App::Project::Logger;
  use App::Project::CheckUntrackedFiles;
  
  sub run {
      my ($self, $command, $args, $options) = @_;
      my @untracks = App::Project::CheckUntrackedFiles->new()->run();
      if (!@untracks) {
          my $unk = join("\n", @untracks);
          errorf("Unknown local files:\n$unk\n\nUpdate .gitignore, or git add them\n");
      }
      print join("\n", @untracks);
  }
  
  1;
  
APP_PROJECT_CLI_UNTRACKS

$fatpacked{"App/Project/CheckUntrackedFiles.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PROJECT_CHECKUNTRACKEDFILES';
  package App::Project::CheckUntrackedFiles;
  use strict;
  use warnings;
  use utf8;
  
  use App::Project::Logger;
  
  sub new {
      my $class = shift;
      return bless {@_}, $class;
  }
  
  sub run {
      my ($self) = @_;
      my $unk = `git ls-files -z --others --exclude-standard`;
      return split("\0", $unk);
  }
  
  1;
  
  __END__
  
  =encoding utf-8
  
  =head1 NAME
  
  App::Project::CheckUntrackedFiles
  
  =head1 DESCRIPTION
  
  Copy from L<Minilla::Release::CheckUntrackedFiles>.
  
APP_PROJECT_CHECKUNTRACKEDFILES

$fatpacked{"App/Project/Errors.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PROJECT_ERRORS';
  package App::Project::Errors;
  use strict;
  use warnings;
  use utf8;
  
  use Carp ();
  
  package App::Project::Error::CommandExit;
  
  use overload '""' => 'message', fallback => 1;
  
  sub throw {
      my ($class, $body) = @_;
      my $self = bless { body => $body, message => Carp::longmess($class) }, $class;
      die $self;
  }
  
  sub body { shift->{body} }
  
  sub message {
      my($self) = @_;
      return $self->{message};
  }
  
  1;
  
APP_PROJECT_ERRORS

$fatpacked{"App/Project/Flow/CheckChanges.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PROJECT_FLOW_CHECKCHANGES';
  package App::Project::Flow::CheckChanges;
  use strict;
  use warnings;
  use utf8;
  use ExtUtils::MakeMaker qw(prompt);
  
  use App::Project::Util qw(edit_file slurp);
  use App::Project::Logger;
  
  sub new {
      my $class = shift;
      return bless {@_}, $class;
  }
  
  sub run {
      my ($self, $project, $opts) = @_;
      $project->version or die 'Must specifies version name!';
  
      if ($ENV{PERL_APP_PROJECT_CHECK_CHANGE_LOG}) {
          infof("Okay, you are debugging now.\n");
          return;
      }
  
      until (slurp('Changes') =~ /^\{\{\$NEXT\}\}\n+[ \t]+\S/m) {
          infof("No mention of version '%s' in changelog file 'Changes'\n", $project->version);
          if (prompt("Edit file?", 'y') =~ /y/i) {
              edit_file('Changes');
          } else {
              errorf("Giving up!\n");
          }
      }
  }
  
  1;
  
APP_PROJECT_FLOW_CHECKCHANGES

$fatpacked{"App/Project/Flow/Commit.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PROJECT_FLOW_COMMIT';
  package App::Project::Flow::Commit;
  use strict;
  use warnings;
  use utf8;
  
  use App::Project::Util qw(cmd);
  use App::Project::Logger;
  
  sub new {
      my $class = shift;
      return bless {@_}, $class;
  }
  
  sub run {
      my ($self, $project, $opts) = @_;
  
      my @modified_files = split /\0/, `git ls-files --deleted --modified -z`;
      return if @modified_files == 0;
  
      my $ver = $project->version;
  
      my $msg = "Checking in changes prior to tagging of version $ver.\n\nChangelog diff is:\n\n";
      $msg .= `git diff Changes`;
  
      if ($opts->{dry_run}) {
          infof("DRY-RUN.  Would have committed message of:\n----------------\n$msg\n-----------\n");
          return;
      }
  
      cmd('git', 'commit', '-a', '-m', $msg);
  
      $self->_push_to_origin();
  }
  
  sub _push_to_origin {
      my ($self) = @_;
  
      # git v1.7.10 is required?
      my $branch = _get_branch()
          or return;
      $branch =~ s/\n//g;
      infof("Pushing to origin\n");
      cmd('git', 'push', 'origin', $branch);
  }
  
  sub _get_branch {
      open my $fh, '<', '.git/HEAD';
      chomp( my $head = do { local $/; <$fh> });
      close $fh;
  
      my ($branch) = $head =~ m!ref: refs/heads/(\S+)!;
      return $branch;
  }
  
  1;
  
APP_PROJECT_FLOW_COMMIT

$fatpacked{"App/Project/Flow/RewriteChanges.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PROJECT_FLOW_REWRITECHANGES';
  package App::Project::Flow::RewriteChanges;
  use strict;
  use warnings;
  use utf8;
  use App::Project::Util qw(slurp_raw spew_raw);
  
  sub new {
      my $class = shift;
      return bless {@_}, $class;
  }
  
  sub run {
      my ($self, $project, $opts) = @_;
      return if $opts->{dry_run};
  
      my $content = slurp_raw('Changes');
      $content =~ s!\{\{\$NEXT\}\}!
          "{{\$NEXT}}\n\n" . $project->version. " " . $project->changes_time->strftime('%Y-%m-%dT%H:%M:%SZ')
          !e;
      spew_raw('Changes' => $content);
  }
  
  
  1;
  
APP_PROJECT_FLOW_REWRITECHANGES

$fatpacked{"App/Project/Flow/Tag.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PROJECT_FLOW_TAG';
  package App::Project::Flow::Tag;
  use strict;
  use warnings;
  use utf8;
  
  use App::Project::Util qw(cmd);
  use App::Project::Logger;
  
  sub run {
      my ($self, $project, $opts) = @_;
      my $version = $project->version;
  
      if ( $opts->{dry_run} ) {
          infof("DRY-RUN.  Would have tagged version $version.\n");
          return;
      }
  
      my $tag = $project->format_tag($version);
      cmd('git', 'tag', $tag);
      cmd('git', "push", 'origin', tag => $tag);
  }
  
  1;
  
APP_PROJECT_FLOW_TAG

$fatpacked{"App/Project/Git.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PROJECT_GIT';
  package App::Project::Git;
  use strict;
  use warnings;
  use utf8;
  
  use parent qw(Exporter);
  use App::Project::Util;
  
  our @EXPORT = qw(git_init git_add git_commit);
  
  sub git_init {
      cmd('git', 'init');
  }
  
  sub git_add {
      cmd('git', 'add', @_ ? @_ : '.');
  }
  
  sub git_commit {
      cmd('git', 'commit', @_);
  }
  
  1;
  
APP_PROJECT_GIT

$fatpacked{"App/Project/Logger.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PROJECT_LOGGER';
  package App::Project::Logger;
  use 5.008001;
  use strict;
  use warnings;
  use utf8;
  use parent qw(Exporter);
  
  use Term::ANSIColor qw(colored);
  require Win32::Console::ANSI if $^O eq 'MSWin32';
  
  use App::Project::Errors;
  
  our @EXPORT = qw(debugf infof warnf errorf);
  
  our $COLOR;
  
  use constant { DEBUG => 1, INFO => 2, WARN => 3, ERROR => 4 };
  
  our $Colors = {
      DEBUG,   => 'green',
      WARN,    => 'yellow',
      INFO,    => 'cyan',
      ERROR,   => 'red',
  };
  
  sub _printf {
      my $type = pop;
      my($temp, @args) = @_;
      _print(sprintf($temp, map { defined($_) ? $_ : '-' } @args), $type);
  }
  
  sub _print {
      my($msg, $type) = @_;
      return if $type == DEBUG && !App::Project->debug;
      $msg = colored $msg, $Colors->{$type} if defined $type && $COLOR;
      my $fh = $type && $type >= WARN ? *STDERR : *STDOUT;
      print {$fh} $msg;
  }
  
  sub infof {
      _printf(@_, INFO);
  }
  
  sub warnf {
      _printf(@_, WARN);
  }
  
  sub debugf {
      _printf(@_, DEBUG);
  }
  
  sub errorf {
      my(@msg) = @_;
      _printf(@msg, ERROR);
  
      my $fmt = shift @msg;
      App::Project::Error::CommandExit->throw(sprintf($fmt, @msg));
  }
  
  1;
  
APP_PROJECT_LOGGER

$fatpacked{"App/Project/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PROJECT_UTIL';
  package App::Project::Util;
  use strict;
  use warnings;
  use utf8;
  use parent qw(Exporter);
  
  use App::Project::Logger;
  use Cwd();
  
  our @EXPORT = qw(camelize cmd edit_file slurp slurp_raw spew_raw);
  
  sub camelize {
      my ($target) = @_;
      $target =~ s/(_|^)(.)/\u$2/g;
      return $target;
  }
  
  sub cmd {
      App::Project::Logger::infof("[%s] \$ %s\n", File::Basename::basename(Cwd::getcwd()), "@_");
      system(@_) == 0
          or App::Project::Logger::errorf("Giving up.\n");
  }
  
  sub edit_file {
      my ($file) = @_;
      my $editor = $ENV{"EDITOR"} || "vi";
      system( $editor, $file );
  }
  
  sub slurp {
      my $fname = shift;
      open my $fh, '<', $fname
          or Carp::croak("Can't open '$fname' for reading: '$!'");
      scalar do { local $/; <$fh> }
  }
  
  sub slurp_raw {
      my $fname = shift;
      open my $fh, '<:raw', $fname
          or Carp::croak("Can't open '$fname' for reading: '$!'");
      scalar do { local $/; <$fh> }
  }
  
  sub spew_raw {
      my $fname = shift;
      open my $fh, '>:raw', $fname
          or Carp::croak("Can't open '$fname' for writing: '$!'");
      print {$fh} $_[0];
  }
  
  1;
  
APP_PROJECT_UTIL

$fatpacked{"Getopt/Compact/WithCmd.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GETOPT_COMPACT_WITHCMD';
  package Getopt::Compact::WithCmd;
  
  use strict;
  use warnings;
  use 5.008_001;
  use Data::Dumper ();
  use List::Util qw(max);
  use Getopt::Long qw(GetOptionsFromArray);
  use Carp ();
  use constant DEFAULT_CONFIG => (
      no_auto_abbrev => 1,
      no_ignore_case => 1,
      bundling       => 1,
  );
  
  our $VERSION = '0.22';
  
  my $TYPE_MAP = {
      'Bool'   => '!',
      'Incr'   => '+',
      'Str'    => '=s',
      'Int'    => '=i',
      'Num'    => '=f',
      'ExNum'  => '=o',
  };
  
  my $TYPE_GEN = {};
  
  sub new {
      my ($class, %args) = @_;
      my $self = bless {
          cmd         => $args{cmd} || do { require File::Basename; File::Basename::basename($0) },
          name        => $args{name},
          version     => $args{version} || $::VERSION,
          modes       => $args{modes},
          opt         => {},
          usage       => exists $args{usage} && !$args{usage} ? 0 : 1,
          args        => $args{args} || '',
          _argv       => \@ARGV,
          struct      => [],
          summary     => {},
          requires    => {},
          ret         => 0,
          error       => undef,
          other_usage => undef,
          commands    => [],
          _struct     => $args{command_struct} || {},
      }, $class;
  
      my %config = (DEFAULT_CONFIG, %{$args{configure} || {}});
      my @gconf = grep $config{$_}, keys %config;
      Getopt::Long::Configure(@gconf) if @gconf;
  
      $self->_init_summary($args{command_struct});
  
      $self->_init_struct($args{global_struct} || []);
      my $opthash = $self->_parse_struct || return $self;
      if ($args{command_struct}) {
          if (my @gopts = $self->_parse_argv) {
              $self->{ret} = $self->_parse_option(\@gopts, $opthash);
              unshift @ARGV, @gopts;
              return $self unless $self->{ret};
              return $self if $self->_want_help;
          }
          $self->_check_requires;
      }
      else {
          $self->{ret} = $self->_parse_option(\@ARGV, $opthash);
          return $self unless $self->{ret};
          return $self if $self->_want_help;
          $self->_check_requires;
          return $self;
      }
  
      $self->_parse_command_struct($args{command_struct});
      return $self;
  }
  
  sub new_from_array {
      my ($class, $args, %options) = @_;
      unless (ref $args eq 'ARRAY') {
          Carp::croak("Usage: $class->new_from_array(\\\@args, %options)");
      }
      local *ARGV = $args;
      return $class->new(%options);
  }
  
  sub new_from_string {
      my ($class, $str, %options) = @_;
      unless (defined $str) {
          Carp::croak("Usage: $class->new_from_string(\$str, %options)");
      }
      require Text::ParseWords;
      my $args = [Text::ParseWords::shellwords($str)];
      local *ARGV = $args;
      return $class->new(%options);
  }
  
  sub args       { $_[0]->{_argv}     }
  sub error      { $_[0]->{error}||'' }
  sub command    { $_[0]->{command}   }
  sub commands   { $_[0]->{commands}  }
  sub status     { $_[0]->{ret}       }
  sub is_success { $_[0]->{ret}       }
  sub pod2usage  { Carp::carp('Not implemented') }
  
  sub opts {
      my($self) = @_;
      my $opt = $self->{opt};
      if ($self->{usage} && ($opt->{help} || $self->status == 0)) {
          # display usage message & exit
          print $self->usage;
          exit !$self->status;
      }
      return $opt;
  }
  
  sub usage {
      my($self, @targets) = @_;
      my $usage = '';
      my(@help, @commands);
  
      if ((defined $self->command && $self->command eq 'help') || @targets) {
          delete $self->{command};
          @targets = @{$self->{_argv}} unless @targets;
          for (my $i = 0; $i < @targets; $i++) {
              my $target = $targets[$i];
              last unless defined $target;
              unless (ref $self->{_struct}{$target} eq 'HASH') {
                  $self->{error} = "Unknown command: $target";
                  last;
              }
              else {
                  $self->{command} = $target;
                  push @{$self->{commands}}, $target;
                  $self->_init_struct($self->{_struct}{$target}{options});
                  $self->_extends_usage($self->{_struct}{$target});
  
                  if (ref $self->{_struct}{$target}{command_struct} eq 'HASH') {
                      $self->{_struct} = $self->{_struct}{$target}{command_struct};
                  }
                  else {
                      $self->{summary} = {};
                  }
              }
          }
      }
  
      my($name, $version, $cmd, $struct, $args, $summary, $error, $other_usage) = map
          $self->{$_} || '', qw/name version cmd struct args summary error other_usage/;
  
      $usage .= "$error\n" if $error;
  
      if ($name) {
          $usage .= $name;
          $usage .= " v$version" if $version;
          $usage .= "\n";
      }
  
      if ($self->command && $self->command ne 'help') {
          my $sub_command = join q{ }, @{$self->commands} ? @{$self->commands} : $self->command;
          $usage .= "usage: $cmd $sub_command [options]";
      }
      else {
          $usage .= "usage: $cmd [options]";
          $usage .= ' COMMAND' if keys %$summary;
      }
      $usage .= ($args ? " $args" : '') . "\n\n";
  
      for my $o (@$struct) {
          my ($name_spec, $desc, $arg_spec, $dist, $opts) = @$o;
          $desc = '' unless defined $desc;
          my @onames = $self->_option_names($name_spec);
          my $optname = join
              (', ', map { (length($_) > 1 ? '--' : '-').$_ } @onames);
          $optname = '    '.$optname unless length($onames[0]) == 1;
          my $info = do {
              local $Data::Dumper::Indent = 0;
              local $Data::Dumper::Terse  = 1;
              my $info = [];
              push @$info, $self->_opt_spec2name($arg_spec) || $arg_spec || '';
              push @$info, $opts->{required}        ? "(required)" : '';
              push @$info, defined $opts->{default} ? "(default: ".Data::Dumper::Dumper($opts->{default}).")" : '';
              $info;
          };
          push @help, [ $optname, $info, ucfirst($desc) ];
      }
  
      if (@help) {
          require Text::Table;
          my $sep = \'   ';
          $usage .= "options:\n";
          $usage .= Text::Table->new($sep, '', $sep, '', $sep, '')->load($self->_format_info(@help))->stringify."\n";
      }
  
      if (defined $other_usage && length $other_usage > 0) {
          $other_usage =~ s/\n$//ms;
          $usage .= "$other_usage\n\n";
      }
  
      if (!$self->command || $self->{has_sub_command}) {
          for my $command (sort keys %$summary) {
              push @commands, [ $command, ucfirst $summary->{$command} ];
          }
  
          if (@commands) {
              require Text::Table;
              my $sep = \'   ';
              $usage .= "Implemented commands are:\n";
              $usage .= Text::Table->new($sep, '', $sep, '')->load(@commands)->stringify."\n";
              my $help_command = "$cmd help COMMAND";
              if (@{$self->commands}) {
                  my $sub_commands = join q{ }, @{$self->commands};
                  $help_command = "$cmd $sub_commands COMMAND --help";
              }
              $usage .= "See '$help_command' for more information on a specific command.\n\n";
          }
      }
  
      return $usage;
  }
  
  sub show_usage {
      my $self = shift;
      print $self->usage(@_);
      exit !$self->status;
  }
  
  sub completion {
      my($self, $shell) = @_;
      $shell ||= 'bash';
  
      if ($shell eq 'bash') {
          return $self->_completion_bash;
      } else {
          Carp::carp("Not implemented: completion for $shell");
          return "";
      }
  }
  
  sub show_completion {
      my $self = shift;
      print $self->completion(@_);
      exit !$self->status;
  }
  
  sub _completion_bash {
      my $self = shift;
      my $comp = '';
  
      my $prog  = $self->{name} || substr($0, rindex($0, '/')+1);
      my $fname = $prog;
      $fname =~ s/[.-]/_/g;
  
      my @global_opts;
      my @commands;
      my $case = {
          word  => '"$cmd"',
          cases => [],
      };
  
      @global_opts = $self->_options2optarg($self->{struct});
  
      for my $cmd (sort keys %{ $self->{_struct} }) {
          my $s = $self->{_struct}{$cmd};
  
          my @opts = $self->_options2optarg($s->{options});
          my @commands2;
  
          if (ref $s->{command_struct} eq 'HASH') {
              for my $cmd (sort keys %{ $s->{command_struct} }) {
                  my $s = $s->{command_struct}{$cmd};
                  my @opts = $self->_options2optarg($s->{options});
  
                  push @commands2, {
                      cmd  => $cmd,
                      opts => \@opts,
                  };
              }
          }
  
          push @commands, {
              cmd    => $cmd,
              opts   => \@opts,
              subcmd => \@commands2,
              args   => ($s->{args} || ''),
          };
      }
  
      $comp .= "_$fname() {\n";
      $comp .= <<'EOC';
    COMPREPLY=()
    local cur=${COMP_WORDS[COMP_CWORD]}
    local prev=${COMP_WORDS[COMP_CWORD-1]}
    local cmd=()
    for ((i=1; i<COMP_CWORD; i++)); do
      # skip global opts and type to find cmd
      if [[ "${COMP_WORDS[$i]}" != -* && "${COMP_WORDS[$i]}" != [A-Z]* ]]; then
        cmd[${#cmd[@]}]=${COMP_WORDS[$i]}
      fi
    done
  
  EOC
  
      $comp .= sprintf qq{  local global_opts="%s"\n},
          join(" ", map { @{$_->{opt}} } @global_opts);
      $comp .= sprintf qq{  local cmds="%s"\n},
          join(" ", map { $_->{cmd} } @commands);
      $comp .= "\n";
  
      ### sub commands
      for my $command (@commands) {
  
          my $case_prev = {
              word  => '"$prev"',
              cases => [
                  _opts2casecmd(@{ $command->{opts} }),
                  {
                      pat => '*',
                      cmd => ['COMPREPLY=($(compgen -W "'._gen_wordlist($command).'" -- "$cur"))'],
                  },
              ],
          };
  
          if (scalar(@{ $command->{subcmd} }) > 0) {
              my @cases;
  
              for my $subcommand (@{ $command->{subcmd} }) {
                  next if (scalar(@{ $subcommand->{opts} }) <= 0);
                  push @cases, {
                      pat => $subcommand->{cmd},
                      cmd => [{
                          word  => '"$prev"',
                          cases => [
                              _opts2casecmd(@{ $subcommand->{opts} }),
                              {
                                  pat => '*',
                                  cmd => ['COMPREPLY=($(compgen -W "'._gen_wordlist($subcommand).'" -- "$cur"))'],
                              },
                          ],
                      }],
                  };
              }
  
              push @cases, {
                  pat => '*',
                  cmd => [ $case_prev ],
              };
  
              push @{ $case->{cases} }, {
                  pat => $command->{cmd},
                  cmd => [{
                      word  => '"${cmd[1]}"',
                      cases => [@cases],
                  }],
              };
          } else {
              push @{ $case->{cases} }, {
                  pat => $command->{cmd},
                  cmd => [ $case_prev ],
              };
          }
      }
  
      ### global opts
      push @{ $case->{cases} }, {
          pat => '*',
          cmd => [{
              word  => '"$prev"',
              cases => [
                  _opts2casecmd(@global_opts),
                  {
                      pat => '*',
                      cmd => ['COMPREPLY=($(compgen -W "$global_opts $cmds" -- "$cur"))'],
                  },
              ],
          }],
      };
  
      my @c = _generate_case_command($case);
      $comp .= join("\n", map {"  ".$_} @c)."\n";
  
      $comp .= <<"EOC";
  }
  
  complete -F _$fname $prog
  EOC
      return $comp;
  }
  
  # take following hashref and generate case command string
  # +{
  #     word  => WORD, # case WORD in
  #     cases => [
  #         {
  #             pat => PATTERN,               # PATTERN)
  #             cmd => ['cmd1', 'cmd2', ...], # COMMANDS;;
  #         },
  #         {
  #             pat => PATTERN,               # PATTERN)
  #             cmd => [                      # nested case command
  #                 {
  #                     word  => WORD,
  #                     cases => [ ... ],
  #                 },
  #             ],
  #         },
  #     ],
  # }
  sub _generate_case_command {
      my $case = shift;
      my @line;
  
      push @line, "case $case->{word} in";
      for my $c (@{ $case->{cases} }) {
          push @line, "  $c->{pat})";
          for my $cmd (@{ $c->{cmd} }, ';;') {
              if (ref $cmd eq 'HASH') {
                  push @line, map {"    ".$_} _generate_case_command->($cmd);
              } else {
                  push @line, "    ".$cmd;
              }
          }
      }
      push @line, "esac";
  
      return @line;
  }
  
  sub _options2optarg {
      my($self, $opts) = @_;
      my @optarg;
  
      for my $o (@{ $opts }) {
          my ($name_spec, $desc, $arg_spec, $dist, $opts) = @$o;
          my @onames = map { (length($_) > 1 ? '--' : '-').$_ } $self->_option_names($name_spec);
          my $arg = $self->_opt_spec2name($arg_spec) || $arg_spec || '';
          $arg = '' if $arg eq 'Incr';
          push @optarg, {
              opt => \@onames,
              arg => $arg,
          };
      }
  
      return @optarg;
  }
  
  sub _opts2casecmd {
      my @cases;
      for my $o (grep { $_->{arg} } @_) {
          push @cases, {
              pat => join("|", @{ $o->{opt} }),
              cmd => ['COMPREPLY=($(compgen -W "'.$o->{arg}.'" -- "$cur"))'],
          };
      }
  
      return @cases;
  }
  
  sub _gen_wordlist {
      my $command = shift;
  
      return join(" ",
                  '-h', '--help',
                  (map { @{$_->{opt}} } @{ $command->{opts} }),
                  ($command->{args}||''),
                  (map { $_->{cmd} } @{ $command->{subcmd} }),
              );
  }
  
  sub _opt_spec2name {
      my ($self, $spec) = @_;
      my $name = '';
      return $name unless defined $spec;
      my ($type, $dest) = $spec =~ /^[=:]?([!+isof])([@%])?/;
      if ($type) {
          $name =
              $type eq '!' ? 'Bool'  :
              $type eq '+' ? 'Incr'  :
              $type eq 's' ? 'Str'   :
              $type eq 'i' ? 'Int'   :
              $type eq 'f' ? 'Num'   :
              $type eq 'o' ? 'ExNum' : '';
      }
      if ($dest) {
          $name = $dest eq '@' ? "Array[$name]" : $dest eq '%' ? "Hash[$name]" : $name;
      }
      return $name;
  }
  
  sub _format_info {
      my ($self, @help) = @_;
  
      my $type_max     = 0;
      my $required_max = 0;
      my $default_max  = 0;
      for my $row (@help) {
          my ($type, $required, $default) = @{$row->[1]};
          $type_max     = max $type_max, length($type);
          $required_max = max $required_max, length($required);
          $default_max  = max $default_max, length($default);
      }
  
      for my $row (@help) {
          my ($type, $required, $default) = @{$row->[1]};
          my $parts = [];
          for my $stuff ([$type_max, $type], [$required_max, $required], [$default_max, $default]) {
              push @$parts, sprintf '%-*s', @$stuff if $stuff->[0] > 0;
          }
          $row->[1] = join ' ', @$parts;
      }
  
      return @help;
  }
  
  sub _parse_command_struct {
      my ($self, $command_struct) = @_;
      $command_struct ||= {};
  
      my $command_map = { map { $_ => 1 } keys %$command_struct };
      my $command = shift @ARGV;
      unless (defined $command) {
          $self->{ret} = $self->_check_requires;
          return $self;
      }
  
      unless ($command_map->{help}) {
          $command_map->{help} = 1;
          $command_struct->{help} = {
              args => '[COMMAND]',
              desc => 'show help message',
          };
      }
  
      unless (exists $command_map->{$command}) {
          $self->{error} = "Unknown command: $command";
          $self->{ret} = 0;
          return $self;
      }
  
      $self->{command} ||= $command;
  
      if ($command eq 'help') {
          $self->{ret} = 0;
          delete $self->{error};
          if (defined $ARGV[0] && exists $command_struct->{$ARGV[0]}) {
              my $nested_struct = $command_struct->{$ARGV[0]}{command_struct};
              $self->_init_nested_struct($nested_struct) if $nested_struct;
          }
          return $self;
      }
  
      push @{$self->{commands} ||= []}, $command;
      $self->_init_struct($command_struct->{$command}{options});
      $self->_extends_usage($command_struct->{$command});
      my $opthash = $self->_parse_struct || return $self;
  
      if (my $nested_struct = $command_struct->{$command}{command_struct}) {
          $self->_init_nested_struct($nested_struct);
  
          my @opts = $self->_parse_argv($nested_struct);
          $self->{ret} = $self->_parse_option(\@opts, $opthash);
          unshift @ARGV, @opts;
          $self->_check_requires;
          if ($self->_want_help) {
              delete $self->{error};
              $self->{ret} = 0;
          }
          return $self unless $self->{ret};
          $self->_parse_command_struct($nested_struct);
      }
      else {
          $self->{ret} = $self->_parse_option(\@ARGV, $opthash);
          $self->_check_requires;
          $self->{has_sub_command} = 0;
          if ($self->_want_help) {
              delete $self->{error};
              $self->{ret} = 0;
          }
      }
  
      return $self;
  }
  
  sub _want_help {
      exists $_[0]->{opt}{help} && $_[0]->{opt}{help} ? 1 : 0;
  }
  
  sub _init_nested_struct {
      my ($self, $nested_struct) = @_;
      $self->{summary} = {}; # reset
      $self->_init_summary($nested_struct);
      $self->{has_sub_command} = 1;
  }
  
  sub _parse_option {
      my ($self, $argv, $opthash) = @_;
      local $SIG{__WARN__} = sub {
          $self->{error} = join '', @_;
          chomp $self->{error};
      };
      my $ret = GetOptionsFromArray($argv, %$opthash) ? 1 : 0;
  
      $self->{parsed_opthash} = $opthash;
  
      return $ret;
  }
  
  sub _parse_argv {
      my ($self, $struct) = @_;
      $struct ||= $self->{_struct};
  
      my @opts;
      while (@ARGV) {
          my $argv = shift @ARGV;
          push @opts, $argv;
          last if exists $struct->{$argv};
      }
      return @opts;
  }
  
  sub _parse_struct {
      my ($self) = @_;
      my $struct = $self->{struct};
  
      my $opthash = {};
      my $default_opthash = {};
      my $default_args = [];
      for my $s (@$struct) {
          my($m, $descr, $spec, $ref, $opts) = @$s;
          my @onames = $self->_option_names($m);
          my($longname) = grep length($_) > 1, @onames;
          my ($type, $cb) = $self->_compile_spec($spec);
          my $o = join('|', @onames).($type||'');
          my $dest = $longname ? $longname : $onames[0];
          $opts ||= {};
          my $destination;
          if (ref $cb eq 'CODE') {
              my $t =
                  substr($type, -1, 1) eq '@' ? 'Array' :
                  substr($type, -1, 1) eq '%' ? 'Hash'  : '';
              if (ref $ref eq 'CODE') {
                  $destination = sub { $ref->($_[0], $cb->($_[1])) };
              }
              elsif (ref $ref) {
                  if (ref $ref eq 'SCALAR' || ref $ref eq 'REF') {
                      $$ref = $t eq 'Array' ? [] : $t eq 'Hash' ? {} : undef;
                  }
                  elsif (ref $ref eq 'ARRAY') {
                      @$ref = ();
                  }
                  elsif (ref $ref eq 'HASH') {
                      %$ref = ();
                  }
                  $destination = sub {
                      if ($t eq 'Array') {
                          if (ref $ref eq 'SCALAR' || ref $ref eq 'REF') {
                              push @{$$ref}, scalar $cb->($_[1]);
                          }
                          elsif (ref $ref eq 'ARRAY') {
                              push @$ref, scalar $cb->($_[1]);
                          }
                          elsif (ref $ref eq 'HASH') {
                              my @kv = split '=', $_[1], 2;
                              die qq(Option $_[0], key "$_[1]", requires a value\n)
                                  unless @kv == 2;
                              $ref->{$kv[0]} = scalar $cb->($kv[1]);
                          }
                      }
                      elsif ($t eq 'Hash') {
                          if (ref $ref eq 'SCALAR' || ref $ref eq 'REF') {
                              $$ref->{$_[1]} = scalar $cb->($_[2]);
                          }
                          elsif (ref $ref eq 'ARRAY') {
                              # XXX but Getopt::Long is $ret = join '=', $_[1], $_[2];
                              push @$ref, $_[1], scalar $cb->($_[2]);
                          }
                          elsif (ref $ref eq 'HASH') {
                              $ref->{$_[1]} = scalar $cb->($_[2]);
                          }
                      }
                      else {
                          if (ref $ref eq 'SCALAR' || ref $ref eq 'REF') {
                              $$ref = $cb->($_[1]);
                          }
                          elsif (ref $ref eq 'ARRAY') {
                              @$ref = (scalar $cb->($_[1]));
                          }
                          elsif (ref $ref eq 'HASH') {
                              my @kv = split '=', $_[1], 2;
                              die qq(Option $_[0], key "$_[1]", requires a value\n)
                                  unless @kv == 2;
                              %$ref = ($kv[0] => scalar $cb->($kv[1]));
                          }
                      }
                  };
              }
              else {
                  $destination = sub {
                      if ($t eq 'Array') {
                          $self->{opt}{$dest} ||= [];
                          push @{$self->{opt}{$dest}}, scalar $cb->($_[1]);
                      }
                      elsif ($t eq 'Hash') {
                          $self->{opt}{$dest} ||= {};
                          $self->{opt}{$dest}{$_[1]} = $cb->($_[2]);
                      }
                      else {
                          $self->{opt}{$dest} = $cb->($_[1]);
                      }
                  };
              }
          }
          else {
              $destination = ref $ref ? $ref : \$self->{opt}{$dest};
          }
          if (exists $opts->{default}) {
              my $value = $opts->{default};
              if (ref $value eq 'ARRAY') {
                  push @$default_args, map {
                      ("--$dest", $_) 
                  } grep { defined $_ } @$value;
              }
              elsif (ref $value eq 'HASH') {
                  push @$default_args, map {
                      (my $key = $_) =~ s/=/\\=/g;
                      ("--$dest" => "$key=$value->{$_}")
                  } grep {
                      defined $value->{$_}  
                  } keys %$value;
              }
              elsif (not ref $value) {
                  if (!$spec || ($TYPE_MAP->{$spec} || $spec) eq '!') {
                      push @$default_args, "--$dest" if $value;
                  }
                  else {
                      push @$default_args, "--$dest", $value if defined $value;
                  }
              }
              else {
                  $self->{error} = "Invalid default option for $dest";
                  $self->{ret} = 0;
              }
              $default_opthash->{$o} = $destination;
          }
          $opthash->{$o} = $destination;
          $self->{requires}{$dest} = $o if $opts->{required};
      }
  
      return if $self->{error};
      if (@$default_args) {
          $self->{ret} = $self->_parse_option($default_args, $default_opthash);
          unshift @ARGV, @$default_args;
          return unless $self->{ret};
      }
  
      return $opthash;
  }
  
  sub _init_struct {
      my ($self, $struct) = @_;
      $self->{struct} = ref $struct eq 'ARRAY' ? $struct : ref $struct eq 'HASH' ? $self->_normalize_struct($struct) : [];
  
      if (ref $self->{modes} eq 'ARRAY') {
          my @modeopt;
          for my $m (@{$self->{modes}}) {
              my($mc) = $m =~ /^(\w)/;
              push @modeopt, [[$mc, $m], qq($m mode)];
          }
          unshift @$struct, @modeopt;
      }
  
      unshift @{$self->{struct}}, [[qw(h help)], qq(this help message)]
          if $self->{usage} && !$self->_has_option('help');
  }
  
  sub _normalize_struct {
      my ($self, $struct) = @_;
  
      my $result = [];
      for my $option (keys %$struct) {
          my $data = $struct->{$option} || {};
          $data = ref $data eq 'HASH' ? $data : {};
          my $row = [];
          push @$row, [
              $option,
              ref $data->{alias} eq 'ARRAY' ? @{$data->{alias}} :
              defined $data->{alias}        ? $data->{alias}    :  (),
          ];
          push @$row, $data->{desc};
          push @$row, $data->{type};
          push @$row, $data->{dest};
          push @$row, $data->{opts};
          push @$result, $row;
      }
  
      return $result;
  }
  
  sub _compile_spec {
      my ($self, $spec) = @_;
      return if !defined $spec or $spec eq '';
      return $spec if $self->_opt_spec2name($spec);
      my ($type, $cb);
      if ($spec =~ /^(Array|Hash)\[(\w+)\]$/) {
          $type  = $TYPE_MAP->{$2} || Carp::croak("Can't find type constraint '$2'");
          $type .= $1 eq 'Array' ? '@' : '%';
          $cb    = $TYPE_GEN->{$2};
      }
      elsif ($type = $TYPE_MAP->{$spec}) {
          $cb = $TYPE_GEN->{$spec};
      }
      else {
          Carp::croak("Can't find type constraint '$spec'");
      }
      return $type, $cb;
  }
  
  sub add_type {
      my ($class, $name, $src_type, $cb) = @_;
      unless (defined $name && $src_type && ref $cb eq 'CODE') {
          Carp::croak("Usage: $class->add_type(\$name, \$src_type, \$cb)");
      }
      unless ($TYPE_MAP->{$src_type}) {
          Carp::croak("$src_type is not defined src type");
      }
      $TYPE_MAP->{$name} = $TYPE_MAP->{$src_type};
      $TYPE_GEN->{$name} = $cb;
  }
  
  sub _init_summary {
      my ($self, $command_struct) = @_;
      if ($command_struct) {
          for my $key (keys %$command_struct) {
              $self->{summary}{$key} = $command_struct->{$key}->{desc} || '';
          }
      }
      else {
          $self->{summary} = {};
      }
  }
  
  sub _extends_usage {
      my ($self, $command_option) = @_;
      for my $key (qw/args other_usage/) {
          $self->{$key} = $command_option->{$key} if exists $command_option->{$key};
      }
  }
  
  sub _check_requires {
      my ($self) = @_;
      for my $dest (sort keys %{$self->{requires}}) {
          unless (defined $self->{opt}{$dest}) {
              unless (defined ${$self->{parsed_opthash}{$self->{requires}{$dest}}}) {
                  $self->{ret}   = 0;
                  $self->{error} = "`--$dest` option must be specified";
                  return 0;
              }
          }
      }
      return 1;
  }
  
  sub _option_names {
      my($self, $m) = @_;
      my @sorted = sort {
          my ($la, $lb) = (length($a), length($b));
          return $la <=> $lb if $la < 2 or $lb < 2;
          return 0;
      } ref $m eq 'ARRAY' ? @$m : $m;
      return @sorted;
  }
  
  sub _has_option {
      my($self, $option) = @_;
      return 1 if grep { $_ eq $option } map { $self->_option_names($_->[0]) } @{$self->{struct}};
      return 0;
  }
  
  1;
  __END__
  
  =encoding utf-8
  
  =for stopwords
  
  =head1 NAME
  
  Getopt::Compact::WithCmd - sub-command friendly, like Getopt::Compact
  
  =head1 SYNOPSIS
  
  inside foo.pl:
  
    use Getopt::Compact::WithCmd;
    
    my $go = Getopt::Compact::WithCmd->new(
       name          => 'foo',
       version       => '0.1',
       args          => 'FILE',
       global_struct => [
          [ [qw/f force/], 'force overwrite', '!', \my $force ],
       ],
       command_struct => {
          get => {
              options     => [
                  [ [qw/d dir/], 'dest dir', '=s', undef, { default => '.' } ],
                  [ [qw/o output/], 'output file name', '=s', undef, { required => 1 }],
              ],
              desc        => 'get file from url',
              args        => 'url',
              other_usage => 'blah blah blah',
          },
          remove => {
              ...
          }
       },
    );
    
    my $opts = $go->opts;
    my $cmd  = $go->command;
    
    if ($cmd eq 'get') {
        my $url = shift @ARGV;
    }
  
  how will be like this:
  
    $ ./foo.pl -f get -o bar.html http://example.com/
  
  usage, running the command './foo.pl -x' results in the following output:
  
    $ ./foo.pl -x
    Unknown option: x
    foo v0.1
    usage: foo.pl [options] COMMAND FILE
    
    options:
       -h, --help           This help message
       -f, --force   Bool   Force overwrite
    
    Implemented commands are:
       get   Get file from url
    
    See 'foo.pl help COMMAND' for more information on a specific command.
  
  in addition, running the command './foo.pl get' results in the following output:
  
    $ ./foo.pl get
    `--output` option must be specified
    foo v0.1
    usage: foo.pl get [options] url
    
    options:
       -h, --help                                     This help message
       -d, --dir      Str            (default: '.')   Dest dir
       -o, --output   Str (required)                  Output file name
    
    blah blah blah
  
  =head1 DESCRIPTION
  
  Getopt::Compact::WithCmd is yet another Getopt::* module.
  This module is respected L<Getopt::Compact>.
  This module is you can define of git-like option.
  In addition, usage can be set at the same time.
  
  =head1 METHODS
  
  =head2 new(%args)
  
  Create an object.
  The option most Getopt::Compact compatible.
  But I<struct> is cannot use.
  
  The new I<%args> are:
  
  =over
  
  =item C<< global_struct($arrayref) >>
  
  This option is sets common options across commands.
  This option value is Getopt::Compact compatible.
  In addition, extended to other values can be set.
  
    use Getopt::Compact::WithCmd;
    my $go = Getopt::Compact::WithCmd->new(
        global_struct => [
            [ $name_spec_arrayref, $description_scalar, $argument_spec_scalar, \$destination_scalar, $opt_hashref ],
            [ ... ]
        ],
    );
  
  And you can also write in hash style.
  
    use Getopt::Compact::WithCmd;
    my $go = Getopt::Compact::WithCmd->new(
        global_struct => {
            $name_scalar => {
                alias => $name_spec_arrayref,
                desc  => $description_scalar,
                type  => $argument_spec_scalar,
                dest  => \$destination_scalar,
                opts  => $opt_hashref,
            },
            $other_name_scalar => {
                ...
            },
        },
    );
  
  I<$argument_spec_scalar> can be set value are L<< Getopt::Long >>'s option specifications.
  And you can also specify the following readable style:
  
    Bool     # eq !
    Incr     # eq +
    Str      # eq =s
    Int      # eq =i
    Num      # eq =f
    ExNum    # eq =o
  
  In addition, Array and Hash type are:
  
    Array[Str] # eq =s@
    Hash[Int]  # eq =i%
    ...
  
  I<$opt_hasref> are:
  
    {
        default  => $value, # default value
        required => $bool,
    }
  
  =item C<< command_struct($hashref) >>
  
  This option is sets sub-command and options.
  
    use Getopt::Compact::WithCmd;
    my $go = Getopt::Compact::WithCmd->new(
        command_struct => {
            $command => {
                options        => $options,
                args           => $args,
                desc           => $description,
                other_usage    => $other_usage,
                command_struct => $command_struct,
            },
        },
    );
  
  I<$options>
  
  This value is compatible to C<global_struct>.
  
  I<$args>
  
  command args.
  
  I<$description>
  
  command description.
  
  I<$other_usage>
  
  other usage message.
  be added to the end of the usage message.
  
  I<$command_struct>
  
  support nesting.
  
    use Getopt::Compact::WithCmd;
    my $go = Getopt::Compact::WithCmd->new(
        command_struct => {
            $command => {
                options        => $options,
                args           => $args,
                desc           => $description,
                other_usage    => $other_usage,
                command_struct => {
                    $sub_command => {
                        options => ...
                    },
                },
            },
        },
    );
  
    # will run cmd:
    $ ./foo.pl $command $sub_command ...
  
  =back
  
  =head2 add_type($new_type, $src_type, $code_ref);
  
  This method is additional your own type.
  You must be call before new() method.
  
    use JSON;
    use Data::Dumper;
  
    Getopt::Compact::WithCmd->add_type(JSON => Str => sub { decode_json(shift) });
    my $go = Getopt::Compact::WithCmd->new(
        global_struct => {
            from_json => {
                type => 'JSON',
            },
        },
    );
    my $data = $go->opts->{from_json};
    print Dumper $data;
  
    # will run cmd:
    $ ./add_type.pl --from_json '{"foo":"bar"}'
    $VAR1 = {
              'foo' => 'bar'
            };
  
  =head2 new_from_array(\@myopts, %args);
  
  C<< new_from_array >> can be used to parse options from an arbitrary array.
  
    $go = Getopt::Compact::WithCmd->new_from_array(\@myopts, ...);
  
  =head2 new_from_string($option_string, %args);
  
  C<< new_from_string >> can be used to parts options from an arbitrary string.
  
  This method using L<< Text::ParseWords >> on internal.
  
    $go = Getopt::Compact::WithCmd->new_from_string('--foo bar baz', ...);
  
  =head2 opts
  
  Returns a hashref of options keyed by option name.
  Return value is merged global options and command options.
  
  =head2 command
  
  Gets sub-command name.
  
    # inside foo.pl
    use Getopt::Compact::WithCmd;
    
    my $go = Getopt::Compact::WithCmd->new(
       command_struct => {
          bar => {},
       },
    );
    
    print "command: ", $go->command, "\n";
    
    # running the command
    $ ./foo.pl bar
    bar
  
  =head2 commands
  
  Get sub commands. Returned value is ARRAYREF.
  
    # inside foo.pl
    use Getopt::Compact::WithCmd;
    
    my $go = Getopt::Compact::WithCmd->new(
       command_struct => {
          bar => {
              command_struct => {
                  baz => {},
              },
          },
       },
    );
    
    print join(", ", @{$go->commands}), "\n";
    
    # running the command
    $ ./foo.pl bar baz
    bar, baz
  
  =head2 status
  
  This is a true value if the command line was processed successfully. Otherwise it returns a false result.
  
    $go->status ? "success" : "fail";
  
  =head2 is_success
  
  Alias of C<status>
  
    $go->is_success # == $go->status
  
  =head2 usage
  
  Gets usage message.
  
    my $message = $go->usage;
    my $message = $go->usage($target_command_name); # must be implemented command.
  
  =head2 show_usage
  
  Display usage message and exit.
  
    $go->show_usage;
    $go->show_usage($target_command_name);
  
  =head2 completion
  
  Gets shell completion string.
  
    my $comp = $go->completion('bash');
  
  NOTICE:
  completion() supports only one nested level of "command_struct".
  completion() supports only bash.
  
  =head2 show_completion
  
  Display completion string and exit.
  
    $go->show_completion('bash');
  
  =head2 error
  
  Return value is an error message or empty string.
  
    $go->error;
  
  =head2 args
  
  Return value is array reference to any remaining arguments.
  
    $go->args # like \@ARGV
  
  =head2 pod2usage
  
  B<Not implemented.>
  
  =head1 AUTHOR
  
  xaicron E<lt>xaicron {at} cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2010 - xaicron
  
  =head1 LICENSE
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  L<Getopt::Compact>
  
  =cut
GETOPT_COMPACT_WITHCMD

$fatpacked{"Try/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TRY_TINY';
  package Try::Tiny;
  BEGIN {
    $Try::Tiny::AUTHORITY = 'cpan:NUFFIN';
  }
  {
    $Try::Tiny::VERSION = '0.18';
  }
  use 5.006;
  # ABSTRACT: minimal try/catch with proper preservation of $@
  
  use strict;
  use warnings;
  
  use base 'Exporter';
  our @EXPORT = our @EXPORT_OK = qw(try catch finally);
  
  use Carp;
  $Carp::Internal{+__PACKAGE__}++;
  
  BEGIN { eval "use Sub::Name; 1" or *{subname} = sub {1} }
  
  # Need to prototype as @ not $$ because of the way Perl evaluates the prototype.
  # Keeping it at $$ means you only ever get 1 sub because we need to eval in a list
  # context & not a scalar one
  
  sub try (&;@) {
    my ( $try, @code_refs ) = @_;
  
    # we need to save this here, the eval block will be in scalar context due
    # to $failed
    my $wantarray = wantarray;
  
    # work around perl bug by explicitly initializing these, due to the likelyhood
    # this will be used in global destruction (perl rt#119311)
    my ( $catch, @finally ) = ();
  
    # find labeled blocks in the argument list.
    # catch and finally tag the blocks by blessing a scalar reference to them.
    foreach my $code_ref (@code_refs) {
  
      if ( ref($code_ref) eq 'Try::Tiny::Catch' ) {
        croak 'A try() may not be followed by multiple catch() blocks'
          if $catch;
        $catch = ${$code_ref};
      } elsif ( ref($code_ref) eq 'Try::Tiny::Finally' ) {
        push @finally, ${$code_ref};
      } else {
        croak(
          'try() encountered an unexpected argument ('
        . ( defined $code_ref ? $code_ref : 'undef' )
        . ') - perhaps a missing semi-colon before or'
        );
      }
    }
  
    # FIXME consider using local $SIG{__DIE__} to accumulate all errors. It's
    # not perfect, but we could provide a list of additional errors for
    # $catch->();
  
    # name the blocks if we have Sub::Name installed
    my $caller = caller;
    subname("${caller}::try {...} " => $try);
    subname("${caller}::catch {...} " => $catch) if $catch;
    subname("${caller}::finally {...} " => $_) foreach @finally;
  
    # save the value of $@ so we can set $@ back to it in the beginning of the eval
    # and restore $@ after the eval finishes
    my $prev_error = $@;
  
    my ( @ret, $error );
  
    # failed will be true if the eval dies, because 1 will not be returned
    # from the eval body
    my $failed = not eval {
      $@ = $prev_error;
  
      # evaluate the try block in the correct context
      if ( $wantarray ) {
        @ret = $try->();
      } elsif ( defined $wantarray ) {
        $ret[0] = $try->();
      } else {
        $try->();
      };
  
      return 1; # properly set $fail to false
    };
  
    # preserve the current error and reset the original value of $@
    $error = $@;
    $@ = $prev_error;
  
    # set up a scope guard to invoke the finally block at the end
    my @guards =
      map { Try::Tiny::ScopeGuard->_new($_, $failed ? $error : ()) }
      @finally;
  
    # at this point $failed contains a true value if the eval died, even if some
    # destructor overwrote $@ as the eval was unwinding.
    if ( $failed ) {
      # if we got an error, invoke the catch block.
      if ( $catch ) {
        # This works like given($error), but is backwards compatible and
        # sets $_ in the dynamic scope for the body of C<$catch>
        for ($error) {
          return $catch->($error);
        }
  
        # in case when() was used without an explicit return, the C<for>
        # loop will be aborted and there's no useful return value
      }
  
      return;
    } else {
      # no failure, $@ is back to what it was, everything is fine
      return $wantarray ? @ret : $ret[0];
    }
  }
  
  sub catch (&;@) {
    my ( $block, @rest ) = @_;
  
    croak 'Useless bare catch()' unless wantarray;
  
    return (
      bless(\$block, 'Try::Tiny::Catch'),
      @rest,
    );
  }
  
  sub finally (&;@) {
    my ( $block, @rest ) = @_;
  
    croak 'Useless bare finally()' unless wantarray;
  
    return (
      bless(\$block, 'Try::Tiny::Finally'),
      @rest,
    );
  }
  
  {
    package # hide from PAUSE
      Try::Tiny::ScopeGuard;
  
    use constant UNSTABLE_DOLLARAT => ($] < '5.013002') ? 1 : 0;
  
    sub _new {
      shift;
      bless [ @_ ];
    }
  
    sub DESTROY {
      my ($code, @args) = @{ $_[0] };
  
      local $@ if UNSTABLE_DOLLARAT;
      eval {
        $code->(@args);
        1;
      } or do {
        warn
          "Execution of finally() block $code resulted in an exception, which "
        . '*CAN NOT BE PROPAGATED* due to fundamental limitations of Perl. '
        . 'Your program will continue as if this event never took place. '
        . "Original exception text follows:\n\n"
        . (defined $@ ? $@ : '$@ left undefined...')
        . "\n"
        ;
      }
    }
  }
  
  __PACKAGE__
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Try::Tiny - minimal try/catch with proper preservation of $@
  
  =head1 VERSION
  
  version 0.18
  
  =head1 SYNOPSIS
  
  You can use Try::Tiny's C<try> and C<catch> to expect and handle exceptional
  conditions, avoiding quirks in Perl and common mistakes:
  
    # handle errors with a catch handler
    try {
      die "foo";
    } catch {
      warn "caught error: $_"; # not $@
    };
  
  You can also use it like a standalone C<eval> to catch and ignore any error
  conditions.  Obviously, this is an extreme measure not to be undertaken
  lightly:
  
    # just silence errors
    try {
      die "foo";
    };
  
  =head1 DESCRIPTION
  
  This module provides bare bones C<try>/C<catch>/C<finally> statements that are designed to
  minimize common mistakes with eval blocks, and NOTHING else.
  
  This is unlike L<TryCatch> which provides a nice syntax and avoids adding
  another call stack layer, and supports calling C<return> from the C<try> block to
  return from the parent subroutine. These extra features come at a cost of a few
  dependencies, namely L<Devel::Declare> and L<Scope::Upper> which are
  occasionally problematic, and the additional catch filtering uses L<Moose>
  type constraints which may not be desirable either.
  
  The main focus of this module is to provide simple and reliable error handling
  for those having a hard time installing L<TryCatch>, but who still want to
  write correct C<eval> blocks without 5 lines of boilerplate each time.
  
  It's designed to work as correctly as possible in light of the various
  pathological edge cases (see L</BACKGROUND>) and to be compatible with any style
  of error values (simple strings, references, objects, overloaded objects, etc).
  
  If the C<try> block dies, it returns the value of the last statement executed in
  the C<catch> block, if there is one. Otherwise, it returns C<undef> in scalar
  context or the empty list in list context. The following examples all
  assign C<"bar"> to C<$x>:
  
    my $x = try { die "foo" } catch { "bar" };
    my $x = try { die "foo" } || { "bar" };
    my $x = (try { die "foo" }) // { "bar" };
  
    my $x = eval { die "foo" } || "bar";
  
  You can add C<finally> blocks, yielding the following:
  
    my $x;
    try { die 'foo' } finally { $x = 'bar' };
    try { die 'foo' } catch { warn "Got a die: $_" } finally { $x = 'bar' };
  
  C<finally> blocks are always executed making them suitable for cleanup code
  which cannot be handled using local.  You can add as many C<finally> blocks to a
  given C<try> block as you like.
  
  =head1 EXPORTS
  
  All functions are exported by default using L<Exporter>.
  
  If you need to rename the C<try>, C<catch> or C<finally> keyword consider using
  L<Sub::Import> to get L<Sub::Exporter>'s flexibility.
  
  =over 4
  
  =item try (&;@)
  
  Takes one mandatory C<try> subroutine, an optional C<catch> subroutine and C<finally>
  subroutine.
  
  The mandatory subroutine is evaluated in the context of an C<eval> block.
  
  If no error occurred the value from the first block is returned, preserving
  list/scalar context.
  
  If there was an error and the second subroutine was given it will be invoked
  with the error in C<$_> (localized) and as that block's first and only
  argument.
  
  C<$@> does B<not> contain the error. Inside the C<catch> block it has the same
  value it had before the C<try> block was executed.
  
  Note that the error may be false, but if that happens the C<catch> block will
  still be invoked.
  
  Once all execution is finished then the C<finally> block, if given, will execute.
  
  =item catch (&;@)
  
  Intended to be used in the second argument position of C<try>.
  
  Returns a reference to the subroutine it was given but blessed as
  C<Try::Tiny::Catch> which allows try to decode correctly what to do
  with this code reference.
  
    catch { ... }
  
  Inside the C<catch> block the caught error is stored in C<$_>, while previous
  value of C<$@> is still available for use.  This value may or may not be
  meaningful depending on what happened before the C<try>, but it might be a good
  idea to preserve it in an error stack.
  
  For code that captures C<$@> when throwing new errors (i.e.
  L<Class::Throwable>), you'll need to do:
  
    local $@ = $_;
  
  =item finally (&;@)
  
    try     { ... }
    catch   { ... }
    finally { ... };
  
  Or
  
    try     { ... }
    finally { ... };
  
  Or even
  
    try     { ... }
    finally { ... }
    catch   { ... };
  
  Intended to be the second or third element of C<try>. C<finally> blocks are always
  executed in the event of a successful C<try> or if C<catch> is run. This allows
  you to locate cleanup code which cannot be done via C<local()> e.g. closing a file
  handle.
  
  When invoked, the C<finally> block is passed the error that was caught.  If no
  error was caught, it is passed nothing.  (Note that the C<finally> block does not
  localize C<$_> with the error, since unlike in a C<catch> block, there is no way
  to know if C<$_ == undef> implies that there were no errors.) In other words,
  the following code does just what you would expect:
  
    try {
      die_sometimes();
    } catch {
      # ...code run in case of error
    } finally {
      if (@_) {
        print "The try block died with: @_\n";
      } else {
        print "The try block ran without error.\n";
      }
    };
  
  B<You must always do your own error handling in the C<finally> block>. C<Try::Tiny> will
  not do anything about handling possible errors coming from code located in these
  blocks.
  
  Furthermore B<exceptions in C<finally> blocks are not trappable and are unable
  to influence the execution of your program>. This is due to limitation of
  C<DESTROY>-based scope guards, which C<finally> is implemented on top of. This
  may change in a future version of Try::Tiny.
  
  In the same way C<catch()> blesses the code reference this subroutine does the same
  except it bless them as C<Try::Tiny::Finally>.
  
  =back
  
  =head1 BACKGROUND
  
  There are a number of issues with C<eval>.
  
  =head2 Clobbering $@
  
  When you run an C<eval> block and it succeeds, C<$@> will be cleared, potentially
  clobbering an error that is currently being caught.
  
  This causes action at a distance, clearing previous errors your caller may have
  not yet handled.
  
  C<$@> must be properly localized before invoking C<eval> in order to avoid this
  issue.
  
  More specifically, C<$@> is clobbered at the beginning of the C<eval>, which
  also makes it impossible to capture the previous error before you die (for
  instance when making exception objects with error stacks).
  
  For this reason C<try> will actually set C<$@> to its previous value (the one
  available before entering the C<try> block) in the beginning of the C<eval>
  block.
  
  =head2 Localizing $@ silently masks errors
  
  Inside an C<eval> block, C<die> behaves sort of like:
  
    sub die {
      $@ = $_[0];
      return_undef_from_eval();
    }
  
  This means that if you were polite and localized C<$@> you can't die in that
  scope, or your error will be discarded (printing "Something's wrong" instead).
  
  The workaround is very ugly:
  
    my $error = do {
      local $@;
      eval { ... };
      $@;
    };
  
    ...
    die $error;
  
  =head2 $@ might not be a true value
  
  This code is wrong:
  
    if ( $@ ) {
      ...
    }
  
  because due to the previous caveats it may have been unset.
  
  C<$@> could also be an overloaded error object that evaluates to false, but
  that's asking for trouble anyway.
  
  The classic failure mode is:
  
    sub Object::DESTROY {
      eval { ... }
    }
  
    eval {
      my $obj = Object->new;
  
      die "foo";
    };
  
    if ( $@ ) {
  
    }
  
  In this case since C<Object::DESTROY> is not localizing C<$@> but still uses
  C<eval>, it will set C<$@> to C<"">.
  
  The destructor is called when the stack is unwound, after C<die> sets C<$@> to
  C<"foo at Foo.pm line 42\n">, so by the time C<if ( $@ )> is evaluated it has
  been cleared by C<eval> in the destructor.
  
  The workaround for this is even uglier than the previous ones. Even though we
  can't save the value of C<$@> from code that doesn't localize, we can at least
  be sure the C<eval> was aborted due to an error:
  
    my $failed = not eval {
      ...
  
      return 1;
    };
  
  This is because an C<eval> that caught a C<die> will always return a false
  value.
  
  =head1 SHINY SYNTAX
  
  Using Perl 5.10 you can use L<perlsyn/"Switch statements">.
  
  The C<catch> block is invoked in a topicalizer context (like a C<given> block),
  but note that you can't return a useful value from C<catch> using the C<when>
  blocks without an explicit C<return>.
  
  This is somewhat similar to Perl 6's C<CATCH> blocks. You can use it to
  concisely match errors:
  
    try {
      require Foo;
    } catch {
      when (/^Can't locate .*?\.pm in \@INC/) { } # ignore
      default { die $_ }
    };
  
  =head1 CAVEATS
  
  =over 4
  
  =item *
  
  C<@_> is not available within the C<try> block, so you need to copy your
  arglist. In case you want to work with argument values directly via C<@_>
  aliasing (i.e. allow C<$_[1] = "foo">), you need to pass C<@_> by reference:
  
    sub foo {
      my ( $self, @args ) = @_;
      try { $self->bar(@args) }
    }
  
  or
  
    sub bar_in_place {
      my $self = shift;
      my $args = \@_;
      try { $_ = $self->bar($_) for @$args }
    }
  
  =item *
  
  C<return> returns from the C<try> block, not from the parent sub (note that
  this is also how C<eval> works, but not how L<TryCatch> works):
  
    sub parent_sub {
      try {
        die;
      }
      catch {
        return;
      };
  
      say "this text WILL be displayed, even though an exception is thrown";
    }
  
  Instead, you should capture the return value:
  
    sub parent_sub {
      my $success = try {
        die;
        1;
      };
      return unless $success;
  
      say "This text WILL NEVER appear!";
    }
  
  Note that if you have a C<catch> block, it must return C<undef> for this to work,
  since if a C<catch> block exists, its return value is returned in place of C<undef>
  when an exception is thrown.
  
  =item *
  
  C<try> introduces another caller stack frame. L<Sub::Uplevel> is not used. L<Carp>
  will not report this when using full stack traces, though, because
  C<%Carp::Internal> is used. This lack of magic is considered a feature.
  
  =item *
  
  The value of C<$_> in the C<catch> block is not guaranteed to be the value of
  the exception thrown (C<$@>) in the C<try> block.  There is no safe way to
  ensure this, since C<eval> may be used unhygenically in destructors.  The only
  guarantee is that the C<catch> will be called if an exception is thrown.
  
  =item *
  
  The return value of the C<catch> block is not ignored, so if testing the result
  of the expression for truth on success, be sure to return a false value from
  the C<catch> block:
  
    my $obj = try {
      MightFail->new;
    } catch {
      ...
  
      return; # avoid returning a true value;
    };
  
    return unless $obj;
  
  =item *
  
  C<$SIG{__DIE__}> is still in effect.
  
  Though it can be argued that C<$SIG{__DIE__}> should be disabled inside of
  C<eval> blocks, since it isn't people have grown to rely on it. Therefore in
  the interests of compatibility, C<try> does not disable C<$SIG{__DIE__}> for
  the scope of the error throwing code.
  
  =item *
  
  Lexical C<$_> may override the one set by C<catch>.
  
  For example Perl 5.10's C<given> form uses a lexical C<$_>, creating some
  confusing behavior:
  
    given ($foo) {
      when (...) {
        try {
          ...
        } catch {
          warn $_; # will print $foo, not the error
          warn $_[0]; # instead, get the error like this
        }
      }
    }
  
  Note that this behavior was changed once again in L<Perl5 version 18
  |https://metacpan.org/module/perldelta#given-now-aliases-the-global-_>.
  However, since the entirety of lexical C<$_> is now L<considired experimental
  |https://metacpan.org/module/perldelta#Lexical-_-is-now-experimental>, it
  is unclear whether the new version 18 behavior is final.
  
  =back
  
  =head1 SEE ALSO
  
  =over 4
  
  =item L<TryCatch>
  
  Much more feature complete, more convenient semantics, but at the cost of
  implementation complexity.
  
  =item L<autodie>
  
  Automatic error throwing for builtin functions and more. Also designed to
  work well with C<given>/C<when>.
  
  =item L<Throwable>
  
  A lightweight role for rolling your own exception classes.
  
  =item L<Error>
  
  Exception object implementation with a C<try> statement. Does not localize
  C<$@>.
  
  =item L<Exception::Class::TryCatch>
  
  Provides a C<catch> statement, but properly calling C<eval> is your
  responsibility.
  
  The C<try> keyword pushes C<$@> onto an error stack, avoiding some of the
  issues with C<$@>, but you still need to localize to prevent clobbering.
  
  =back
  
  =head1 LIGHTNING TALK
  
  I gave a lightning talk about this module, you can see the slides (Firefox
  only):
  
  L<http://web.archive.org/web/20100628040134/http://nothingmuch.woobling.org/talks/takahashi.xul>
  
  Or read the source:
  
  L<http://web.archive.org/web/20100305133605/http://nothingmuch.woobling.org/talks/yapc_asia_2009/try_tiny.yml>
  
  =head1 VERSION CONTROL
  
  L<http://github.com/doy/try-tiny/>
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Yuval Kogman <nothingmuch@woobling.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2013 by Yuval Kogman.
  
  This is free software, licensed under:
  
    The MIT (X11) License
  
  =cut
TRY_TINY

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
     if (my $fat = $_[0]{$_[1]}) {
       return sub {
         return 0 unless length $fat;
         $fat =~ s/^([^\n]*\n?)//;
         $_ = $1;
         return 1;
       };
     }
     return;
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE

#!/usr/bin/env perl
use strict;
use warnings;
use App::Project::CLI;

App::Project::CLI->new()->run(@ARGV);

