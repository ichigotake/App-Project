#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"App/Project.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PROJECT';
  package App::Project;
  use 5.008001;
  use strict;
  use warnings;
  use version; our $VERSION = version->declare("v0.0.0");
  
  use Time::Piece qw(gmtime);
  
  our $DEBUG;
  
  sub debug { $DEBUG }
  
  sub new {
      my ($class, @args) = @_;
      my $self = bless {@args}, $class;
      $self->{version} // die 'Must specifies version!';
      $self->{changes_time} = scalar(gmtime());
      return $self;
  }
  
  sub version { return shift->{version}; }
  
  sub changes_time { return shift->{changes_time}; }
  
  1;
  __END__
  
  =encoding utf-8
  
  =head1 NAME
  
  App::Project - [DRAFT] Generic authoring tool(not only for perl project).
  
  =head1 SYNOPSIS
  
      project changes      - Ready to change log for release
      project untracks     - Show untracked files
      project dist         - (not yet) Make your dist tarball
      project migrate      - (not yet) Set up your project ready for this tool
      project release      - Make release tag and push
      project bump_version - Bump version for next release
      project wrapper      - (not yet) Install this command line tool in your project
  
  =head1 THIS IS DRAFT
  
  I'm going to implements this modules.
  
  And thinking about this name because L<App::Project> naming is uncool name :(
  
  =head1 DESCRIPTION
  
  App::Project is a application authoring tool. App::Project provides I<project> command as authoring tool for application project.
  
  App::Project is not only for Perl project.
  
  App::Project inspire of Minilla(as CPAN module auhtoring tool).
  
  B<THIS IS A DEVELOPMENT RELEASE. API MAY CHANGE WITHOUT NOTICE>.
  
  =head1 GETTING STARTED
  
      # First time only
      # TODO: Provide fat pack tool
      % cpanm App::Project
      # App::Project has only a few deps. It should be very quick
      # Make a new distribution
      % cd /path/to/App/
      % project migrate
      # Git commit
      % git commit -m "initial commit"
      # Hack your code!
      % $EDITOR lib/YourCode
      # Done? Test and release it!
      # Make L<git tag> and update change log for release
      % project release
      # Need more portability tool? We provide to generate L<>
      % project wrapper > bin/project
  
  
  It's that easy.
  
  =head1 NOTE
  
  =head2 Why made?
  
  I need generic authoring tool. (e.g. Android application, HTML5 application, and other)
  
  I was impressed L<Minilla>. And I decide make this project.
  
  =head2 Why Perl?
  
  Perl script is high portability, A lot of operation system is installed Perl. 
  
  Make simple script with comparative ease. I don't have plan to be complex interfaces ;)
  
  =head2 App::Project is built on small libraries.
  
  App::Project is built on only few small libraries. You can install App::Project without a huge list of dependencies to heavy modules.
  
  And dependencies are pure perl or perl core(5.12.0+) only, because to higher portability for I<wrapper> script.
  
  =head1 LICENSE
  
  Copyright (C) ichigotake.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 AUTHOR
  
  ichigotake E<lt>ichigotake.san@gmail.comE<gt>
  
  =head1 SEE ALSO
  
  =item1 L<Minilla>
  
  =cut
  
APP_PROJECT

$fatpacked{"App/Project/BumpVersion.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PROJECT_BUMPVERSION';
  package App::Project::BumpVersion;
  use 5.008001;
  use strict;
  use warnings;
  use ExtUtils::MakeMaker qw(prompt);
  use version;
  use Version::Next;
  use App::Project::Logger;
  
  sub new {
      my $class = shift;
      return bless {@_}, $class;
  }
  
  sub run {
      my ($self, $current_version, $opts) = @_;
      my $validate = $opts->{validate} || 0;
      $current_version //= '0.1';
  
      my $is_valid = version::is_lax($current_version);
      if ($validate) {
          return $is_valid ? $current_version : undef;
      }
      if (!$is_valid) {
          errorf("Sorry, version '%s' is invalid.  Stopping.\n", $current_version);
      }
      return $self->default_new_version($current_version);
  }
  
  sub default_new_version {
      my ($self, $version) = @_;
      @_ == 2 or die;
  
      if (not exists_tag($version)) {
          $version;
      } else {
          return Version::Next::next_version("$version");
      }
  }
  
  sub exists_tag {
      my ( $tag ) = @_;
  
      my $x = `git tag -l $tag`;
      chomp $x;
      return !!$x;
  }
  
  
  1;
  
APP_PROJECT_BUMPVERSION

$fatpacked{"App/Project/CLI.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PROJECT_CLI';
  package App::Project::CLI;
  use strict;
  use warnings;
  use utf8;
  use Getopt::Long;
  use Getopt::Compact::WithCmd;
  use Try::Tiny;
  use App::Project::Errors;
  use App::Project::Logger;
  use App::Project::Util;
  
  sub new {
      my $class = shift;
      return bless {@_}, $class;
  }
  
  sub run {
      my ($self, @args) = @_;
      
      local @ARGV = @args;
      my @commands;
      my $go = Getopt::Compact::WithCmd->new(
          name => 'App::Project',
          version => '0.1',
          global_struct => [],
          command_struct => {
              bump_version => {
                  options => [
                      [ [qw/v validate/], 'validate version format', '!', undef, { default => 0 } ],
                  ],
                  args => 'version',
                  desc => 'bump next version',
              },
              changes => {
                  options => [
                      [ [qw/c check/], 'Check can edit Changes', '!', undef, {default => 0} ],
                      [ [qw/d dry-run/], 'Dry run mode', '!', undef, { default => 0 } ],
                  ],
                  args => 'version',
                  desc => 'Edit and commit Changes',
              },
              release => {
                  options => [
                      [ [qw/d dry-run/], 'Dry run mode', '!', undef, { default => 0 } ],
                  ],
                  args => 'version',
                  desc => 'Make release tag and push',
              },
              untracks => {
                  options => [
                      [ [qw/z/], "\0 line termination on output", "!", undef, { default => 0 } ],
                  ],
                  desc => 'Show untracked files',
              },
          },
      );
  
      my $cmd = $go->command || 'help';
      if ($cmd eq 'help') {
          $go->show_usage;
          exit;
      }
      my $klass = sprintf("App::Project::CLI::%s", camelize($cmd));
  
      ## no critic
      if (eval sprintf("require %s; 1;", $klass)) {
          try {
              $klass->run($go);
          } catch {
              /App::Project::Error::CommandExit/ and return;
              errorf("%s\n", $_);
              exit 1;
          }
      } else {
          warnf("Could not find command '%s'\n", $cmd);
          if ($@ !~ /^Can't locate App::Project/) {
              errorf("$@\n");
          }
          exit 2;
      }
  }
  
  1;
  
APP_PROJECT_CLI

$fatpacked{"App/Project/CLI/BumpVersion.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PROJECT_CLI_BUMPVERSION';
  package App::Project::CLI::BumpVersion;
  use strict;
  use warnings;
  use utf8;
  use App::Project::BumpVersion;
  use version;
  
  sub run {
      my ($self, $command, $args, $options) = @_;
      my $version = shift(@$args) // undef;
      my $res = App::Project::BumpVersion->new()->run($version, $options);
      exit 1 unless $res;
      print $res;
  }
  
  1;
  
APP_PROJECT_CLI_BUMPVERSION

$fatpacked{"App/Project/CLI/Changes.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PROJECT_CLI_CHANGES';
  package App::Project::CLI::Changes;
  use strict;
  use warnings;
  use utf8;
  
  use App::Project;
  use App::Project::Flow::CheckChanges;
  use App::Project::Flow::RewriteChanges;
  use App::Project::Logger;
  
  sub run {
      my ($self, $go) = @_;
      my $version = shift(@{$go->args}) or die 'Must specifies version name!';
      my $project = App::Project->new(version => $version);
      App::Project::Flow::CheckChanges->new()->run($project, $go->opts);
      if ($go->opts->{check} || undef) {
          return;
      }
      App::Project::Flow::RewriteChanges->new()->run($project, $go->opts);
  
  }
  
  1;
  
APP_PROJECT_CLI_CHANGES

$fatpacked{"App/Project/CLI/Release.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PROJECT_CLI_RELEASE';
  package App::Project::CLI::Release;
  use strict;
  use warnings;
  use utf8;
  
  use App::Project;
  use App::Project::Flow::Commit;
  use App::Project::Flow::Tag;
  
  sub run {
      my ($self, $go) = @_;
      my $version = shift(@{$go->args}) or die 'Must specifies version name!';
      my $project = App::Project->new(version => $version);
      App::Project::Flow::Commit->new()->run($project, $go->opts);
      App::Project::Flow::Tag->new()->run($project, $go->opts);
  }
  
  1;
  
APP_PROJECT_CLI_RELEASE

$fatpacked{"App/Project/CLI/Untracks.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PROJECT_CLI_UNTRACKS';
  package App::Project::CLI::Untracks;
  use strict;
  use warnings;
  use utf8;
  use App::Project::Logger;
  use App::Project::CheckUntrackedFiles;
  
  sub run {
      my ($self, $command, $args, $options) = @_;
      my @untracks = App::Project::CheckUntrackedFiles->new()->run();
      if (!@untracks) {
          my $unk = join("\n", @untracks);
          errorf("Unknown local files:\n$unk\n\nUpdate .gitignore, or git add them\n");
      }
      print join("\n", @untracks);
  }
  
  1;
  
APP_PROJECT_CLI_UNTRACKS

$fatpacked{"App/Project/CheckUntrackedFiles.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PROJECT_CHECKUNTRACKEDFILES';
  package App::Project::CheckUntrackedFiles;
  use strict;
  use warnings;
  use utf8;
  
  use App::Project::Logger;
  
  sub new {
      my $class = shift;
      return bless {@_}, $class;
  }
  
  sub run {
      my ($self) = @_;
      my $unk = `git ls-files -z --others --exclude-standard`;
      return split("\0", $unk);
  }
  
  1;
  
  __END__
  
  =encoding utf-8
  
  =head1 NAME
  
  App::Project::CheckUntrackedFiles
  
  =head1 DESCRIPTION
  
  Copy from L<Minilla::Release::CheckUntrackedFiles>.
  
APP_PROJECT_CHECKUNTRACKEDFILES

$fatpacked{"App/Project/Errors.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PROJECT_ERRORS';
  package App::Project::Errors;
  use strict;
  use warnings;
  use utf8;
  
  use Carp ();
  
  package App::Project::Error::CommandExit;
  
  use overload '""' => 'message', fallback => 1;
  
  sub throw {
      my ($class, $body) = @_;
      my $self = bless { body => $body, message => Carp::longmess($class) }, $class;
      die $self;
  }
  
  sub body { shift->{body} }
  
  sub message {
      my($self) = @_;
      return $self->{message};
  }
  
  1;
  
APP_PROJECT_ERRORS

$fatpacked{"App/Project/Flow/CheckChanges.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PROJECT_FLOW_CHECKCHANGES';
  package App::Project::Flow::CheckChanges;
  use strict;
  use warnings;
  use utf8;
  use ExtUtils::MakeMaker qw(prompt);
  
  use App::Project::Util qw(edit_file slurp);
  use App::Project::Logger;
  
  sub new {
      my $class = shift;
      return bless {@_}, $class;
  }
  
  sub run {
      my ($self, $project, $opts) = @_;
      $project->version or die 'Must specifies version name!';
  
      if ($ENV{PERL_APP_PROJECT_CHECK_CHANGE_LOG}) {
          infof("Okay, you are debugging now.\n");
          return;
      }
  
      until (slurp('Changes') =~ /^\{\{\$NEXT\}\}\n+[ \t]+\S/m) {
          infof("No mention of version '%s' in changelog file 'Changes'\n", $project->version);
          if (prompt("Edit file?", 'y') =~ /y/i) {
              edit_file('Changes');
          } else {
              errorf("Giving up!\n");
          }
      }
  }
  
  1;
  
APP_PROJECT_FLOW_CHECKCHANGES

$fatpacked{"App/Project/Flow/Commit.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PROJECT_FLOW_COMMIT';
  package App::Project::Flow::Commit;
  use strict;
  use warnings;
  use utf8;
  
  use App::Project::Util qw(cmd);
  use App::Project::Logger;
  
  sub new {
      my $class = shift;
      return bless {@_}, $class;
  }
  
  sub run {
      my ($self, $project, $opts) = @_;
  
      my @modified_files = split /\0/, `git ls-files --deleted --modified -z`;
      return if @modified_files == 0;
  
      my $ver = $project->version;
  
      my $msg = "Checking in changes prior to tagging of version $ver.\n\nChangelog diff is:\n\n";
      $msg .= `git diff Changes`;
  
      if ($opts->{dry_run}) {
          infof("DRY-RUN.  Would have committed message of:\n----------------\n$msg\n-----------\n");
          return;
      }
  
      cmd('git', 'commit', '-a', '-m', $msg);
  
      $self->_push_to_origin();
  }
  
  sub _push_to_origin {
      my ($self) = @_;
  
      # git v1.7.10 is required?
      my $branch = _get_branch()
          or return;
      $branch =~ s/\n//g;
      infof("Pushing to origin\n");
      cmd('git', 'push', 'origin', $branch);
  }
  
  sub _get_branch {
      open my $fh, '<', '.git/HEAD';
      chomp( my $head = do { local $/; <$fh> });
      close $fh;
  
      my ($branch) = $head =~ m!ref: refs/heads/(\S+)!;
      return $branch;
  }
  
  1;
  
APP_PROJECT_FLOW_COMMIT

$fatpacked{"App/Project/Flow/RewriteChanges.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PROJECT_FLOW_REWRITECHANGES';
  package App::Project::Flow::RewriteChanges;
  use strict;
  use warnings;
  use utf8;
  use App::Project::Util qw(slurp_raw spew_raw);
  
  sub new {
      my $class = shift;
      return bless {@_}, $class;
  }
  
  sub run {
      my ($self, $project, $opts) = @_;
      return if $opts->{dry_run};
  
      my $content = slurp_raw('Changes');
      $content =~ s!\{\{\$NEXT\}\}!
          "{{\$NEXT}}\n\n" . $project->version. " " . $project->changes_time->strftime('%Y-%m-%dT%H:%M:%SZ')
          !e;
      spew_raw('Changes' => $content);
  }
  
  
  1;
  
APP_PROJECT_FLOW_REWRITECHANGES

$fatpacked{"App/Project/Flow/Tag.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PROJECT_FLOW_TAG';
  package App::Project::Flow::Tag;
  use strict;
  use warnings;
  use utf8;
  
  use App::Project::Util qw(cmd);
  use App::Project::Logger;
  
  sub run {
      my ($self, $project, $opts) = @_;
      my $version = $project->version;
  
      if ( $opts->{dry_run} ) {
          infof("DRY-RUN.  Would have tagged version $version.\n");
          return;
      }
  
      my $tag = $project->format_tag($version);
      cmd('git', 'tag', $tag);
      cmd('git', "push", 'origin', tag => $tag);
  }
  
  1;
  
APP_PROJECT_FLOW_TAG

$fatpacked{"App/Project/Git.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PROJECT_GIT';
  package App::Project::Git;
  use strict;
  use warnings;
  use utf8;
  
  use parent qw(Exporter);
  use App::Project::Util;
  
  our @EXPORT = qw(git_init git_add git_commit);
  
  sub git_init {
      cmd('git', 'init');
  }
  
  sub git_add {
      cmd('git', 'add', @_ ? @_ : '.');
  }
  
  sub git_commit {
      cmd('git', 'commit', @_);
  }
  
  1;
  
APP_PROJECT_GIT

$fatpacked{"App/Project/Logger.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PROJECT_LOGGER';
  package App::Project::Logger;
  use 5.008001;
  use strict;
  use warnings;
  use utf8;
  use parent qw(Exporter);
  
  use Term::ANSIColor qw(colored);
  require Win32::Console::ANSI if $^O eq 'MSWin32';
  
  use App::Project::Errors;
  
  our @EXPORT = qw(debugf infof warnf errorf);
  
  our $COLOR;
  
  use constant { DEBUG => 1, INFO => 2, WARN => 3, ERROR => 4 };
  
  our $Colors = {
      DEBUG,   => 'green',
      WARN,    => 'yellow',
      INFO,    => 'cyan',
      ERROR,   => 'red',
  };
  
  sub _printf {
      my $type = pop;
      my($temp, @args) = @_;
      _print(sprintf($temp, map { defined($_) ? $_ : '-' } @args), $type);
  }
  
  sub _print {
      my($msg, $type) = @_;
      return if $type == DEBUG && !App::Project->debug;
      $msg = colored $msg, $Colors->{$type} if defined $type && $COLOR;
      my $fh = $type && $type >= WARN ? *STDERR : *STDOUT;
      print {$fh} $msg;
  }
  
  sub infof {
      _printf(@_, INFO);
  }
  
  sub warnf {
      _printf(@_, WARN);
  }
  
  sub debugf {
      _printf(@_, DEBUG);
  }
  
  sub errorf {
      my(@msg) = @_;
      _printf(@msg, ERROR);
  
      my $fmt = shift @msg;
      App::Project::Error::CommandExit->throw(sprintf($fmt, @msg));
  }
  
  1;
  
APP_PROJECT_LOGGER

$fatpacked{"App/Project/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PROJECT_UTIL';
  package App::Project::Util;
  use strict;
  use warnings;
  use utf8;
  use parent qw(Exporter);
  
  use App::Project::Logger;
  use Cwd();
  
  our @EXPORT = qw(camelize cmd edit_file slurp slurp_raw spew_raw);
  
  sub camelize {
      my ($target) = @_;
      $target =~ s/(_|^)(.)/\u$2/g;
      return $target;
  }
  
  sub cmd {
      App::Project::Logger::infof("[%s] \$ %s\n", File::Basename::basename(Cwd::getcwd()), "@_");
      system(@_) == 0
          or App::Project::Logger::errorf("Giving up.\n");
  }
  
  sub edit_file {
      my ($file) = @_;
      my $editor = $ENV{"EDITOR"} || "vi";
      system( $editor, $file );
  }
  
  sub slurp {
      my $fname = shift;
      open my $fh, '<', $fname
          or Carp::croak("Can't open '$fname' for reading: '$!'");
      scalar do { local $/; <$fh> }
  }
  
  sub slurp_raw {
      my $fname = shift;
      open my $fh, '<:raw', $fname
          or Carp::croak("Can't open '$fname' for reading: '$!'");
      scalar do { local $/; <$fh> }
  }
  
  sub spew_raw {
      my $fname = shift;
      open my $fh, '>:raw', $fname
          or Carp::croak("Can't open '$fname' for writing: '$!'");
      print {$fh} $_[0];
  }
  
  1;
  
APP_PROJECT_UTIL

$fatpacked{"Getopt/Compact/WithCmd.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GETOPT_COMPACT_WITHCMD';
  package Getopt::Compact::WithCmd;use strict;use warnings;use 5.008_001;use Data::Dumper ();use List::Util qw(max);use Getopt::Long qw(GetOptionsFromArray);use Carp ();use constant DEFAULT_CONFIG=>(no_auto_abbrev=>1,no_ignore_case=>1,bundling=>1,);our$VERSION='0.22';my$TYPE_MAP={'Bool'=>'!','Incr'=>'+','Str'=>'=s','Int'=>'=i','Num'=>'=f','ExNum'=>'=o',};my$TYPE_GEN={};sub new {my ($class,%args)=@_;my$self=bless {cmd=>$args{cmd}|| do {require File::Basename;File::Basename::basename($0)},name=>$args{name},version=>$args{version}|| $::VERSION,modes=>$args{modes},opt=>{},usage=>exists$args{usage}&&!$args{usage}? 0 : 1,args=>$args{args}|| '',_argv=>\@ARGV,struct=>[],summary=>{},requires=>{},ret=>0,error=>undef,other_usage=>undef,commands=>[],_struct=>$args{command_struct}|| {},},$class;my%config=(DEFAULT_CONFIG,%{$args{configure}|| {}});my@gconf=grep$config{$_},keys%config;Getopt::Long::Configure(@gconf)if@gconf;$self->_init_summary($args{command_struct});$self->_init_struct($args{global_struct}|| []);my$opthash=$self->_parse_struct || return$self;if ($args{command_struct}){if (my@gopts=$self->_parse_argv){$self->{ret}=$self->_parse_option(\@gopts,$opthash);unshift@ARGV,@gopts;return$self unless$self->{ret};return$self if$self->_want_help}$self->_check_requires}else {$self->{ret}=$self->_parse_option(\@ARGV,$opthash);return$self unless$self->{ret};return$self if$self->_want_help;$self->_check_requires;return$self}$self->_parse_command_struct($args{command_struct});return$self}sub new_from_array {my ($class,$args,%options)=@_;unless (ref$args eq 'ARRAY'){Carp::croak("Usage: $class->new_from_array(\\\@args, %options)")}local*ARGV=$args;return$class->new(%options)}sub new_from_string {my ($class,$str,%options)=@_;unless (defined$str){Carp::croak("Usage: $class->new_from_string(\$str, %options)")}require Text::ParseWords;my$args=[Text::ParseWords::shellwords($str)];local*ARGV=$args;return$class->new(%options)}sub args {$_[0]->{_argv}}sub error {$_[0]->{error}||''}sub command {$_[0]->{command}}sub commands {$_[0]->{commands}}sub status {$_[0]->{ret}}sub is_success {$_[0]->{ret}}sub pod2usage {Carp::carp('Not implemented')}sub opts {my($self)=@_;my$opt=$self->{opt};if ($self->{usage}&& ($opt->{help}|| $self->status==0)){print$self->usage;exit!$self->status}return$opt}sub usage {my($self,@targets)=@_;my$usage='';my(@help,@commands);if ((defined$self->command && $self->command eq 'help')|| @targets){delete$self->{command};@targets=@{$self->{_argv}}unless@targets;for (my$i=0;$i < @targets;$i++){my$target=$targets[$i];last unless defined$target;unless (ref$self->{_struct}{$target}eq 'HASH'){$self->{error}="Unknown command: $target";last}else {$self->{command}=$target;push @{$self->{commands}},$target;$self->_init_struct($self->{_struct}{$target}{options});$self->_extends_usage($self->{_struct}{$target});if (ref$self->{_struct}{$target}{command_struct}eq 'HASH'){$self->{_struct}=$self->{_struct}{$target}{command_struct}}else {$self->{summary}={}}}}}my($name,$version,$cmd,$struct,$args,$summary,$error,$other_usage)=map $self->{$_}|| '',qw/name version cmd struct args summary error other_usage/;$usage .= "$error\n" if$error;if ($name){$usage .= $name;$usage .= " v$version" if$version;$usage .= "\n"}if ($self->command && $self->command ne 'help'){my$sub_command=join q{ },@{$self->commands}? @{$self->commands}: $self->command;$usage .= "usage: $cmd $sub_command [options]"}else {$usage .= "usage: $cmd [options]";$usage .= ' COMMAND' if keys %$summary}$usage .= ($args ? " $args" : '')."\n\n";for my$o (@$struct){my ($name_spec,$desc,$arg_spec,$dist,$opts)=@$o;$desc='' unless defined$desc;my@onames=$self->_option_names($name_spec);my$optname=join (', ',map {(length($_)> 1 ? '--' : '-').$_}@onames);$optname='    '.$optname unless length($onames[0])==1;my$info=do {local$Data::Dumper::Indent=0;local$Data::Dumper::Terse=1;my$info=[];push @$info,$self->_opt_spec2name($arg_spec)|| $arg_spec || '';push @$info,$opts->{required}? "(required)" : '';push @$info,defined$opts->{default}? "(default: ".Data::Dumper::Dumper($opts->{default}).")" : '';$info};push@help,[$optname,$info,ucfirst($desc)]}if (@help){require Text::Table;my$sep=\'   ';$usage .= "options:\n";$usage .= Text::Table->new($sep,'',$sep,'',$sep,'')->load($self->_format_info(@help))->stringify."\n"}if (defined$other_usage && length$other_usage > 0){$other_usage =~ s/\n$//ms;$usage .= "$other_usage\n\n"}if (!$self->command || $self->{has_sub_command}){for my$command (sort keys %$summary){push@commands,[$command,ucfirst$summary->{$command}]}if (@commands){require Text::Table;my$sep=\'   ';$usage .= "Implemented commands are:\n";$usage .= Text::Table->new($sep,'',$sep,'')->load(@commands)->stringify."\n";my$help_command="$cmd help COMMAND";if (@{$self->commands}){my$sub_commands=join q{ },@{$self->commands};$help_command="$cmd $sub_commands COMMAND --help"}$usage .= "See '$help_command' for more information on a specific command.\n\n"}}return$usage}sub show_usage {my$self=shift;print$self->usage(@_);exit!$self->status}sub completion {my($self,$shell)=@_;$shell ||= 'bash';if ($shell eq 'bash'){return$self->_completion_bash}else {Carp::carp("Not implemented: completion for $shell");return ""}}sub show_completion {my$self=shift;print$self->completion(@_);exit!$self->status}sub _completion_bash {my$self=shift;my$comp='';my$prog=$self->{name}|| substr($0,rindex($0,'/')+1);my$fname=$prog;$fname =~ s/[.-]/_/g;my@global_opts;my@commands;my$case={word=>'"$cmd"',cases=>[],};@global_opts=$self->_options2optarg($self->{struct});for my$cmd (sort keys %{$self->{_struct}}){my$s=$self->{_struct}{$cmd};my@opts=$self->_options2optarg($s->{options});my@commands2;if (ref$s->{command_struct}eq 'HASH'){for my$cmd (sort keys %{$s->{command_struct}}){my$s=$s->{command_struct}{$cmd};my@opts=$self->_options2optarg($s->{options});push@commands2,{cmd=>$cmd,opts=>\@opts,}}}push@commands,{cmd=>$cmd,opts=>\@opts,subcmd=>\@commands2,args=>($s->{args}|| ''),}}$comp .= "_$fname() {\n";$comp .= <<'EOC';$comp .= sprintf qq{  local global_opts="%s"\n},join(" ",map {@{$_->{opt}}}@global_opts);$comp .= sprintf qq{  local cmds="%s"\n},join(" ",map {$_->{cmd}}@commands);$comp .= "\n";for my$command (@commands){my$case_prev={word=>'"$prev"',cases=>[_opts2casecmd(@{$command->{opts}}),{pat=>'*',cmd=>['COMPREPLY=($(compgen -W "'._gen_wordlist($command).'" -- "$cur"))'],},],};if (scalar(@{$command->{subcmd}})> 0){my@cases;for my$subcommand (@{$command->{subcmd}}){next if (scalar(@{$subcommand->{opts}})<= 0);push@cases,{pat=>$subcommand->{cmd},cmd=>[{word=>'"$prev"',cases=>[_opts2casecmd(@{$subcommand->{opts}}),{pat=>'*',cmd=>['COMPREPLY=($(compgen -W "'._gen_wordlist($subcommand).'" -- "$cur"))'],},],}],}}push@cases,{pat=>'*',cmd=>[$case_prev ],};push @{$case->{cases}},{pat=>$command->{cmd},cmd=>[{word=>'"${cmd[1]}"',cases=>[@cases],}],}}else {push @{$case->{cases}},{pat=>$command->{cmd},cmd=>[$case_prev ],}}}push @{$case->{cases}},{pat=>'*',cmd=>[{word=>'"$prev"',cases=>[_opts2casecmd(@global_opts),{pat=>'*',cmd=>['COMPREPLY=($(compgen -W "$global_opts $cmds" -- "$cur"))'],},],}],};my@c=_generate_case_command($case);$comp .= join("\n",map {"  ".$_}@c)."\n";$comp .= <<"EOC";return$comp}sub _generate_case_command {my$case=shift;my@line;push@line,"case $case->{word} in";for my$c (@{$case->{cases}}){push@line,"  $c->{pat})";for my$cmd (@{$c->{cmd}},';;'){if (ref$cmd eq 'HASH'){push@line,map {"    ".$_}_generate_case_command->($cmd)}else {push@line,"    ".$cmd}}}push@line,"esac";return@line}sub _options2optarg {my($self,$opts)=@_;my@optarg;for my$o (@{$opts}){my ($name_spec,$desc,$arg_spec,$dist,$opts)=@$o;my@onames=map {(length($_)> 1 ? '--' : '-').$_}$self->_option_names($name_spec);my$arg=$self->_opt_spec2name($arg_spec)|| $arg_spec || '';$arg='' if$arg eq 'Incr';push@optarg,{opt=>\@onames,arg=>$arg,}}return@optarg}sub _opts2casecmd {my@cases;for my$o (grep {$_->{arg}}@_){push@cases,{pat=>join("|",@{$o->{opt}}),cmd=>['COMPREPLY=($(compgen -W "'.$o->{arg}.'" -- "$cur"))'],}}return@cases}sub _gen_wordlist {my$command=shift;return join(" ",'-h','--help',(map {@{$_->{opt}}}@{$command->{opts}}),($command->{args}||''),(map {$_->{cmd}}@{$command->{subcmd}}),)}sub _opt_spec2name {my ($self,$spec)=@_;my$name='';return$name unless defined$spec;my ($type,$dest)=$spec =~ /^[=:]?([!+isof])([@%])?/;if ($type){$name=$type eq '!' ? 'Bool' : $type eq '+' ? 'Incr' : $type eq 's' ? 'Str' : $type eq 'i' ? 'Int' : $type eq 'f' ? 'Num' : $type eq 'o' ? 'ExNum' : ''}if ($dest){$name=$dest eq '@' ? "Array[$name]" : $dest eq '%' ? "Hash[$name]" : $name}return$name}sub _format_info {my ($self,@help)=@_;my$type_max=0;my$required_max=0;my$default_max=0;for my$row (@help){my ($type,$required,$default)=@{$row->[1]};$type_max=max$type_max,length($type);$required_max=max$required_max,length($required);$default_max=max$default_max,length($default)}for my$row (@help){my ($type,$required,$default)=@{$row->[1]};my$parts=[];for my$stuff ([$type_max,$type],[$required_max,$required],[$default_max,$default]){push @$parts,sprintf '%-*s',@$stuff if$stuff->[0]> 0}$row->[1]=join ' ',@$parts}return@help}sub _parse_command_struct {my ($self,$command_struct)=@_;$command_struct ||= {};my$command_map={map {$_=>1}keys %$command_struct };my$command=shift@ARGV;unless (defined$command){$self->{ret}=$self->_check_requires;return$self}unless ($command_map->{help}){$command_map->{help}=1;$command_struct->{help}={args=>'[COMMAND]',desc=>'show help message',}}unless (exists$command_map->{$command}){$self->{error}="Unknown command: $command";$self->{ret}=0;return$self}$self->{command}||= $command;if ($command eq 'help'){$self->{ret}=0;delete$self->{error};if (defined$ARGV[0]&& exists$command_struct->{$ARGV[0]}){my$nested_struct=$command_struct->{$ARGV[0]}{command_struct};$self->_init_nested_struct($nested_struct)if$nested_struct}return$self}push @{$self->{commands}||= []},$command;$self->_init_struct($command_struct->{$command}{options});$self->_extends_usage($command_struct->{$command});my$opthash=$self->_parse_struct || return$self;if (my$nested_struct=$command_struct->{$command}{command_struct}){$self->_init_nested_struct($nested_struct);my@opts=$self->_parse_argv($nested_struct);$self->{ret}=$self->_parse_option(\@opts,$opthash);unshift@ARGV,@opts;$self->_check_requires;if ($self->_want_help){delete$self->{error};$self->{ret}=0}return$self unless$self->{ret};$self->_parse_command_struct($nested_struct)}else {$self->{ret}=$self->_parse_option(\@ARGV,$opthash);$self->_check_requires;$self->{has_sub_command}=0;if ($self->_want_help){delete$self->{error};$self->{ret}=0}}return$self}sub _want_help {exists $_[0]->{opt}{help}&& $_[0]->{opt}{help}? 1 : 0}sub _init_nested_struct {my ($self,$nested_struct)=@_;$self->{summary}={};$self->_init_summary($nested_struct);$self->{has_sub_command}=1}sub _parse_option {my ($self,$argv,$opthash)=@_;local$SIG{__WARN__}=sub {$self->{error}=join '',@_;chomp$self->{error}};my$ret=GetOptionsFromArray($argv,%$opthash)? 1 : 0;$self->{parsed_opthash}=$opthash;return$ret}sub _parse_argv {my ($self,$struct)=@_;$struct ||= $self->{_struct};my@opts;while (@ARGV){my$argv=shift@ARGV;push@opts,$argv;last if exists$struct->{$argv}}return@opts}sub _parse_struct {my ($self)=@_;my$struct=$self->{struct};my$opthash={};my$default_opthash={};my$default_args=[];for my$s (@$struct){my($m,$descr,$spec,$ref,$opts)=@$s;my@onames=$self->_option_names($m);my($longname)=grep length($_)> 1,@onames;my ($type,$cb)=$self->_compile_spec($spec);my$o=join('|',@onames).($type||'');my$dest=$longname ? $longname : $onames[0];$opts ||= {};my$destination;if (ref$cb eq 'CODE'){my$t=substr($type,-1,1)eq '@' ? 'Array' : substr($type,-1,1)eq '%' ? 'Hash' : '';if (ref$ref eq 'CODE'){$destination=sub {$ref->($_[0],$cb->($_[1]))}}elsif (ref$ref){if (ref$ref eq 'SCALAR' || ref$ref eq 'REF'){$$ref=$t eq 'Array' ? []: $t eq 'Hash' ? {}: undef}elsif (ref$ref eq 'ARRAY'){@$ref=()}elsif (ref$ref eq 'HASH'){%$ref=()}$destination=sub {if ($t eq 'Array'){if (ref$ref eq 'SCALAR' || ref$ref eq 'REF'){push @{$$ref},scalar$cb->($_[1])}elsif (ref$ref eq 'ARRAY'){push @$ref,scalar$cb->($_[1])}elsif (ref$ref eq 'HASH'){my@kv=split '=',$_[1],2;die qq(Option $_[0], key "$_[1]", requires a value\n) unless@kv==2;$ref->{$kv[0]}=scalar$cb->($kv[1])}}elsif ($t eq 'Hash'){if (ref$ref eq 'SCALAR' || ref$ref eq 'REF'){$$ref->{$_[1]}=scalar$cb->($_[2])}elsif (ref$ref eq 'ARRAY'){push @$ref,$_[1],scalar$cb->($_[2])}elsif (ref$ref eq 'HASH'){$ref->{$_[1]}=scalar$cb->($_[2])}}else {if (ref$ref eq 'SCALAR' || ref$ref eq 'REF'){$$ref=$cb->($_[1])}elsif (ref$ref eq 'ARRAY'){@$ref=(scalar$cb->($_[1]))}elsif (ref$ref eq 'HASH'){my@kv=split '=',$_[1],2;die qq(Option $_[0], key "$_[1]", requires a value\n) unless@kv==2;%$ref=($kv[0]=>scalar$cb->($kv[1]))}}}}else {$destination=sub {if ($t eq 'Array'){$self->{opt}{$dest}||= [];push @{$self->{opt}{$dest}},scalar$cb->($_[1])}elsif ($t eq 'Hash'){$self->{opt}{$dest}||= {};$self->{opt}{$dest}{$_[1]}=$cb->($_[2])}else {$self->{opt}{$dest}=$cb->($_[1])}}}}else {$destination=ref$ref ? $ref : \$self->{opt}{$dest}}if (exists$opts->{default}){my$value=$opts->{default};if (ref$value eq 'ARRAY'){push @$default_args,map {("--$dest",$_)}grep {defined $_}@$value}elsif (ref$value eq 'HASH'){push @$default_args,map {(my$key=$_)=~ s/=/\\=/g;("--$dest"=>"$key=$value->{$_}")}grep {defined$value->{$_}}keys %$value}elsif (not ref$value){if (!$spec || ($TYPE_MAP->{$spec}|| $spec)eq '!'){push @$default_args,"--$dest" if$value}else {push @$default_args,"--$dest",$value if defined$value}}else {$self->{error}="Invalid default option for $dest";$self->{ret}=0}$default_opthash->{$o}=$destination}$opthash->{$o}=$destination;$self->{requires}{$dest}=$o if$opts->{required}}return if$self->{error};if (@$default_args){$self->{ret}=$self->_parse_option($default_args,$default_opthash);unshift@ARGV,@$default_args;return unless$self->{ret}}return$opthash}sub _init_struct {my ($self,$struct)=@_;$self->{struct}=ref$struct eq 'ARRAY' ? $struct : ref$struct eq 'HASH' ? $self->_normalize_struct($struct): [];if (ref$self->{modes}eq 'ARRAY'){my@modeopt;for my$m (@{$self->{modes}}){my($mc)=$m =~ /^(\w)/;push@modeopt,[[$mc,$m],qq($m mode)]}unshift @$struct,@modeopt}unshift @{$self->{struct}},[[qw(h help)],qq(this help message)]if$self->{usage}&&!$self->_has_option('help')}sub _normalize_struct {my ($self,$struct)=@_;my$result=[];for my$option (keys %$struct){my$data=$struct->{$option}|| {};$data=ref$data eq 'HASH' ? $data : {};my$row=[];push @$row,[$option,ref$data->{alias}eq 'ARRAY' ? @{$data->{alias}}: defined$data->{alias}? $data->{alias}: (),];push @$row,$data->{desc};push @$row,$data->{type};push @$row,$data->{dest};push @$row,$data->{opts};push @$result,$row}return$result}sub _compile_spec {my ($self,$spec)=@_;return if!defined$spec or $spec eq '';return$spec if$self->_opt_spec2name($spec);my ($type,$cb);if ($spec =~ /^(Array|Hash)\[(\w+)\]$/){$type=$TYPE_MAP->{$2}|| Carp::croak("Can't find type constraint '$2'");$type .= $1 eq 'Array' ? '@' : '%';$cb=$TYPE_GEN->{$2}}elsif ($type=$TYPE_MAP->{$spec}){$cb=$TYPE_GEN->{$spec}}else {Carp::croak("Can't find type constraint '$spec'")}return$type,$cb}sub add_type {my ($class,$name,$src_type,$cb)=@_;unless (defined$name && $src_type && ref$cb eq 'CODE'){Carp::croak("Usage: $class->add_type(\$name, \$src_type, \$cb)")}unless ($TYPE_MAP->{$src_type}){Carp::croak("$src_type is not defined src type")}$TYPE_MAP->{$name}=$TYPE_MAP->{$src_type};$TYPE_GEN->{$name}=$cb}sub _init_summary {my ($self,$command_struct)=@_;if ($command_struct){for my$key (keys %$command_struct){$self->{summary}{$key}=$command_struct->{$key}->{desc}|| ''}}else {$self->{summary}={}}}sub _extends_usage {my ($self,$command_option)=@_;for my$key (qw/args other_usage/){$self->{$key}=$command_option->{$key}if exists$command_option->{$key}}}sub _check_requires {my ($self)=@_;for my$dest (sort keys %{$self->{requires}}){unless (defined$self->{opt}{$dest}){unless (defined ${$self->{parsed_opthash}{$self->{requires}{$dest}}}){$self->{ret}=0;$self->{error}="`--$dest` option must be specified";return 0}}}return 1}sub _option_names {my($self,$m)=@_;my@sorted=sort {my ($la,$lb)=(length($a),length($b));return$la <=> $lb if$la < 2 or $lb < 2;return 0}ref$m eq 'ARRAY' ? @$m : $m;return@sorted}sub _has_option {my($self,$option)=@_;return 1 if grep {$_ eq $option}map {$self->_option_names($_->[0])}@{$self->{struct}};return 0}1;
    COMPREPLY=()
    local cur=${COMP_WORDS[COMP_CWORD]}
    local prev=${COMP_WORDS[COMP_CWORD-1]}
    local cmd=()
    for ((i=1; i<COMP_CWORD; i++)); do
      # skip global opts and type to find cmd
      if [[ "${COMP_WORDS[$i]}" != -* && "${COMP_WORDS[$i]}" != [A-Z]* ]]; then
        cmd[${#cmd[@]}]=${COMP_WORDS[$i]}
      fi
    done
  
  EOC
  }
  
  complete -F _$fname $prog
  EOC
GETOPT_COMPACT_WITHCMD

$fatpacked{"Try/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TRY_TINY';
  package Try::Tiny;BEGIN {$Try::Tiny::AUTHORITY='cpan:NUFFIN'}$Try::Tiny::VERSION='0.22';use 5.006;use strict;use warnings;use Exporter 5.57 'import';our@EXPORT=our@EXPORT_OK=qw(try catch finally);use Carp;$Carp::Internal{+__PACKAGE__}++;BEGIN {eval "use Sub::Name; 1" or *{subname}=sub {1}}sub try (&;@) {my ($try,@code_refs)=@_;my$wantarray=wantarray;my ($catch,@finally)=();for my$code_ref (@code_refs){if (ref($code_ref)eq 'Try::Tiny::Catch'){croak 'A try() may not be followed by multiple catch() blocks' if$catch;$catch=${$code_ref}}elsif (ref($code_ref)eq 'Try::Tiny::Finally'){push@finally,${$code_ref}}else {croak('try() encountered an unexpected argument (' .(defined$code_ref ? $code_ref : 'undef').') - perhaps a missing semi-colon before or')}}my$caller=caller;subname("${caller}::try {...} "=>$try);subname("${caller}::catch {...} "=>$catch)if$catch;subname("${caller}::finally {...} "=>$_)foreach@finally;my$prev_error=$@;my (@ret,$error);my$failed=not eval {$@=$prev_error;if ($wantarray){@ret=$try->()}elsif (defined$wantarray){$ret[0]=$try->()}else {$try->()};return 1};$error=$@;$@=$prev_error;my@guards=map {Try::Tiny::ScopeGuard->_new($_,$failed ? $error : ())}@finally;if ($failed){if ($catch){for ($error){return$catch->($error)}}return}else {return$wantarray ? @ret : $ret[0]}}sub catch (&;@) {my ($block,@rest)=@_;croak 'Useless bare catch()' unless wantarray;return (bless(\$block,'Try::Tiny::Catch'),@rest,)}sub finally (&;@) {my ($block,@rest)=@_;croak 'Useless bare finally()' unless wantarray;return (bless(\$block,'Try::Tiny::Finally'),@rest,)}{package Try::Tiny::ScopeGuard;use constant UNSTABLE_DOLLARAT=>($] < '5.013002')? 1 : 0;sub _new {shift;bless [@_ ]}sub DESTROY {my ($code,@args)=@{$_[0]};local $@ if UNSTABLE_DOLLARAT;eval {$code->(@args);1}or do {warn "Execution of finally() block $code resulted in an exception, which " .'*CAN NOT BE PROPAGATED* due to fundamental limitations of Perl. ' .'Your program will continue as if this event never took place. ' ."Original exception text follows:\n\n" .(defined $@ ? $@ : '$@ left undefined...')."\n" }}}__PACKAGE__ 
TRY_TINY

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
     if (my $fat = $_[0]{$_[1]}) {
       return sub {
         return 0 unless length $fat;
         $fat =~ s/^([^\n]*\n?)//;
         $_ = $1;
         return 1;
       };
     }
     return;
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE

#!/usr/bin/env perl
use strict;
use warnings;
use App::Project::CLI;

App::Project::CLI->new()->run(@ARGV);

